
========================================================================

** ELF Header Information

    File Name: E:\PAN211X\pan211_sdk_wiki\PAN216x-DK-v2.1.1\PAN216x-DK-v2.1.1\01_SDK\example\01_normal_setup\rx\keil\Objects\rx.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x000000f1
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_SOFT (0x05000202)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Soft float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 6 (build 750) Tool: armasm [4d35ec]
    Component: ARM Compiler 5.06 update 6 (build 750) Tool: armlink [4d35ed]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 1
    Section header entries: 16

    Program header offset: 402004 (0x00062254)
    Section header offset: 402036 (0x00062274)

    Section header string table index: 15

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 11460 bytes (9364 bytes in file)
    Virtual address: 0x00000000 (Alignment 8)


========================================================================

** Section #1 'ER_IROM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 9228 bytes (alignment 4)
    Address: 0x00000000

    $d.realdata
    RESET
    __Vectors
        0x00000000:    200008b8    ...     DCD    536873144
        0x00000004:    000000f1    ....    DCD    241
        0x00000008:    000000f9    ....    DCD    249
        0x0000000c:    000000d5    ....    DCD    213
        0x00000010:    00000000    ....    DCD    0
        0x00000014:    00000000    ....    DCD    0
        0x00000018:    00000000    ....    DCD    0
        0x0000001c:    00000000    ....    DCD    0
        0x00000020:    00000000    ....    DCD    0
        0x00000024:    00000000    ....    DCD    0
        0x00000028:    00000000    ....    DCD    0
        0x0000002c:    000000fd    ....    DCD    253
        0x00000030:    00000000    ....    DCD    0
        0x00000034:    00000000    ....    DCD    0
        0x00000038:    000000ff    ....    DCD    255
        0x0000003c:    00000101    ....    DCD    257
        0x00000040:    00000103    ....    DCD    259
        0x00000044:    00000103    ....    DCD    259
        0x00000048:    00000103    ....    DCD    259
        0x0000004c:    00000103    ....    DCD    259
        0x00000050:    00000103    ....    DCD    259
        0x00000054:    00000103    ....    DCD    259
        0x00000058:    00000103    ....    DCD    259
        0x0000005c:    00000103    ....    DCD    259
        0x00000060:    00001669    i...    DCD    5737
        0x00000064:    00000103    ....    DCD    259
        0x00000068:    00000103    ....    DCD    259
        0x0000006c:    00000103    ....    DCD    259
        0x00000070:    00000103    ....    DCD    259
        0x00000074:    00000103    ....    DCD    259
        0x00000078:    00000103    ....    DCD    259
        0x0000007c:    00000103    ....    DCD    259
        0x00000080:    00000103    ....    DCD    259
        0x00000084:    00000103    ....    DCD    259
        0x00000088:    00000103    ....    DCD    259
        0x0000008c:    00000103    ....    DCD    259
        0x00000090:    00000103    ....    DCD    259
        0x00000094:    00000103    ....    DCD    259
        0x00000098:    00000103    ....    DCD    259
        0x0000009c:    00000000    ....    DCD    0
        0x000000a0:    00000103    ....    DCD    259
        0x000000a4:    00000103    ....    DCD    259
        0x000000a8:    00000103    ....    DCD    259
        0x000000ac:    00000103    ....    DCD    259
        0x000000b0:    00000103    ....    DCD    259
        0x000000b4:    00000103    ....    DCD    259
        0x000000b8:    00000103    ....    DCD    259
        0x000000bc:    00000103    ....    DCD    259
    $t
    .ARM.Collect$$$$00000000
    .ARM.Collect$$$$00000001
    __Vectors_End
    __main
    _main_stk
        0x000000c0:    4803        .H      LDR      r0,__lit__00000000 ; [0xd0] = 0x200008b8
        0x000000c2:    4685        .F      MOV      sp,r0
    .ARM.Collect$$$$00000004
    _main_scatterload
        0x000000c4:    f000f8d8    ....    BL       __scatterload ; 0x278
    .ARM.Collect$$$$00000008
    .ARM.Collect$$$$0000000A
    .ARM.Collect$$$$0000000B
    __main_after_scatterload
    _main_clock
    _main_cpp_init
    _main_init
        0x000000c8:    4800        .H      LDR      r0,[pc,#0] ; [0xcc] = 0x1c9d
        0x000000ca:    4700        .G      BX       r0
    $d
        0x000000cc:    00001c9d    ....    DCD    7325
    .ARM.Collect$$$$00002712
    __lit__00000000
    .ARM.Collect$$$$0000000D
    .ARM.Collect$$$$0000000F
    __rt_final_cpp
    __rt_final_exit
        0x000000d0:    200008b8    ...     DCD    536873144
    $t
    .emb_text
    HardFault_Handler
;;;72         MOVS    r0, #4
        0x000000d4:    2004        .       MOVS     r0,#4
;;;73         MOV     r1, LR
        0x000000d6:    4671        qF      MOV      r1,lr
;;;74         TST     r0, r1
        0x000000d8:    4208        .B      TST      r0,r1
;;;75         BEQ     Stack_Use_MSP
        0x000000da:    d002        ..      BEQ      0xe2 ; HardFault_Handler + 14
;;;76         MRS     R0, PSP ;stack use PSP
        0x000000dc:    f3ef8009    ....    MRS      r0,PSP
;;;77         B       Get_LR_and_Branch
        0x000000e0:    e001        ..      B        0xe6 ; HardFault_Handler + 18
;;;78     Stack_Use_MSP
;;;79         MRS     R0, MSP ; stack use MSP
        0x000000e2:    f3ef8008    ....    MRS      r0,MSP
;;;80     Get_LR_and_Branch
;;;81         MOV     R1, LR ; LR current value
        0x000000e6:    4671        qF      MOV      r1,lr
;;;82         LDR     R2,=__cpp(Hard_Fault_Handler)
        0x000000e8:    4a00        .J      LDR      r2,[pc,#0] ; [0xec] = 0x8b1
;;;83         BX      R2
        0x000000ea:    4710        .G      BX       r2
    $d
        0x000000ec:    000008b1    ....    DCD    2225
    $t
    .text
    Reset_Handler
;;; ..\..\..\..\pan108\device\Source\arm\startup_PANSeries.s
;;;100                     LDR     R0, =SystemInit
        0x000000f0:    4804        .H      LDR      r0,[pc,#16] ; [0x104] = 0x15d5
;;;101                     BLX     R0
        0x000000f2:    4780        .G      BLX      r0
;;;102                     LDR     R0, =__main
        0x000000f4:    4804        .H      LDR      r0,[pc,#16] ; [0x108] = 0xc1
;;;103                     BX      R0
        0x000000f6:    4700        .G      BX       r0
    NMI_Handler
;;;104                     ENDP
;;;105    
;;;106    ; Dummy Exception Handlers (infinite loops which can be modified)
;;;107    
;;;108    NMI_Handler     PROC
;;;109                    EXPORT  NMI_Handler                [WEAK]
;;;110                    B       .
        0x000000f8:    e7fe        ..      B        NMI_Handler ; 0xf8
;;;111                    ENDP
;;;112    HardFault_Handler\
;;;113                    PROC
;;;114                    EXPORT  HardFault_Handler          [WEAK]
;;;115                    B       .
        0x000000fa:    e7fe        ..      B        0xfa ; NMI_Handler + 2
    SVC_Handler
;;;116                    ENDP
;;;117    SVC_Handler     PROC
;;;118                    EXPORT  SVC_Handler                [WEAK]
;;;119                    B       .
        0x000000fc:    e7fe        ..      B        SVC_Handler ; 0xfc
    PendSV_Handler
;;;120                    ENDP
;;;121    PendSV_Handler  PROC
;;;122                    EXPORT  PendSV_Handler             [WEAK]
;;;123                    B       .
        0x000000fe:    e7fe        ..      B        PendSV_Handler ; 0xfe
    SysTick_Handler
;;;124                    ENDP
;;;125    SysTick_Handler PROC
;;;126                    EXPORT  SysTick_Handler            [WEAK]
;;;127                    B       .
        0x00000100:    e7fe        ..      B        SysTick_Handler ; 0x100
    ACC_IRQHandler
    ADC_IRQHandler
    BOD_IRQHandler
    DMA_IRQHandler
    EXT0_IRQHandler
    EXT1_IRQHandler
    EXT2_IRQHandler
    GPIO_IRQHandler
    I2C0_IRQHandler
    I2S_IRQHandler
    KSCAN_IRQHandler
    LL_IRQHandler
    MODEM_IRQHandler
    PWM0_IRQHandler
    PWM1_IRQHandler
    PWM2_IRQHandler
    QDEC_IRQHandler
    RSVD_IRQHandler
    SLEEP_IRQHandler
    SPI0_IRQHandler
    SPI1_IRQHandler
    STANDBY_IRQHandler
    TMR1_IRQHandler
    TMR2_IRQHandler
    TRIM_IRQHandler
    UART0_IRQHandler
    UART1_IRQHandler
    USBDMA_IRQHandler
    USB_IRQHandler
    WDT_IRQHandler
    WWDT_IRQHandler
;;;128                    ENDP
;;;129    
;;;130    Default_Handler PROC
;;;131                    EXPORT  I2C0_IRQHandler            [WEAK]
;;;132                    EXPORT  SPI0_IRQHandler            [WEAK]
;;;133                    EXPORT  I2S_IRQHandler             [WEAK]
;;;134                    EXPORT  UART0_IRQHandler           [WEAK]
;;;135                    EXPORT  PWM0_IRQHandler            [WEAK]
;;;136                    EXPORT  ADC_IRQHandler             [WEAK]
;;;137                    EXPORT  WDT_IRQHandler             [WEAK]
;;;138                    EXPORT  WWDT_IRQHandler            [WEAK]
;;;139                    EXPORT  TMR0_IRQHandler            [WEAK]
;;;140                    EXPORT  ACC_IRQHandler             [WEAK]
;;;141                    EXPORT  SPI1_IRQHandler            [WEAK]
;;;142                    EXPORT  LL_IRQHandler              [WEAK]
;;;143                    EXPORT  UART1_IRQHandler           [WEAK]
;;;144                    EXPORT  TMR1_IRQHandler            [WEAK]
;;;145                    EXPORT  TMR2_IRQHandler            [WEAK]
;;;146                    EXPORT  TRIM_IRQHandler            [WEAK]
;;;147                    EXPORT  KSCAN_IRQHandler           [WEAK]
;;;148                    EXPORT  QDEC_IRQHandler            [WEAK]
;;;149                    EXPORT  GPIO_IRQHandler            [WEAK]
;;;150                    EXPORT  PWM1_IRQHandler            [WEAK]
;;;151                    EXPORT  PWM2_IRQHandler            [WEAK]
;;;152                    EXPORT  USBDMA_IRQHandler          [WEAK]
;;;153                    EXPORT  USB_IRQHandler             [WEAK]
;;;154                    EXPORT  RSVD_IRQHandler            [WEAK]
;;;155                    EXPORT  EXT0_IRQHandler            [WEAK]
;;;156                    EXPORT  EXT1_IRQHandler            [WEAK]
;;;157                    EXPORT  EXT2_IRQHandler            [WEAK]
;;;158                    EXPORT  DMA_IRQHandler             [WEAK]
;;;159                    EXPORT  BOD_IRQHandler             [WEAK]
;;;160                    EXPORT  SLEEP_IRQHandler           [WEAK]
;;;161                    EXPORT  STANDBY_IRQHandler         [WEAK]
;;;162                    EXPORT  MODEM_IRQHandler           [WEAK]
;;;163    
;;;164    
;;;165    I2C0_IRQHandler            ; 0,
;;;166    SPI0_IRQHandler            ; 1,
;;;167    I2S_IRQHandler             ; 2,
;;;168    UART0_IRQHandler           ; 3,
;;;169    PWM0_IRQHandler            ; 4,
;;;170    ADC_IRQHandler             ; 5,
;;;171    WDT_IRQHandler             ; 6,
;;;172    WWDT_IRQHandler            ; 7,
;;;173    TMR0_IRQHandler            ; 8,
;;;174    
;;;175    ACC_IRQHandler             ; 9,
;;;176    SPI1_IRQHandler            ; 10,
;;;177    LL_IRQHandler              ; 11,
;;;178    UART1_IRQHandler           ; 12,
;;;179    TMR1_IRQHandler            ; 13,
;;;180    TMR2_IRQHandler            ; 14,
;;;181    TRIM_IRQHandler            ; 15,
;;;182    KSCAN_IRQHandler           ; 16,
;;;183    QDEC_IRQHandler            ; 17,
;;;184    
;;;185    GPIO_IRQHandler            ; 18,
;;;186    PWM1_IRQHandler            ; 19,
;;;187    PWM2_IRQHandler            ; 20,
;;;188    USBDMA_IRQHandler          ; 21,
;;;189    USB_IRQHandler             ; 22,
;;;190    RSVD_IRQHandler            ; 23,
;;;191    EXT0_IRQHandler            ; 24,
;;;192    EXT1_IRQHandler            ; 25,
;;;193    EXT2_IRQHandler            ; 26,
;;;194    
;;;195    DMA_IRQHandler             ; 27,
;;;196    BOD_IRQHandler             ; 28,
;;;197    SLEEP_IRQHandler           ; 29,
;;;198    STANDBY_IRQHandler         ; 30,
;;;199    MODEM_IRQHandler           ; 31,
;;;200    
;;;201                    B       .
        0x00000102:    e7fe        ..      B        ACC_IRQHandler ; 0x102
    $d
        0x00000104:    000015d5    ....    DCD    5589
        0x00000108:    000000c1    ....    DCD    193
    $t
    .text
    __aeabi_uidiv
    __aeabi_uidivmod
        0x0000010c:    b530        0.      PUSH     {r4,r5,lr}
        0x0000010e:    460b        .F      MOV      r3,r1
        0x00000110:    4601        .F      MOV      r1,r0
        0x00000112:    2000        .       MOVS     r0,#0
        0x00000114:    2220         "      MOVS     r2,#0x20
        0x00000116:    2401        .$      MOVS     r4,#1
        0x00000118:    e009        ..      B        0x12e ; __aeabi_uidiv + 34
        0x0000011a:    460d        .F      MOV      r5,r1
        0x0000011c:    40d5        .@      LSRS     r5,r5,r2
        0x0000011e:    429d        .B      CMP      r5,r3
        0x00000120:    d305        ..      BCC      0x12e ; __aeabi_uidiv + 34
        0x00000122:    461d        .F      MOV      r5,r3
        0x00000124:    4095        .@      LSLS     r5,r5,r2
        0x00000126:    1b49        I.      SUBS     r1,r1,r5
        0x00000128:    4625        %F      MOV      r5,r4
        0x0000012a:    4095        .@      LSLS     r5,r5,r2
        0x0000012c:    1940        @.      ADDS     r0,r0,r5
        0x0000012e:    4615        .F      MOV      r5,r2
        0x00000130:    1e52        R.      SUBS     r2,r2,#1
        0x00000132:    2d00        .-      CMP      r5,#0
        0x00000134:    dcf1        ..      BGT      0x11a ; __aeabi_uidiv + 14
        0x00000136:    bd30        0.      POP      {r4,r5,pc}
    .text
    __aeabi_uldivmod
        0x00000138:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0000013a:    b41f        ..      PUSH     {r0-r4}
        0x0000013c:    4606        .F      MOV      r6,r0
        0x0000013e:    2000        .       MOVS     r0,#0
        0x00000140:    b082        ..      SUB      sp,sp,#8
        0x00000142:    4605        .F      MOV      r5,r0
        0x00000144:    2440        @$      MOVS     r4,#0x40
        0x00000146:    9101        ..      STR      r1,[sp,#4]
        0x00000148:    9000        ..      STR      r0,[sp,#0]
        0x0000014a:    e01b        ..      B        0x184 ; __aeabi_uldivmod + 76
        0x0000014c:    9901        ..      LDR      r1,[sp,#4]
        0x0000014e:    4622        "F      MOV      r2,r4
        0x00000150:    460f        .F      MOV      r7,r1
        0x00000152:    4630        0F      MOV      r0,r6
        0x00000154:    f000f87f    ....    BL       __aeabi_llsr ; 0x256
        0x00000158:    9a04        ..      LDR      r2,[sp,#0x10]
        0x0000015a:    9b05        ..      LDR      r3,[sp,#0x14]
        0x0000015c:    1a80        ..      SUBS     r0,r0,r2
        0x0000015e:    4199        .A      SBCS     r1,r1,r3
        0x00000160:    d310        ..      BCC      0x184 ; __aeabi_uldivmod + 76
        0x00000162:    4610        .F      MOV      r0,r2
        0x00000164:    4619        .F      MOV      r1,r3
        0x00000166:    4622        "F      MOV      r2,r4
        0x00000168:    f000f865    ..e.    BL       __aeabi_llsl ; 0x236
        0x0000016c:    1a36        6.      SUBS     r6,r6,r0
        0x0000016e:    418f        .A      SBCS     r7,r7,r1
        0x00000170:    9701        ..      STR      r7,[sp,#4]
        0x00000172:    4622        "F      MOV      r2,r4
        0x00000174:    2001        .       MOVS     r0,#1
        0x00000176:    2100        .!      MOVS     r1,#0
        0x00000178:    9f00        ..      LDR      r7,[sp,#0]
        0x0000017a:    f000f85c    ..\.    BL       __aeabi_llsl ; 0x236
        0x0000017e:    1838        8.      ADDS     r0,r7,r0
        0x00000180:    414d        MA      ADCS     r5,r5,r1
        0x00000182:    9000        ..      STR      r0,[sp,#0]
        0x00000184:    4620         F      MOV      r0,r4
        0x00000186:    1e64        d.      SUBS     r4,r4,#1
        0x00000188:    2800        .(      CMP      r0,#0
        0x0000018a:    dcdf        ..      BGT      0x14c ; __aeabi_uldivmod + 20
        0x0000018c:    9b01        ..      LDR      r3,[sp,#4]
        0x0000018e:    9800        ..      LDR      r0,[sp,#0]
        0x00000190:    4629        )F      MOV      r1,r5
        0x00000192:    4632        2F      MOV      r2,r6
        0x00000194:    b007        ..      ADD      sp,sp,#0x1c
        0x00000196:    bdf0        ..      POP      {r4-r7,pc}
    .text
    __aeabi_lmul
    _ll_mul
        0x00000198:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0000019a:    b41f        ..      PUSH     {r0-r4}
        0x0000019c:    b086        ..      SUB      sp,sp,#0x18
        0x0000019e:    2000        .       MOVS     r0,#0
        0x000001a0:    9000        ..      STR      r0,[sp,#0]
        0x000001a2:    9001        ..      STR      r0,[sp,#4]
        0x000001a4:    9002        ..      STR      r0,[sp,#8]
        0x000001a6:    9806        ..      LDR      r0,[sp,#0x18]
        0x000001a8:    9906        ..      LDR      r1,[sp,#0x18]
        0x000001aa:    b280        ..      UXTH     r0,r0
        0x000001ac:    9004        ..      STR      r0,[sp,#0x10]
        0x000001ae:    9807        ..      LDR      r0,[sp,#0x1c]
        0x000001b0:    0c09        ..      LSRS     r1,r1,#16
        0x000001b2:    0402        ..      LSLS     r2,r0,#16
        0x000001b4:    1400        ..      ASRS     r0,r0,#16
        0x000001b6:    4311        .C      ORRS     r1,r1,r2
        0x000001b8:    9007        ..      STR      r0,[sp,#0x1c]
        0x000001ba:    2700        .'      MOVS     r7,#0
        0x000001bc:    9d08        ..      LDR      r5,[sp,#0x20]
        0x000001be:    9809        ..      LDR      r0,[sp,#0x24]
        0x000001c0:    9106        ..      STR      r1,[sp,#0x18]
        0x000001c2:    463e        >F      MOV      r6,r7
        0x000001c4:    463c        <F      MOV      r4,r7
        0x000001c6:    9003        ..      STR      r0,[sp,#0xc]
        0x000001c8:    9803        ..      LDR      r0,[sp,#0xc]
        0x000001ca:    b2a9        ..      UXTH     r1,r5
        0x000001cc:    0402        ..      LSLS     r2,r0,#16
        0x000001ce:    0c00        ..      LSRS     r0,r0,#16
        0x000001d0:    9003        ..      STR      r0,[sp,#0xc]
        0x000001d2:    9804        ..      LDR      r0,[sp,#0x10]
        0x000001d4:    0c2d        -.      LSRS     r5,r5,#16
        0x000001d6:    4315        .C      ORRS     r5,r5,r2
        0x000001d8:    4348        HC      MULS     r0,r1,r0
        0x000001da:    2100        .!      MOVS     r1,#0
        0x000001dc:    4622        "F      MOV      r2,r4
        0x000001de:    f000f82a    ..*.    BL       __aeabi_llsl ; 0x236
        0x000001e2:    19c7        ..      ADDS     r7,r0,r7
        0x000001e4:    4171        qA      ADCS     r1,r1,r6
        0x000001e6:    3410        .4      ADDS     r4,r4,#0x10
        0x000001e8:    460e        .F      MOV      r6,r1
        0x000001ea:    2c40        @,      CMP      r4,#0x40
        0x000001ec:    dbec        ..      BLT      0x1c8 ; __aeabi_lmul + 48
        0x000001ee:    4638        8F      MOV      r0,r7
        0x000001f0:    9a02        ..      LDR      r2,[sp,#8]
        0x000001f2:    f000f820    .. .    BL       __aeabi_llsl ; 0x236
        0x000001f6:    9a00        ..      LDR      r2,[sp,#0]
        0x000001f8:    9b01        ..      LDR      r3,[sp,#4]
        0x000001fa:    1880        ..      ADDS     r0,r0,r2
        0x000001fc:    9000        ..      STR      r0,[sp,#0]
        0x000001fe:    4159        YA      ADCS     r1,r1,r3
        0x00000200:    9802        ..      LDR      r0,[sp,#8]
        0x00000202:    9101        ..      STR      r1,[sp,#4]
        0x00000204:    3010        .0      ADDS     r0,r0,#0x10
        0x00000206:    9002        ..      STR      r0,[sp,#8]
        0x00000208:    2840        @(      CMP      r0,#0x40
        0x0000020a:    dbcc        ..      BLT      0x1a6 ; __aeabi_lmul + 14
        0x0000020c:    9800        ..      LDR      r0,[sp,#0]
        0x0000020e:    b00b        ..      ADD      sp,sp,#0x2c
        0x00000210:    bdf0        ..      POP      {r4-r7,pc}
    .text
    __aeabi_memcpy
    __aeabi_memcpy4
    __aeabi_memcpy8
        0x00000212:    4603        .F      MOV      r3,r0
        0x00000214:    430b        .C      ORRS     r3,r3,r1
        0x00000216:    079b        ..      LSLS     r3,r3,#30
        0x00000218:    d003        ..      BEQ      0x222 ; __aeabi_memcpy + 16
        0x0000021a:    e009        ..      B        0x230 ; __aeabi_memcpy + 30
        0x0000021c:    c908        ..      LDM      r1!,{r3}
        0x0000021e:    1f12        ..      SUBS     r2,r2,#4
        0x00000220:    c008        ..      STM      r0!,{r3}
        0x00000222:    2a04        .*      CMP      r2,#4
        0x00000224:    d2fa        ..      BCS      0x21c ; __aeabi_memcpy + 10
        0x00000226:    e003        ..      B        0x230 ; __aeabi_memcpy + 30
        0x00000228:    780b        .x      LDRB     r3,[r1,#0]
        0x0000022a:    7003        .p      STRB     r3,[r0,#0]
        0x0000022c:    1c40        @.      ADDS     r0,r0,#1
        0x0000022e:    1c49        I.      ADDS     r1,r1,#1
        0x00000230:    1e52        R.      SUBS     r2,r2,#1
        0x00000232:    d2f9        ..      BCS      0x228 ; __aeabi_memcpy + 22
        0x00000234:    4770        pG      BX       lr
    .text
    __aeabi_llsl
    _ll_shift_l
        0x00000236:    b510        ..      PUSH     {r4,lr}
        0x00000238:    2a20         *      CMP      r2,#0x20
        0x0000023a:    db04        ..      BLT      0x246 ; __aeabi_llsl + 16
        0x0000023c:    4601        .F      MOV      r1,r0
        0x0000023e:    3a20         :      SUBS     r2,r2,#0x20
        0x00000240:    4091        .@      LSLS     r1,r1,r2
        0x00000242:    2000        .       MOVS     r0,#0
        0x00000244:    bd10        ..      POP      {r4,pc}
        0x00000246:    4091        .@      LSLS     r1,r1,r2
        0x00000248:    2320         #      MOVS     r3,#0x20
        0x0000024a:    1a9c        ..      SUBS     r4,r3,r2
        0x0000024c:    4603        .F      MOV      r3,r0
        0x0000024e:    40e3        .@      LSRS     r3,r3,r4
        0x00000250:    4319        .C      ORRS     r1,r1,r3
        0x00000252:    4090        .@      LSLS     r0,r0,r2
        0x00000254:    bd10        ..      POP      {r4,pc}
    .text
    __aeabi_llsr
    _ll_ushift_r
        0x00000256:    b510        ..      PUSH     {r4,lr}
        0x00000258:    2a20         *      CMP      r2,#0x20
        0x0000025a:    db04        ..      BLT      0x266 ; __aeabi_llsr + 16
        0x0000025c:    4608        .F      MOV      r0,r1
        0x0000025e:    3a20         :      SUBS     r2,r2,#0x20
        0x00000260:    40d0        .@      LSRS     r0,r0,r2
        0x00000262:    2100        .!      MOVS     r1,#0
        0x00000264:    bd10        ..      POP      {r4,pc}
        0x00000266:    460b        .F      MOV      r3,r1
        0x00000268:    40d3        .@      LSRS     r3,r3,r2
        0x0000026a:    40d0        .@      LSRS     r0,r0,r2
        0x0000026c:    2420         $      MOVS     r4,#0x20
        0x0000026e:    1aa2        ..      SUBS     r2,r4,r2
        0x00000270:    4091        .@      LSLS     r1,r1,r2
        0x00000272:    4308        .C      ORRS     r0,r0,r1
        0x00000274:    4619        .F      MOV      r1,r3
        0x00000276:    bd10        ..      POP      {r4,pc}
    .text
    __scatterload
    __scatterload_rt2
        0x00000278:    4c06        .L      LDR      r4,[pc,#24] ; [0x294] = 0x23ec
        0x0000027a:    2501        .%      MOVS     r5,#1
        0x0000027c:    4e06        .N      LDR      r6,[pc,#24] ; [0x298] = 0x240c
        0x0000027e:    e005        ..      B        0x28c ; __scatterload + 20
        0x00000280:    68e3        .h      LDR      r3,[r4,#0xc]
        0x00000282:    cc07        ..      LDM      r4!,{r0-r2}
        0x00000284:    432b        +C      ORRS     r3,r3,r5
        0x00000286:    3c0c        .<      SUBS     r4,r4,#0xc
        0x00000288:    4798        .G      BLX      r3
        0x0000028a:    3410        .4      ADDS     r4,r4,#0x10
        0x0000028c:    42b4        .B      CMP      r4,r6
        0x0000028e:    d3f7        ..      BCC      0x280 ; __scatterload + 8
        0x00000290:    f7ffff1a    ....    BL       __main_after_scatterload ; 0xc8
    $d
        0x00000294:    000023ec    .#..    DCD    9196
        0x00000298:    0000240c    .$..    DCD    9228
    $t
    i.BSP_4LineSPIInit
    BSP_4LineSPIInit
;;; ..\..\..\..\pan108\bsp.c
;;;204    {
        0x0000029c:    b510        ..      PUSH     {r4,lr}
;;;205        CLK_AHBPeriphClockCmd(CLK_AHBPeriph_GPIO, ENABLE);
        0x0000029e:    2101        .!      MOVS     r1,#1
        0x000002a0:    2002        .       MOVS     r0,#2
        0x000002a2:    f000f8d3    ....    BL       CLK_AHBPeriphClockCmd ; 0x44c
;;;206    
;;;207        SYS_ConfigMFP(P4_0, SYS_MFP_GPIO); // sck
        0x000002a6:    2100        .!      MOVS     r1,#0
        0x000002a8:    2040        @       MOVS     r0,#0x40
        0x000002aa:    f001f94f    ..O.    BL       SYS_ConfigMFP ; 0x154c
;;;208        SYS_ConfigMFP(P4_1, SYS_MFP_GPIO); // csn
        0x000002ae:    2100        .!      MOVS     r1,#0
        0x000002b0:    2041        A       MOVS     r0,#0x41
        0x000002b2:    f001f94b    ..K.    BL       SYS_ConfigMFP ; 0x154c
;;;209        SYS_ConfigMFP(P4_2, SYS_MFP_GPIO); // miso
        0x000002b6:    2100        .!      MOVS     r1,#0
        0x000002b8:    2042        B       MOVS     r0,#0x42
        0x000002ba:    f001f947    ..G.    BL       SYS_ConfigMFP ; 0x154c
;;;210        SYS_ConfigMFP(P4_3, SYS_MFP_GPIO); // mosi
        0x000002be:    2100        .!      MOVS     r1,#0
        0x000002c0:    2043        C       MOVS     r0,#0x43
        0x000002c2:    f001f943    ..C.    BL       SYS_ConfigMFP ; 0x154c
;;;211        SYS_ConfigMFP(P4_5, SYS_MFP_GPIO); // irq
        0x000002c6:    2100        .!      MOVS     r1,#0
        0x000002c8:    2045        E       MOVS     r0,#0x45
        0x000002ca:    f001f93f    ..?.    BL       SYS_ConfigMFP ; 0x154c
;;;212    
;;;213        GPIO_SetModeByPin(P4_1, GPIO_MODE_OUTPUT); // cs
        0x000002ce:    2101        .!      MOVS     r1,#1
        0x000002d0:    2041        A       MOVS     r0,#0x41
        0x000002d2:    f000facf    ....    BL       GPIO_SetModeByPin ; 0x874
;;;214        GPIO_SetModeByPin(P4_0, GPIO_MODE_OUTPUT); // sck
        0x000002d6:    2101        .!      MOVS     r1,#1
        0x000002d8:    2040        @       MOVS     r0,#0x40
        0x000002da:    f000facb    ....    BL       GPIO_SetModeByPin ; 0x874
;;;215        GPIO_SetModeByPin(P4_3, GPIO_MODE_OUTPUT); // mosi
        0x000002de:    2101        .!      MOVS     r1,#1
        0x000002e0:    2043        C       MOVS     r0,#0x43
        0x000002e2:    f000fac7    ....    BL       GPIO_SetModeByPin ; 0x874
;;;216        GPIO_SetModeByPin(P4_2, GPIO_MODE_INPUT);  // miso
        0x000002e6:    2100        .!      MOVS     r1,#0
        0x000002e8:    2042        B       MOVS     r0,#0x42
        0x000002ea:    f000fac3    ....    BL       GPIO_SetModeByPin ; 0x874
;;;217        GPIO_SetModeByPin(P4_5, GPIO_MODE_INPUT);  // irq
        0x000002ee:    2100        .!      MOVS     r1,#0
        0x000002f0:    2045        E       MOVS     r0,#0x45
        0x000002f2:    f000fabf    ....    BL       GPIO_SetModeByPin ; 0x874
;;;218    
;;;219        P41 = 1; // cs = 1;
        0x000002f6:    2101        .!      MOVS     r1,#1
        0x000002f8:    4802        .H      LDR      r0,[pc,#8] ; [0x304] = 0x40020280
        0x000002fa:    6041        A`      STR      r1,[r0,#4]
;;;220        P40 = 0; // sck = 0;
        0x000002fc:    2100        .!      MOVS     r1,#0
        0x000002fe:    6001        .`      STR      r1,[r0,#0]
;;;221        P43 = 0; // mosi = 0;
        0x00000300:    60c1        .`      STR      r1,[r0,#0xc]
;;;222    }
        0x00000302:    bd10        ..      POP      {r4,pc}
    $d
        0x00000304:    40020280    ...@    DCD    1073873536
    $t
    i.BSP_ClockInit
    BSP_ClockInit
;;; ..\..\..\..\pan108\bsp.c (8)
        0x00000308:    b510        ..      PUSH     {r4,lr}
;;;9          CLK_RefClkSrcConfig(CLK_SYS_SRCSEL_XTH);
        0x0000030a:    20ff        .       MOVS     r0,#0xff
        0x0000030c:    3001        .0      ADDS     r0,#1
        0x0000030e:    f000f91b    ....    BL       CLK_RefClkSrcConfig ; 0x548
;;; ..\..\..\..\pan108\device\Include\pan_clk.h
;;;219        CLK->CLK_TOP_CTRL = (CLK->CLK_TOP_CTRL & (~CLK_TOPCTL_APB1_DIV_Msk))| (u32ClkDiv << CLK_TOPCTL_APB1_DIV_Pos);
        0x00000312:    4812        .H      LDR      r0,[pc,#72] ; [0x35c] = 0x40040000
        0x00000314:    6a01        .j      LDR      r1,[r0,#0x20]
        0x00000316:    220f        ."      MOVS     r2,#0xf
        0x00000318:    0412        ..      LSLS     r2,r2,#16
        0x0000031a:    4391        .C      BICS     r1,r1,r2
        0x0000031c:    2201        ."      MOVS     r2,#1
        0x0000031e:    0412        ..      LSLS     r2,r2,#16
        0x00000320:    4311        .C      ORRS     r1,r1,r2
        0x00000322:    6201        .b      STR      r1,[r0,#0x20]
;;;220    }
;;;221    
;;;222    /**
;;;223      * @brief  Configures the High Speed APB clock (PCLK2).
;;;224      * @param  u32ClkDiv: defines the APB2 clock divisor. This clock is derived from 
;;;225      *         the AHB clock (HCLK).
;;;226      * 		This parameter can be 0~15,PCLK2 = hclk / (u32ClkDiv * 2):
;;;227      * @return None
;;;228      */
;;;229    __STATIC_INLINE void CLK_PCLK2Config(uint32_t u32ClkDiv)
;;;230    {
;;;231        CLK->CLK_TOP_CTRL = (CLK->CLK_TOP_CTRL & (~CLK_TOPCTL_APB2_DIV_Msk))| (u32ClkDiv << CLK_TOPCTL_APB2_DIV_Pos);
        0x00000324:    6a01        .j      LDR      r1,[r0,#0x20]
        0x00000326:    220f        ."      MOVS     r2,#0xf
        0x00000328:    0512        ..      LSLS     r2,r2,#20
        0x0000032a:    4391        .C      BICS     r1,r1,r2
        0x0000032c:    0082        ..      LSLS     r2,r0,#2
        0x0000032e:    4311        .C      ORRS     r1,r1,r2
        0x00000330:    6201        .b      STR      r1,[r0,#0x20]
;;; ..\..\..\..\pan108\bsp.c
;;;13         CLK_SYSCLKConfig(CLK_DPLL_REF_CLKSEL_XTH, CLK_DPLL_OUT_64M);
        0x00000332:    2101        .!      MOVS     r1,#1
        0x00000334:    2002        .       MOVS     r0,#2
        0x00000336:    f000f93f    ..?.    BL       CLK_SYSCLKConfig ; 0x5b8
;;;14         CLK_RefClkSrcConfig(CLK_SYS_SRCSEL_DPLL);
        0x0000033a:    2001        .       MOVS     r0,#1
        0x0000033c:    0240        @.      LSLS     r0,r0,#9
        0x0000033e:    f000f903    ....    BL       CLK_RefClkSrcConfig ; 0x548
;;;15     
;;;16         //APB Enable
;;;17         CLK_AHBPeriphClockCmd(CLK_AHBPeriph_All, ENABLE);
        0x00000342:    2101        .!      MOVS     r1,#1
        0x00000344:    4806        .H      LDR      r0,[pc,#24] ; [0x360] = 0x7cff
        0x00000346:    f000f881    ....    BL       CLK_AHBPeriphClockCmd ; 0x44c
;;;18         CLK_APB1PeriphClockCmd(CLK_APB1Periph_All, ENABLE);
        0x0000034a:    2101        .!      MOVS     r1,#1
        0x0000034c:    4805        .H      LDR      r0,[pc,#20] ; [0x364] = 0xfff01ffb
        0x0000034e:    f000f889    ....    BL       CLK_APB1PeriphClockCmd ; 0x464
;;;19         CLK_APB2PeriphClockCmd(CLK_APB2Periph_All, ENABLE);
        0x00000352:    2101        .!      MOVS     r1,#1
        0x00000354:    4804        .H      LDR      r0,[pc,#16] ; [0x368] = 0x40103a
        0x00000356:    f000f891    ....    BL       CLK_APB2PeriphClockCmd ; 0x47c
;;;20     }
        0x0000035a:    bd10        ..      POP      {r4,pc}
    $d
        0x0000035c:    40040000    ...@    DCD    1074003968
        0x00000360:    00007cff    .|..    DCD    31999
        0x00000364:    fff01ffb    ....    DCD    4293926907
        0x00000368:    0040103a    :.@.    DCD    4198458
    $t
    i.BSP_DelayMs
    BSP_DelayMs
;;;21     
;;;22     void BSP_GpioInit(void)
;;;23     {
;;;24         SYS_ConfigMFP(P1_0, SYS_MFP_GPIO); // LED2
;;;25         SYS_ConfigMFP(P1_1, SYS_MFP_GPIO); // LED3
;;;26     
;;;27         GPIO_SetModeByPin(P1_0, GPIO_MODE_OUTPUT); // LED2
;;;28         GPIO_SetModeByPin(P1_1, GPIO_MODE_OUTPUT); // LED3
;;;29     
;;;30         P10 = 0;  // 0:off; 1:on
;;;31         P11 = 0;  // 0:off; 1:on
;;;32     }
;;;33     
;;;34     void BSP_TriggerGpioInit(void)
;;;35     {
;;;36         SYS_ConfigMFP(P3_0, SYS_MFP_GPIO);
;;;37         GPIO_SetModeByPin(P3_0, GPIO_MODE_OUTPUT);
;;;38     }
;;;39     
;;;40     void BSP_UartInit(void)
;;;41     {
;;;42         /* Unlock protected registers */
;;;43         SYS_UnlockReg();
;;;44     
;;;45         GPIO_EnableDigitalPath(P1, BIT5);
;;;46         SYS_SET_MFP(P1, 4, UART1_TX);
;;;47         SYS_SET_MFP(P1, 5, UART1_RX);
;;;48     
;;;49         /* Relock protected registers */
;;;50         SYS_LockReg();
;;;51         
;;;52         UART_InitTypeDef Init_Struct;
;;;53     
;;;54         Init_Struct.UART_BaudRate = 115200;
;;;55         Init_Struct.UART_LineCtrl = Uart_Line_8n1;
;;;56     
;;;57         /* Init UART0 for printf */
;;;58         UART_Init(UART1, &Init_Struct);
;;;59         UART_EnableFifo(UART1);
;;;60     }
;;;61     
;;;62     void BSP_Timer0Init(void)
;;;63     {
;;;64         // Select Timer clock source
;;;65         CLK_SetTmrClkSrc(TIMER0, CLK_APB1_TMR0SEL_APB1CLK);
;;;66     
;;;67         // Set Timer work mode and expected clock frequency
;;;68         TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 16000000);
;;;69     
;;;70         // Set compare value (to 16M)
;;;71         // expect_timeout = tmrCmpValue / tmrExpCntFreq = 16M / 16MHz = 1s
;;;72         // real_timeout = tmrCmpValue / tmrRealCntFreq = 16M / tmrRealCntFreq
;;;73         TIMER_SetCmpValue(TIMER0, 16000);
;;;74     
;;;75         // Enable interrupt
;;;76         TIMER_EnableInt(TIMER0);
;;;77         NVIC_EnableIRQ(TMR0_IRQn);
;;;78     
;;;79         // Start Timer counting
;;;80         TIMER_Start(TIMER0);
;;;81     }
;;;82     
;;;83     void TMR0_IRQHandler(void)
;;;84     {
;;;85         if (TIMER_GetIntFlag(TIMER0))
;;;86         {
;;;87             // Clear Timer interrupt flag
;;;88             TIMER_ClearIntFlag(TIMER0);
;;;89             g_SystemTick++;
;;;90             
;;;91     //        if(g_SystemTick >= 1000)
;;;92     //        {
;;;93     //            g_SystemTick = 0;
;;;94     //            SYS_TEST("1 second.\n");
;;;95     //        }
;;;96         }
;;;97     }
;;;98     
;;;99     void BSP_KeyInit(void)
;;;100    {
;;;101    	GPIO_EnablePullupPath(P0, BIT1);
;;;102    	GPIO_EnablePullupPath(P1, BIT6);
;;;103    	GPIO_EnablePullupPath(P1, BIT7);
;;;104        GPIO_EnablePullupPath(P3, BIT1);
;;;105    	GPIO_EnablePullupPath(P3, BIT0);
;;;106    
;;;107        SYS_ConfigMFP(P0_1, SYS_MFP_GPIO);
;;;108        SYS_ConfigMFP(P1_6, SYS_MFP_GPIO);
;;;109        SYS_ConfigMFP(P1_7, SYS_MFP_GPIO);
;;;110        SYS_ConfigMFP(P3_1, SYS_MFP_GPIO);
;;;111        SYS_ConfigMFP(P3_0, SYS_MFP_GPIO);
;;;112    
;;;113        GPIO_SetModeByPin(P0_1, GPIO_MODE_QUASI);
;;;114        GPIO_SetModeByPin(P1_6, GPIO_MODE_QUASI);
;;;115        GPIO_SetModeByPin(P1_7, GPIO_MODE_QUASI);
;;;116        GPIO_SetModeByPin(P3_1, GPIO_MODE_QUASI);
;;;117        GPIO_SetModeByPin(P3_0, GPIO_MODE_INPUT);
;;;118    
;;;119    }
;;;120    
;;;121    void BSP_OLEDInit(void)
;;;122    {
;;;123        SYS_ConfigMFP(P2_2, SYS_MFP_GPIO); // OLED_DC
;;;124        SYS_ConfigMFP(P2_0, SYS_MFP_GPIO); // OLED_CS
;;;125        SYS_ConfigMFP(P2_6, SYS_MFP_GPIO); // OLED_RST
;;;126        SYS_ConfigMFP(P2_1, SYS_MFP_GPIO); // OLED_SCLK
;;;127        SYS_ConfigMFP(P2_3, SYS_MFP_GPIO); // OLED_SDIN
;;;128    
;;;129        GPIO_SetModeByPin(P2_2, GPIO_MODE_OUTPUT); // OLED_DC
;;;130        GPIO_SetModeByPin(P2_0, GPIO_MODE_OUTPUT); // OLED_CS
;;;131        GPIO_SetModeByPin(P2_6, GPIO_MODE_OUTPUT); // OLED_RST
;;;132        GPIO_SetModeByPin(P2_1, GPIO_MODE_OUTPUT); // OLED_SCLK
;;;133        GPIO_SetModeByPin(P2_3, GPIO_MODE_OUTPUT); // OLED_SDIN
;;;134    
;;;135        P22 = 0; // OLED_DC
;;;136        P20 = 0; // OLED_CS
;;;137        P26 = 0; // OLED_RST
;;;138        P21 = 0; // OLED_SCLK
;;;139        P23 = 0; // OLED_SDIN
;;;140    }
;;;141    
;;;142    void BSP_Led2Toggle(void)
;;;143    {
;;;144        static bool FlagStatus = 0;
;;;145    
;;;146        FlagStatus = !FlagStatus;
;;;147        LED2_PIN = FlagStatus;
;;;148    }
;;;149    
;;;150    void BSP_Led3Toggle(void)
;;;151    {
;;;152        static bool FlagStatus = 0;
;;;153    
;;;154        FlagStatus = !FlagStatus;
;;;155        LED3_PIN = FlagStatus;
;;;156    }
;;;157    
;;;158    void BSP_IICInit(void)
;;;159    {
;;;160        CLK_AHBPeriphClockCmd(CLK_AHBPeriph_GPIO, ENABLE);
;;;161    
;;;162        SYS_ConfigMFP(P4_1, SYS_MFP_GPIO); // cs
;;;163        SYS_ConfigMFP(P4_0, SYS_MFP_GPIO); // scl/sck
;;;164        SYS_ConfigMFP(P4_3, SYS_MFP_GPIO); // sda/mosi
;;;165        SYS_ConfigMFP(P4_2, SYS_MFP_GPIO); // miso
;;;166        SYS_ConfigMFP(P4_5, SYS_MFP_GPIO); // IRQ pin
;;;167    
;;;168        GPIO_SetModeByPin(P4_1, GPIO_MODE_OUTPUT); // cs
;;;169        GPIO_SetModeByPin(P4_0, GPIO_MODE_OUTPUT); // scl/sck
;;;170        GPIO_SetModeByPin(P4_3, GPIO_MODE_OUTPUT); // sda/mosi
;;;171        GPIO_SetModeByPin(P4_2, GPIO_MODE_INPUT);  // miso
;;;172        GPIO_SetModeByPin(P4_5, GPIO_MODE_INPUT);  // irq
;;;173                                                   // GPIO_EnablePullupPath(P4, BIT5);
;;;174    
;;;175        P41 = 1; // cs = 1;
;;;176        P40 = 1; // scl = 1;
;;;177        P43 = 1; // sda = 1;
;;;178    }
;;;179    
;;;180    void BSP_3LineSPIInit(void)
;;;181    {
;;;182        CLK_AHBPeriphClockCmd(CLK_AHBPeriph_GPIO, ENABLE);
;;;183    
;;;184        SYS_ConfigMFP(P4_0, SYS_MFP_GPIO); // sck
;;;185        SYS_ConfigMFP(P4_1, SYS_MFP_GPIO); // csn
;;;186        SYS_ConfigMFP(P4_2, SYS_MFP_GPIO); // miso
;;;187        SYS_ConfigMFP(P4_3, SYS_MFP_GPIO); // mosi
;;;188        SYS_ConfigMFP(P4_5, SYS_MFP_GPIO); // irq
;;;189    
;;;190        GPIO_SetModeByPin(P4_1, GPIO_MODE_OUTPUT); // cs
;;;191        GPIO_SetModeByPin(P4_0, GPIO_MODE_OUTPUT); // sck
;;;192        GPIO_SetModeByPin(P4_3, GPIO_MODE_OUTPUT); // mosi
;;;193        GPIO_SetModeByPin(P4_2, GPIO_MODE_INPUT);  // miso
;;;194        GPIO_SetModeByPin(P4_5, GPIO_MODE_INPUT);  // irq
;;;195    
;;;196        P41 = 1; // cs = 1;
;;;197        P40 = 0; // sck = 0;
;;;198        P43 = 0; // mosi
;;;199    
;;;200        GPIO_EnablePullupPath(P4, BIT3);
;;;201    }
;;;202    
;;;203    void BSP_4LineSPIInit(void)
;;;204    {
;;;205        CLK_AHBPeriphClockCmd(CLK_AHBPeriph_GPIO, ENABLE);
;;;206    
;;;207        SYS_ConfigMFP(P4_0, SYS_MFP_GPIO); // sck
;;;208        SYS_ConfigMFP(P4_1, SYS_MFP_GPIO); // csn
;;;209        SYS_ConfigMFP(P4_2, SYS_MFP_GPIO); // miso
;;;210        SYS_ConfigMFP(P4_3, SYS_MFP_GPIO); // mosi
;;;211        SYS_ConfigMFP(P4_5, SYS_MFP_GPIO); // irq
;;;212    
;;;213        GPIO_SetModeByPin(P4_1, GPIO_MODE_OUTPUT); // cs
;;;214        GPIO_SetModeByPin(P4_0, GPIO_MODE_OUTPUT); // sck
;;;215        GPIO_SetModeByPin(P4_3, GPIO_MODE_OUTPUT); // mosi
;;;216        GPIO_SetModeByPin(P4_2, GPIO_MODE_INPUT);  // miso
;;;217        GPIO_SetModeByPin(P4_5, GPIO_MODE_INPUT);  // irq
;;;218    
;;;219        P41 = 1; // cs = 1;
;;;220        P40 = 0; // sck = 0;
;;;221        P43 = 0; // mosi = 0;
;;;222    }
;;;223    
;;;224    void SYS_ConfigMFP(uint8_t PinID, uint32_t PinFunction)
;;;225    {
;;;226        uint8_t port = PinID / 0x10;
;;;227        uint8_t bit = PinID % 0x10;
;;;228    
;;;229        (&SYS->P0_MFP)[port] = ((&SYS->P0_MFP)[port] & ~(SYS_MFP_P00_Msk << bit)) | PinFunction;
;;;230    }
;;;231    
;;;232    /* GPIO Driver Wrapper Functions */
;;;233    void GPIO_SetModeByPin(uint8_t PinID, GPIO_ModeDef Mode)
;;;234    {
;;;235        uint8_t port = PinID / 0x10;
;;;236        uint8_t bit = PinID % 0x10;
;;;237    
;;;238        GPIO_SetMode((GPIO_T*)(P0_BASE + 0x40 * port), BIT0 << bit, Mode);
;;;239    
;;;240        if (Mode == GPIO_MODE_INPUT || Mode == GPIO_MODE_QUASI)
;;;241        {
;;;242            if (PinID == P5_6 || PinID == P4_6 || PinID == P4_7)
;;;243            {
;;;244                // These Pins' DINOFF bits should be synced to 3v area
;;;245                CLK_Wait3vSyncReady();
;;;246            }
;;;247        }
;;;248    }
;;;249    
;;;250    #pragma O0 // disable optimization, otherwise the delay time will be inaccurate
;;;251    
;;;252    /**
;;;253     * @brief BSP_DelayMs
;;;254     * @param[in] <time> ms
;;;255     * @return none
;;;256     * @note user should modify this function according to the actual situation
;;;257     */
;;;258    void BSP_DelayMs(const uint32_t ms)
;;;259    {
;;;260        int i, j;
;;;261        for (i = 0; i < ms; i++)
        0x0000036c:    2100        .!      MOVS     r1,#0
;;; ..\..\..\..\pan108\bsp.c (261)
        0x0000036e:    e008        ..      B        0x382 ; BSP_DelayMs + 22
;;;262        {
;;;263            for (j = 0; j < 8000; j++)
        0x00000370:    2200        ."      MOVS     r2,#0
        0x00000372:    e001        ..      B        0x378 ; BSP_DelayMs + 12
        0x00000374:    bf00        ..      NOP      
        0x00000376:    1c52        R.      ADDS     r2,r2,#1
        0x00000378:    237d        }#      MOVS     r3,#0x7d
        0x0000037a:    019b        ..      LSLS     r3,r3,#6
        0x0000037c:    429a        .B      CMP      r2,r3
        0x0000037e:    dbf9        ..      BLT      0x374 ; BSP_DelayMs + 8
        0x00000380:    1c49        I.      ADDS     r1,r1,#1
        0x00000382:    4281        .B      CMP      r1,r0
        0x00000384:    d3f4        ..      BCC      0x370 ; BSP_DelayMs + 4
;;;264            {
;;;265                __NOP();
;;;266            }
;;;267        }
;;;268    }
        0x00000386:    4770        pG      BX       lr
    i.BSP_DelayUs
    BSP_DelayUs
;;;269    
;;;270    /**
;;;271     * @brief BSP_DelayUs
;;;272     * @param[in] <time> us
;;;273     * @return none
;;;274     * @note user should modify this function according to the actual situation
;;;275     */
;;;276    void BSP_DelayUs(const uint32_t us)
;;;277    {
;;;278        int i, j;
;;;279    
;;;280        for (i = 0; i < us; i++)
        0x00000388:    2100        .!      MOVS     r1,#0
;;; ..\..\..\..\pan108\bsp.c (280)
        0x0000038a:    e006        ..      B        0x39a ; BSP_DelayUs + 18
;;;281        {
;;;282            for (j = 0; j < 10; j++)
        0x0000038c:    2200        ."      MOVS     r2,#0
        0x0000038e:    e001        ..      B        0x394 ; BSP_DelayUs + 12
        0x00000390:    bf00        ..      NOP      
        0x00000392:    1c52        R.      ADDS     r2,r2,#1
        0x00000394:    2a0a        .*      CMP      r2,#0xa
        0x00000396:    dbfb        ..      BLT      0x390 ; BSP_DelayUs + 8
        0x00000398:    1c49        I.      ADDS     r1,r1,#1
        0x0000039a:    4281        .B      CMP      r1,r0
        0x0000039c:    d3f6        ..      BCC      0x38c ; BSP_DelayUs + 4
;;;283            {
;;;284                __NOP();
;;;285            }
;;;286        }
;;;287    }
        0x0000039e:    4770        pG      BX       lr
    i.BSP_GpioInit
    BSP_GpioInit
        0x000003a0:    b510        ..      PUSH     {r4,lr}
;;; ..\..\..\..\pan108\bsp.c (24)
        0x000003a2:    2100        .!      MOVS     r1,#0
        0x000003a4:    2010        .       MOVS     r0,#0x10
        0x000003a6:    f001f8d1    ....    BL       SYS_ConfigMFP ; 0x154c
;;;25         SYS_ConfigMFP(P1_1, SYS_MFP_GPIO); // LED3
        0x000003aa:    2100        .!      MOVS     r1,#0
        0x000003ac:    2011        .       MOVS     r0,#0x11
        0x000003ae:    f001f8cd    ....    BL       SYS_ConfigMFP ; 0x154c
;;;26     
;;;27         GPIO_SetModeByPin(P1_0, GPIO_MODE_OUTPUT); // LED2
        0x000003b2:    2101        .!      MOVS     r1,#1
        0x000003b4:    2010        .       MOVS     r0,#0x10
        0x000003b6:    f000fa5d    ..].    BL       GPIO_SetModeByPin ; 0x874
;;;28         GPIO_SetModeByPin(P1_1, GPIO_MODE_OUTPUT); // LED3
        0x000003ba:    2101        .!      MOVS     r1,#1
        0x000003bc:    2011        .       MOVS     r0,#0x11
        0x000003be:    f000fa59    ..Y.    BL       GPIO_SetModeByPin ; 0x874
;;;29     
;;;30         P10 = 0;  // 0:off; 1:on
        0x000003c2:    2100        .!      MOVS     r1,#0
        0x000003c4:    4801        .H      LDR      r0,[pc,#4] ; [0x3cc] = 0x40020200
        0x000003c6:    6201        .b      STR      r1,[r0,#0x20]
;;;31         P11 = 0;  // 0:off; 1:on
        0x000003c8:    6241        Ab      STR      r1,[r0,#0x24]
;;;32     }
        0x000003ca:    bd10        ..      POP      {r4,pc}
    $d
        0x000003cc:    40020200    ...@    DCD    1073873408
    $t
    i.BSP_UartInit
    BSP_UartInit
;;;33     
;;;34     void BSP_TriggerGpioInit(void)
;;;35     {
;;;36         SYS_ConfigMFP(P3_0, SYS_MFP_GPIO);
;;;37         GPIO_SetModeByPin(P3_0, GPIO_MODE_OUTPUT);
;;;38     }
;;;39     
;;;40     void BSP_UartInit(void)
;;;41     {
        0x000003d0:    b51c        ..      PUSH     {r2-r4,lr}
;;; ..\..\..\..\pan108\device\Include\pan_sys.h
;;;598            SYS->REGLCTL = 0x59;
        0x000003d2:    2359        Y#      MOVS     r3,#0x59
        0x000003d4:    4818        .H      LDR      r0,[pc,#96] ; [0x438] = 0x40030040
        0x000003d6:    2116        .!      MOVS     r1,#0x16
        0x000003d8:    2288        ."      MOVS     r2,#0x88
        0x000003da:    6003        .`      STR      r3,[r0,#0]
;;;599            SYS->REGLCTL = 0x16;
        0x000003dc:    6001        .`      STR      r1,[r0,#0]
;;;600            SYS->REGLCTL = 0x88;
        0x000003de:    6002        .`      STR      r2,[r0,#0]
;;;601        }
;;;602        while(SYS->REGLCTL == 0);
        0x000003e0:    6804        .h      LDR      r4,[r0,#0]
        0x000003e2:    2c00        .,      CMP      r4,#0
        0x000003e4:    d0f9        ..      BEQ      0x3da ; BSP_UartInit + 10
;;; ..\..\..\..\pan108\peripheral\inc\pan_gpio.h
;;;312        gpio->DINOFF &= ~(PinMask << 16);
        0x000003e6:    4915        .I      LDR      r1,[pc,#84] ; [0x43c] = 0x40020040
        0x000003e8:    684a        Jh      LDR      r2,[r1,#4]
        0x000003ea:    03cb        ..      LSLS     r3,r1,#15
        0x000003ec:    439a        .C      BICS     r2,r2,r3
        0x000003ee:    604a        J`      STR      r2,[r1,#4]
;;; ..\..\..\..\pan108\bsp.c
;;;46         SYS_SET_MFP(P1, 4, UART1_TX);
        0x000003f0:    4911        .I      LDR      r1,[pc,#68] ; [0x438] = 0x40030040
        0x000003f2:    3940        @9      SUBS     r1,r1,#0x40
        0x000003f4:    684a        Jh      LDR      r2,[r1,#4]
        0x000003f6:    4b12        .K      LDR      r3,[pc,#72] ; [0x440] = 0xffefefef
        0x000003f8:    401a        .@      ANDS     r2,r2,r3
        0x000003fa:    3210        .2      ADDS     r2,r2,#0x10
        0x000003fc:    604a        J`      STR      r2,[r1,#4]
;;;47         SYS_SET_MFP(P1, 5, UART1_RX);
        0x000003fe:    684a        Jh      LDR      r2,[r1,#4]
        0x00000400:    4b10        .K      LDR      r3,[pc,#64] ; [0x444] = 0xffdfdfdf
        0x00000402:    401a        .@      ANDS     r2,r2,r3
        0x00000404:    3220         2      ADDS     r2,r2,#0x20
        0x00000406:    604a        J`      STR      r2,[r1,#4]
;;; ..\..\..\..\pan108\device\Include\pan_sys.h
;;;616        __NOP();__NOP();__NOP();__NOP();__NOP();
        0x00000408:    bf00        ..      NOP      
        0x0000040a:    bf00        ..      NOP      
        0x0000040c:    bf00        ..      NOP      
        0x0000040e:    bf00        ..      NOP      
        0x00000410:    bf00        ..      NOP      
;;;617    #else
;;;618        __ISB();
;;;619    #endif
;;;620        SYS->REGLCTL = 0;
        0x00000412:    2100        .!      MOVS     r1,#0
        0x00000414:    6001        .`      STR      r1,[r0,#0]
;;; ..\..\..\..\pan108\bsp.c
;;;54         Init_Struct.UART_BaudRate = 115200;
        0x00000416:    20e1        .       MOVS     r0,#0xe1
        0x00000418:    0240        @.      LSLS     r0,r0,#9
;;;55         Init_Struct.UART_LineCtrl = Uart_Line_8n1;
        0x0000041a:    9000        ..      STR      r0,[sp,#0]
        0x0000041c:    2003        .       MOVS     r0,#3
        0x0000041e:    4669        iF      MOV      r1,sp
        0x00000420:    7108        .q      STRB     r0,[r1,#4]
;;;56     
;;;57         /* Init UART0 for printf */
;;;58         UART_Init(UART1, &Init_Struct);
        0x00000422:    4c09        .L      LDR      r4,[pc,#36] ; [0x448] = 0x40013000
        0x00000424:    4620         F      MOV      r0,r4
        0x00000426:    f001f92f    ../.    BL       UART_Init ; 0x1688
;;; ..\..\..\..\pan108\peripheral\inc\pan_uart.h
;;;245        UARTx->SCR |= UART_FCR_FIFOE_Msk;
        0x0000042a:    69e0        .i      LDR      r0,[r4,#0x1c]
        0x0000042c:    2101        .!      MOVS     r1,#1
        0x0000042e:    4308        .C      ORRS     r0,r0,r1
        0x00000430:    61e0        .a      STR      r0,[r4,#0x1c]
;;;246    
;;;247        UARTx->IIR_FCR = UARTx->SCR;
        0x00000432:    69e0        .i      LDR      r0,[r4,#0x1c]
        0x00000434:    60a0        .`      STR      r0,[r4,#8]
;;; ..\..\..\..\pan108\bsp.c
;;;60     }
        0x00000436:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x00000438:    40030040    @..@    DCD    1073938496
        0x0000043c:    40020040    @..@    DCD    1073872960
        0x00000440:    ffefefef    ....    DCD    4293914607
        0x00000444:    ffdfdfdf    ....    DCD    4292861919
        0x00000448:    40013000    .0.@    DCD    1073819648
    $t
    i.CLK_AHBPeriphClockCmd
    CLK_AHBPeriphClockCmd
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c
;;;208        (NewState != DISABLE)?(CLK->AHB_CLK_CTRL |= CLK_AHBPeriph):(CLK->AHB_CLK_CTRL &= ~CLK_AHBPeriph);
        0x0000044c:    4a04        .J      LDR      r2,[pc,#16] ; [0x460] = 0x40040000
        0x0000044e:    2900        .)      CMP      r1,#0
        0x00000450:    6b91        .k      LDR      r1,[r2,#0x38]
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (207)
        0x00000452:    d001        ..      BEQ      0x458 ; CLK_AHBPeriphClockCmd + 12
;;;208        (NewState != DISABLE)?(CLK->AHB_CLK_CTRL |= CLK_AHBPeriph):(CLK->AHB_CLK_CTRL &= ~CLK_AHBPeriph);
        0x00000454:    4301        .C      ORRS     r1,r1,r0
        0x00000456:    e000        ..      B        0x45a ; CLK_AHBPeriphClockCmd + 14
        0x00000458:    4381        .C      BICS     r1,r1,r0
        0x0000045a:    6391        .c      STR      r1,[r2,#0x38]
;;;209    }
        0x0000045c:    4770        pG      BX       lr
    $d
        0x0000045e:    0000        ..      DCW    0
        0x00000460:    40040000    ...@    DCD    1074003968
    $t
    i.CLK_APB1PeriphClockCmd
    CLK_APB1PeriphClockCmd
;;;210    
;;;211    /**
;;;212      * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
;;;213      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;214      *         is disabled and the application software has to enable this clock before 
;;;215      *         using it. 
;;;216      * @param  CLK_APB1Periph: specifies the APB1 peripheral to gates its clock.
;;;217      *          This parameter can be any combination of the following values:
;;;218      *            @arg CLK_APB1Periph_I2C0              
;;;219      *            @arg CLK_APB1Periph_SPI0       
;;;220      *            @arg CLK_APB1Periph_UART0     
;;;221      *            @arg CLK_APB1Periph_PWM01    
;;;222      *            @arg CLK_APB1Periph_PWM23      
;;;223      *            @arg CLK_APB1Periph_PWM45  
;;;224      *            @arg CLK_APB1Periph_PWM67   
;;;225      *            @arg CLK_APB1Periph_PWMEN    
;;;226      *            @arg CLK_APB1Periph_ADC    
;;;227      *            @arg CLK_APB1Periph_WDT   
;;;228      *            @arg CLK_APB1Periph_WWDT    
;;;229      *            @arg CLK_APB1Periph_TMR0    
;;;230      *            @arg CLK_APB1Periph_All
;;;231      * @param  NewState  : new state of the specified peripheral clock.
;;;232      *          This parameter can be: ENABLE or DISABLE.
;;;233      * @retval None
;;;234      */
;;;235    void CLK_APB1PeriphClockCmd(uint32_t CLK_APB1Periph, FunctionalState NewState)
;;;236    {
;;;237      (NewState != DISABLE)?(CLK->APB1_CLK_CTRL |= CLK_APB1Periph):(CLK->APB1_CLK_CTRL &= ~CLK_APB1Periph);
        0x00000464:    4a04        .J      LDR      r2,[pc,#16] ; [0x478] = 0x40040000
        0x00000466:    2900        .)      CMP      r1,#0
        0x00000468:    6bd1        .k      LDR      r1,[r2,#0x3c]
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (236)
        0x0000046a:    d001        ..      BEQ      0x470 ; CLK_APB1PeriphClockCmd + 12
;;;237      (NewState != DISABLE)?(CLK->APB1_CLK_CTRL |= CLK_APB1Periph):(CLK->APB1_CLK_CTRL &= ~CLK_APB1Periph);
        0x0000046c:    4301        .C      ORRS     r1,r1,r0
        0x0000046e:    e000        ..      B        0x472 ; CLK_APB1PeriphClockCmd + 14
        0x00000470:    4381        .C      BICS     r1,r1,r0
        0x00000472:    63d1        .c      STR      r1,[r2,#0x3c]
;;;238    }
        0x00000474:    4770        pG      BX       lr
    $d
        0x00000476:    0000        ..      DCW    0
        0x00000478:    40040000    ...@    DCD    1074003968
    $t
    i.CLK_APB2PeriphClockCmd
    CLK_APB2PeriphClockCmd
;;;239    
;;;240    /**
;;;241      * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
;;;242      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;243      *         is disabled and the application software has to enable this clock before 
;;;244      *         using it.
;;;245      * @param  CLK_APB2Periph: specifies the APB2 peripheral to gates its clock.
;;;246      *          This parameter can be any combination of the following values:
;;;247      *            @arg CLK_APB2Periph_SPI1 
;;;248      *            @arg CLK_APB2Periph_UART1
;;;249      *            @arg CLK_APB2Periph_TMR1 
;;;250      *            @arg CLK_APB2Periph_TMR2 
;;;251      *            @arg CLK_APB2Periph_All  
;;;252      * @param  NewState: new state of the specified peripheral clock.
;;;253      *          This parameter can be: ENABLE or DISABLE.
;;;254      * @retval None
;;;255      */
;;;256    void CLK_APB2PeriphClockCmd(uint32_t CLK_APB2Periph, FunctionalState NewState)
;;;257    {
;;;258        (NewState != DISABLE)?(CLK->APB2_CLK_CTRL |= CLK_APB2Periph):(CLK->APB2_CLK_CTRL &= ~CLK_APB2Periph); 
        0x0000047c:    4a04        .J      LDR      r2,[pc,#16] ; [0x490] = 0x40040040
        0x0000047e:    2900        .)      CMP      r1,#0
        0x00000480:    6851        Qh      LDR      r1,[r2,#4]
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (257)
        0x00000482:    d001        ..      BEQ      0x488 ; CLK_APB2PeriphClockCmd + 12
;;;258        (NewState != DISABLE)?(CLK->APB2_CLK_CTRL |= CLK_APB2Periph):(CLK->APB2_CLK_CTRL &= ~CLK_APB2Periph); 
        0x00000484:    4301        .C      ORRS     r1,r1,r0
        0x00000486:    e000        ..      B        0x48a ; CLK_APB2PeriphClockCmd + 14
        0x00000488:    4381        .C      BICS     r1,r1,r0
        0x0000048a:    6051        Q`      STR      r1,[r2,#4]
;;;259    }
        0x0000048c:    4770        pG      BX       lr
    $d
        0x0000048e:    0000        ..      DCW    0
        0x00000490:    40040040    @..@    DCD    1074004032
    $t
    i.CLK_GetHCLKFreq
    CLK_GetHCLKFreq
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (32)
        0x00000494:    b510        ..      PUSH     {r4,lr}
;;;33         SystemCoreClockUpdate();
        0x00000496:    f001f879    ..y.    BL       SystemCoreClockUpdate ; 0x158c
;;;34         return SystemCoreClock;
        0x0000049a:    4801        .H      LDR      r0,[pc,#4] ; [0x4a0] = 0x20000000
        0x0000049c:    6800        .h      LDR      r0,[r0,#0]
;;;35     }
        0x0000049e:    bd10        ..      POP      {r4,pc}
    $d
        0x000004a0:    20000000    ...     DCD    536870912
    $t
    i.CLK_GetPeripheralFreq
    CLK_GetPeripheralFreq
;;;36     
;;;37     
;;;38      /**
;;;39        * @brief  This function get CPU frequency. The frequency unit is Hz.
;;;40        * @return CPU frequency
;;;41        */
;;;42      uint32_t CLK_GetCPUFreq(void)
;;;43      {
;;;44          SystemCoreClockUpdate();
;;;45          return SystemCoreClock;
;;;46      }
;;;47     
;;;48     /**
;;;49       * @brief  This function get APB1 frequency. The frequency unit is Hz.
;;;50       * @return HCLK frequency
;;;51       */
;;;52     uint32_t CLK_GetPCLK1Freq(void)
;;;53     {
;;;54         uint32_t ahbclock,apb1_clock;
;;;55         uint32_t apb1_div;
;;;56         
;;;57         // update ahb clock
;;;58         SystemCoreClockUpdate();
;;;59         ahbclock =  SystemCoreClock;
;;;60         
;;;61         apb1_div = (CLK->CLK_TOP_CTRL & CLK_TOPCTL_APB1_DIV_Msk) >> CLK_TOPCTL_APB1_DIV_Pos;
;;;62         if(apb1_div)
;;;63     			apb1_clock = ahbclock / (2 * apb1_div);
;;;64     		else
;;;65     			apb1_clock = ahbclock;
;;;66         
;;;67         return apb1_clock;
;;;68     }
;;;69     /**
;;;70       * @brief  This function get APB2 frequency. The frequency unit is Hz.
;;;71       * @return HCLK frequency
;;;72       */
;;;73     uint32_t CLK_GetPCLK2Freq(void)
;;;74     {
;;;75         uint32_t ahbclock,apb2_clock;
;;;76         uint32_t apb2_div;
;;;77         
;;;78         // update ahb clock
;;;79         SystemCoreClockUpdate();
;;;80         ahbclock =  SystemCoreClock;
;;;81         
;;;82         apb2_div = (CLK->CLK_TOP_CTRL & CLK_TOPCTL_APB2_DIV_Msk) >> CLK_TOPCTL_APB2_DIV_Pos;
;;;83         if(apb2_div)
;;;84     			apb2_clock = ahbclock / (2 * apb2_div);
;;;85     		else
;;;86     			apb2_clock = ahbclock;
;;;87         
;;;88         return apb2_clock;
;;;89     }
;;;90      /**
;;;91         * @brief  This function set 16M ref clock source
;;;92         * @param[in]  u32ClkSrc is HCLK clock source. Including :
;;;93         *                  - \ref CLK_SYS_SRCSEL_RCH 
;;;94         *                  - \ref CLK_SYS_SRCSEL_XTH 
;;;95         *                  - \ref CLK_SYS_SRCSEL_RCL 
;;;96         *                  - \ref CLK_SYS_SRCSEL_XTL 
;;;97         *                  - \ref CLK_SYS_SRCSEL_DPLL
;;;98         * @return None
;;;99         */
;;;100    void CLK_RefClkSrcConfig(uint32_t u32ClkSrc)
;;;101    {
;;;102    //    uint32_t tmpreg;
;;;103        CLK->CLK_TOP_CTRL &= ~CLK_TOPCTL_SYS_CLK_SEL_Msk;
;;;104        switch(u32ClkSrc)
;;;105        {
;;;106            case CLK_SYS_SRCSEL_RCH: 
;;;107                CLK->CLK_TOP_CTRL |= CLK_TOPCTL_RCH_EN_Msk;
;;;108    #ifdef SYNC_3V_REG_MANUALLY
;;;109                CLK_Wait3vSyncReady();
;;;110    #endif
;;;111    			CLK_WaitClockReady(u32ClkSrc);
;;;112                CLK->CLK_TOP_CTRL |= CLK_SYS_SRCSEL_RCH;
;;;113                break;
;;;114            case CLK_SYS_SRCSEL_XTH: 
;;;115    			CLK_XthStartupConfig();
;;;116                CLK->CLK_TOP_CTRL |= CLK_TOPCTL_XTH_EN_Msk;
;;;117    #ifdef SYNC_3V_REG_MANUALLY
;;;118                CLK_Wait3vSyncReady();
;;;119    #endif
;;;120    			CLK_WaitClockReady(u32ClkSrc);
;;;121                CLK->CLK_TOP_CTRL |= CLK_SYS_SRCSEL_XTH;
;;;122                break;
;;;123    //        case CLK_SYS_SRCSEL_RCL: 
;;;124    //            CLK->CLK_TOP_CTRL |= (CLK_SYS_SRCSEL_RCL | CLK_TOPCTL_RCL_EN_Msk);
;;;125    //            break;
;;;126    //        case CLK_SYS_SRCSEL_XTL: 
;;;127    //            CLK->CLK_TOP_CTRL |= (CLK_SYS_SRCSEL_XTL | CLK_TOPCTL_XTL_EN_Msk); 
;;;128    //            break;
;;;129            case CLK_SYS_SRCSEL_DPLL: 
;;;130                CLK->CLK_TOP_CTRL |= CLK_TOPCTL_DPLL_EN_Msk;
;;;131    #ifdef SYNC_3V_REG_MANUALLY
;;;132                CLK_Wait3vSyncReady();
;;;133    #endif
;;;134    			CLK_WaitClockReady(u32ClkSrc);
;;;135                CLK->CLK_TOP_CTRL |= CLK_SYS_SRCSEL_DPLL;
;;;136                break;
;;;137            default: break;
;;;138        }
;;;139    
;;;140        //wait xtal clock stable
;;;141    //    CLK_WaitClockReady(u32ClkSrc);
;;;142    	SystemCoreClockUpdate();
;;;143    }
;;;144    /**
;;;145    * @brief  This function set HCLK clock source
;;;146    * @param[in]  u32ClkSrc is HCLK clock source. Including :
;;;147    *                  - \ref CLK_DPLL_REF_CLKSEL_RCH
;;;148    *                  - \ref CLK_DPLL_REF_CLKSEL_XTH
;;;149    * @return None
;;;150    */
;;;151    void CLK_SYSCLKConfig(uint32_t u32ClkSrc,uint32_t freq_out)
;;;152    {
;;;153        if(u32ClkSrc == CLK_DPLL_REF_CLKSEL_RCH){
;;;154            CLK->DPLL_CTRL &= ~CLK_DPLLCTL_RCLK_SEL_Msk;
;;;155        }
;;;156        else if(u32ClkSrc == CLK_DPLL_REF_CLKSEL_XTH){
;;;157            CLK->DPLL_CTRL |= CLK_DPLLCTL_RCLK_SEL_Msk;
;;;158        }
;;;159        
;;;160        /* Config MCU DPLL*/         
;;;161    	CLK_SetDpllOutputFreq(freq_out);
;;;162        //enable dpll clock
;;;163        CLK->CLK_TOP_CTRL |=  CLK_TOPCTL_DPLL_EN_Msk;
;;;164    #ifdef SYNC_3V_REG_MANUALLY
;;;165        CLK_Wait3vSyncReady();
;;;166    #endif
;;;167        CLK_WaitClockReady(CLK_SYS_SRCSEL_DPLL);
;;;168    
;;;169        /* Update System Core Clock */
;;;170    //    SystemCoreClockUpdate();
;;;171    }
;;;172    
;;;173    
;;;174    
;;;175    //void CLK_SetClkDivide(uint32_t u32ClkSel,uint32_t u32ClkDiv)
;;;176    //{
;;;177    //    switch(u32ClkSel){
;;;178    //        case CLK_DivideSource_Apb1:
;;;179    //            CLK->CLK_TOP_CTRL = (CLK->CLK_TOP_CTRL & (~CLK_TOPCTL_APB1_DIV_Msk))| u32ClkDiv;
;;;180    //            break;
;;;181    //        case CLK_DivideSource_Apb2:
;;;182    //            CLK->CLK_TOP_CTRL = (CLK->CLK_TOP_CTRL & (~CLK_TOPCTL_APB2_DIV_Msk))| u32ClkDiv;
;;;183    //            break;
;;;184    //        default: break;
;;;185    //    }
;;;186    //}
;;;187    /**
;;;188      * @brief  Enables or disables the AHB peripheral clock.
;;;189      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;190      *         is disabled and the application software has to enable this clock before 
;;;191      *         using it. 
;;;192      * @param  CLK_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
;;;193      *          This parameter can be any combination of the following values:
;;;194      *            @arg CLK_AHBPeriph_DMAC   
;;;195      *            @arg CLK_AHBPeriph_GPIO   
;;;196      *            @arg CLK_AHBPeriph_SYSTICK
;;;197      *            @arg CLK_AHBPeriph_APB1   
;;;198      *            @arg CLK_AHBPeriph_APB2   
;;;199      *            @arg CLK_AHBPeriph_AHB    
;;;200      *            @arg CLK_AHBPeriph_RF 
;;;201      *            @arg CLK_AHBPeriph_All
;;;202      * @param  NewState    : new state of the specified peripheral clock.
;;;203      *          This parameter can be: ENABLE or DISABLE.
;;;204      * @retval None
;;;205      */
;;;206    void CLK_AHBPeriphClockCmd(uint32_t CLK_AHBPeriph, FunctionalState NewState)
;;;207    {
;;;208        (NewState != DISABLE)?(CLK->AHB_CLK_CTRL |= CLK_AHBPeriph):(CLK->AHB_CLK_CTRL &= ~CLK_AHBPeriph);
;;;209    }
;;;210    
;;;211    /**
;;;212      * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
;;;213      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;214      *         is disabled and the application software has to enable this clock before 
;;;215      *         using it. 
;;;216      * @param  CLK_APB1Periph: specifies the APB1 peripheral to gates its clock.
;;;217      *          This parameter can be any combination of the following values:
;;;218      *            @arg CLK_APB1Periph_I2C0              
;;;219      *            @arg CLK_APB1Periph_SPI0       
;;;220      *            @arg CLK_APB1Periph_UART0     
;;;221      *            @arg CLK_APB1Periph_PWM01    
;;;222      *            @arg CLK_APB1Periph_PWM23      
;;;223      *            @arg CLK_APB1Periph_PWM45  
;;;224      *            @arg CLK_APB1Periph_PWM67   
;;;225      *            @arg CLK_APB1Periph_PWMEN    
;;;226      *            @arg CLK_APB1Periph_ADC    
;;;227      *            @arg CLK_APB1Periph_WDT   
;;;228      *            @arg CLK_APB1Periph_WWDT    
;;;229      *            @arg CLK_APB1Periph_TMR0    
;;;230      *            @arg CLK_APB1Periph_All
;;;231      * @param  NewState  : new state of the specified peripheral clock.
;;;232      *          This parameter can be: ENABLE or DISABLE.
;;;233      * @retval None
;;;234      */
;;;235    void CLK_APB1PeriphClockCmd(uint32_t CLK_APB1Periph, FunctionalState NewState)
;;;236    {
;;;237      (NewState != DISABLE)?(CLK->APB1_CLK_CTRL |= CLK_APB1Periph):(CLK->APB1_CLK_CTRL &= ~CLK_APB1Periph);
;;;238    }
;;;239    
;;;240    /**
;;;241      * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
;;;242      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;243      *         is disabled and the application software has to enable this clock before 
;;;244      *         using it.
;;;245      * @param  CLK_APB2Periph: specifies the APB2 peripheral to gates its clock.
;;;246      *          This parameter can be any combination of the following values:
;;;247      *            @arg CLK_APB2Periph_SPI1 
;;;248      *            @arg CLK_APB2Periph_UART1
;;;249      *            @arg CLK_APB2Periph_TMR1 
;;;250      *            @arg CLK_APB2Periph_TMR2 
;;;251      *            @arg CLK_APB2Periph_All  
;;;252      * @param  NewState: new state of the specified peripheral clock.
;;;253      *          This parameter can be: ENABLE or DISABLE.
;;;254      * @retval None
;;;255      */
;;;256    void CLK_APB2PeriphClockCmd(uint32_t CLK_APB2Periph, FunctionalState NewState)
;;;257    {
;;;258        (NewState != DISABLE)?(CLK->APB2_CLK_CTRL |= CLK_APB2Periph):(CLK->APB2_CLK_CTRL &= ~CLK_APB2Periph); 
;;;259    }
;;;260    
;;;261     /**
;;;262       * @brief  This function check selected clock source status
;;;263       * @param[in]  u32ClkMask is selected clock source. Including
;;;264       *                  - \ref CLK_RCL_SELECT
;;;265       *                  - \ref CLK_RCH_SELECT
;;;266       *                  - \ref CLK_XTL_SELECT
;;;267       *                  - \ref CLK_XTH_SELECT
;;;268       *                  - \ref CLK_DPLL_SELECT
;;;269       * @return   0  clock is not stable
;;;270       *           1  clock is stable
;;;271       *
;;;272       * @details  To wait for clock ready by specified CLKSTATUS bit or timeout (~5ms)
;;;273       */
;;;274    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
;;;275    {
;;;276        int32_t i32TimeOutCnt = 2160000;
;;;277        uint32_t u32ClkTmp = 0;
;;;278        while(1) 
;;;279        {
;;;280    		switch(u32ClkMask){
;;;281    				case CLK_SYS_SRCSEL_RCH :    u32ClkTmp = CLK->RCH_CTRL; break;
;;;282    				case CLK_SYS_SRCSEL_XTH :    u32ClkTmp = CLK->XTH_CTRL; break;
;;;283    //				case CLK_SYS_SRCSEL_RCL :    u32ClkTmp = CLK->RCL_CTRL; break;
;;;284    //				case CLK_SYS_SRCSEL_XTL :    u32ClkTmp = CLK->XTL_CTRL; break;
;;;285    				case CLK_SYS_SRCSEL_DPLL:    u32ClkTmp = CLK->DPLL_CTRL; break;
;;;286    				default: break;
;;;287    		}		
;;;288            if((u32ClkTmp & CLK_STABLE_STATUS_Msk) != CLK_STABLE_STATUS_Msk){
;;;289                if(i32TimeOutCnt-- <= 0)
;;;290                 return 0;
;;;291            }else{
;;;292                break;
;;;293            }  
;;;294        }
;;;295        return 1;
;;;296    }
;;;297     /**
;;;298       * @brief  This function wait sync 3v clock locale stable
;;;299       * @param[in]  none
;;;300       * @return   0  clock sync is not stable
;;;301       *           1  clock sync is stable
;;;302       *
;;;303       * @details  To wait for clock ready by specified CLKSTATUS bit or timeout (~5ms)
;;;304       */
;;;305     uint32_t CLK_Wait3vSyncReady(void)
;;;306     {
;;;307         int32_t i32TimeOutCnt = 2160000;
;;;308    
;;;309        ANA->LP_REG_SYNC |= ANAC_LP_REG_SYNC_3V_Msk;
;;;310        while(ANA->LP_REG_SYNC & (ANAC_LP_REG_SYNC_3V_Msk | ANAC_LP_REG_SYNC_STS_Msk))
;;;311        {
;;;312             if(i32TimeOutCnt-- <= 0)
;;;313                 return 0;
;;;314        }
;;;315    
;;;316         return 1;
;;;317     }
;;;318    /**
;;;319    * @brief  This function wait sync 3v clock locale stable by hardware
;;;320    * @param[in]  none
;;;321    * @return   none
;;;322    */
;;;323    void CLK_Set3vSyncAuto(void)
;;;324    {
;;;325        ANA->LP_REG_SYNC |= ANAC_LP_REG_AUTOSYNC_Msk;
;;;326    }
;;;327    
;;;328    
;;;329    /**
;;;330      * @brief This API is used to select wdt clock source
;;;331      * @param[in] u32clksel wdt clock selection. Could be 
;;;332      *             - \ref CLK_APB1_WDTSEL_MILLI_PULSE, \ref CLK_APB1_WDTSEL_RCL32K
;;;333      * @return none
;;;334      * @note This API is only used to select wdt clock source
;;;335      */
;;;336    void CLK_SetWdtClkSrc(uint32_t u32clksel)
;;;337    {
;;;338        CLK->APB1_CLK_CTRL = (CLK->APB1_CLK_CTRL & ~CLK_APB1CLK_WDTSRC_SEL_Msk) | u32clksel;
;;;339    }
;;;340    
;;;341    /**
;;;342      * @brief This API is used to select wwdt clock source
;;;343      * @param[in] wwdt The base address of wwdt module
;;;344      * @param[in] u32clksel wwdt clock selection. Could be 
;;;345      *             - \ref CLK_APB1_WDTSEL_MILLI_PULSE, \ref CLK_APB1_WDTSEL_RCL32K
;;;346      * @return none
;;;347      * @note This API is only used to select wwdt clock source
;;;348      */
;;;349    
;;;350    void CLK_SetWwdtClkSrc(uint32_t u32clksel)
;;;351    {
;;;352        CLK->APB1_CLK_CTRL = (CLK->APB1_CLK_CTRL & ~CLK_APB1CLK_WWDTSRC_SEL_Msk) | u32clksel;
;;;353    }
;;;354    
;;;355    
;;;356    /**
;;;357      * @brief This API is used to SELECT timer clock source
;;;358      * @param[in] timer The base address of Timer module
;;;359      * @param[in] u32clksel timer clock selection. Could be 
;;;360      *             - \ref CLK_APB_TMR0SEL_APB1CLK, \ref CLK_APB_TMR0SEL_LIRC,\ref CLK_APB_TMR0SEL_TM0
;;;361      *             - \ref CLK_APB_TMR1SEL_APB2CLK, \ref CLK_APB_TMR1SEL_LIRC,\ref CLK_APB_TMR0SEL_TM1
;;;362      *             - \ref CLK_APB_TMR2SEL_APB2CLK, \ref CLK_APB_TMR2SEL_LIRC,\ref CLK_APB_TMR0SEL_TM2
;;;363      * @return none
;;;364      * @note This API is only used to select timer clock source
;;;365      */
;;;366    
;;;367    void CLK_SetTmrClkSrc(TIMER_T *timer, uint32_t u32clksel)
;;;368    {
;;;369        if(timer == TIMER0) {        
;;;370            CLK->APB1_CLK_CTRL = (CLK->APB1_CLK_CTRL & ~CLK_APB1CLK_TMR0SRC_SEL_Msk) | u32clksel;
;;;371        }
;;;372        else if(timer == TIMER1){
;;;373            CLK->APB2_CLK_CTRL = (CLK->APB2_CLK_CTRL & ~CLK_APB2CLK_TMR1SRC_SEL_Msk) | u32clksel;
;;;374        }
;;;375        else if(timer == TIMER2){
;;;376            CLK->APB2_CLK_CTRL = (CLK->APB2_CLK_CTRL & ~CLK_APB2CLK_TMR2SRC_SEL_Msk) | u32clksel;
;;;377        }
;;;378    }
;;;379    
;;;380    uint32_t CLK_GetPeripheralFreq(void * Peripheral)
;;;381    {
        0x000004a4:    b510        ..      PUSH     {r4,lr}
        0x000004a6:    4604        .F      MOV      r4,r0
;;;382        uint8_t u8ApbDiv = 0;
;;;383    	  uint32_t u32AhbClk,u32Pclk;
;;;384    
;;;385    	/*get system clock frequency*/
;;;386        u32AhbClk = CLK_GetHCLKFreq(); 
        0x000004a8:    f7fffff4    ....    BL       CLK_GetHCLKFreq ; 0x494
        0x000004ac:    4602        .F      MOV      r2,r0
;;;387        
;;;388        if((I2C0    == (I2C_T *)   Peripheral) 
        0x000004ae:    2101        .!      MOVS     r1,#1
        0x000004b0:    0789        ..      LSLS     r1,r1,#30
        0x000004b2:    4819        .H      LDR      r0,[pc,#100] ; [0x518] = 0x40040000
        0x000004b4:    428c        .B      CMP      r4,r1
        0x000004b6:    d00e        ..      BEQ      0x4d6 ; CLK_GetPeripheralFreq + 50
;;;389         ||(UART0   == (UART_T *)  Peripheral)
        0x000004b8:    4918        .I      LDR      r1,[pc,#96] ; [0x51c] = 0x40003000
        0x000004ba:    428c        .B      CMP      r4,r1
        0x000004bc:    d00b        ..      BEQ      0x4d6 ; CLK_GetPeripheralFreq + 50
;;;390         ||(SPI0    == (SPI_T *)   Peripheral)
        0x000004be:    4918        .I      LDR      r1,[pc,#96] ; [0x520] = 0x40001000
        0x000004c0:    428c        .B      CMP      r4,r1
        0x000004c2:    d008        ..      BEQ      0x4d6 ; CLK_GetPeripheralFreq + 50
;;;391         ||(TIMER0  == (TIMER_T *) Peripheral)
        0x000004c4:    4917        .I      LDR      r1,[pc,#92] ; [0x524] = 0x40008000
        0x000004c6:    428c        .B      CMP      r4,r1
        0x000004c8:    d005        ..      BEQ      0x4d6 ; CLK_GetPeripheralFreq + 50
;;;392    		 ||(I2S_M   == (I2S_T *)   Peripheral)
        0x000004ca:    4917        .I      LDR      r1,[pc,#92] ; [0x528] = 0x40009000
        0x000004cc:    428c        .B      CMP      r4,r1
        0x000004ce:    d002        ..      BEQ      0x4d6 ; CLK_GetPeripheralFreq + 50
;;;393    		 ||(I2S_S   == (I2S_T *)   Peripheral))
        0x000004d0:    4916        .I      LDR      r1,[pc,#88] ; [0x52c] = 0x4000a000
        0x000004d2:    428c        .B      CMP      r4,r1
        0x000004d4:    d102        ..      BNE      0x4dc ; CLK_GetPeripheralFreq + 56
;;;394        {
;;;395            u8ApbDiv = (CLK->CLK_TOP_CTRL & CLK_TOPCTL_APB1_DIV_Msk) >> CLK_TOPCTL_APB1_DIV_Pos;
        0x000004d6:    6a00        .j      LDR      r0,[r0,#0x20]
        0x000004d8:    0c00        ..      LSRS     r0,r0,#16
        0x000004da:    e013        ..      B        0x504 ; CLK_GetPeripheralFreq + 96
;;;396        }
;;;397        else if((SPI1    == (SPI_T *)    Peripheral) 
        0x000004dc:    4914        .I      LDR      r1,[pc,#80] ; [0x530] = 0x40011000
        0x000004de:    428c        .B      CMP      r4,r1
        0x000004e0:    d00e        ..      BEQ      0x500 ; CLK_GetPeripheralFreq + 92
;;;398              ||(UART1   == (UART_T *)   Peripheral)
        0x000004e2:    4914        .I      LDR      r1,[pc,#80] ; [0x534] = 0x40013000
        0x000004e4:    428c        .B      CMP      r4,r1
        0x000004e6:    d00b        ..      BEQ      0x500 ; CLK_GetPeripheralFreq + 92
;;;399              ||(TIMER1  == (TIMER_T *)  Peripheral)
        0x000004e8:    4913        .I      LDR      r1,[pc,#76] ; [0x538] = 0x40014000
        0x000004ea:    428c        .B      CMP      r4,r1
        0x000004ec:    d008        ..      BEQ      0x500 ; CLK_GetPeripheralFreq + 92
;;;400              ||(TIMER2  == (TIMER_T *)  Peripheral)
        0x000004ee:    4913        .I      LDR      r1,[pc,#76] ; [0x53c] = 0x40015000
        0x000004f0:    428c        .B      CMP      r4,r1
        0x000004f2:    d005        ..      BEQ      0x500 ; CLK_GetPeripheralFreq + 92
;;;401              ||(KSCAN == (KSCAN_T*) Peripheral)
        0x000004f4:    4912        .I      LDR      r1,[pc,#72] ; [0x540] = 0x40019000
        0x000004f6:    428c        .B      CMP      r4,r1
        0x000004f8:    d002        ..      BEQ      0x500 ; CLK_GetPeripheralFreq + 92
;;;402              ||(QDEC    == (QDEC_T *)   Peripheral))
        0x000004fa:    4912        .I      LDR      r1,[pc,#72] ; [0x544] = 0x4001a000
        0x000004fc:    428c        .B      CMP      r4,r1
        0x000004fe:    d109        ..      BNE      0x514 ; CLK_GetPeripheralFreq + 112
;;;403            u8ApbDiv = (CLK->CLK_TOP_CTRL & CLK_TOPCTL_APB2_DIV_Msk) >> CLK_TOPCTL_APB2_DIV_Pos;
        0x00000500:    6a00        .j      LDR      r0,[r0,#0x20]
        0x00000502:    0d00        ..      LSRS     r0,r0,#20
        0x00000504:    0700        ..      LSLS     r0,r0,#28
        0x00000506:    0f00        ..      LSRS     r0,r0,#28
        0x00000508:    d004        ..      BEQ      0x514 ; CLK_GetPeripheralFreq + 112
;;;404        
;;;405        if(u8ApbDiv)
;;;406            u32Pclk = u32AhbClk / (2 * u8ApbDiv);
        0x0000050a:    0041        A.      LSLS     r1,r0,#1
        0x0000050c:    4610        .F      MOV      r0,r2
        0x0000050e:    f7fffdfd    ....    BL       __aeabi_uidiv ; 0x10c
        0x00000512:    bd10        ..      POP      {r4,pc}
;;;407        else
;;;408            u32Pclk = u32AhbClk;
        0x00000514:    4610        .F      MOV      r0,r2
;;;409        return u32Pclk;
;;;410    }
        0x00000516:    bd10        ..      POP      {r4,pc}
    $d
        0x00000518:    40040000    ...@    DCD    1074003968
        0x0000051c:    40003000    .0.@    DCD    1073754112
        0x00000520:    40001000    ...@    DCD    1073745920
        0x00000524:    40008000    ...@    DCD    1073774592
        0x00000528:    40009000    ...@    DCD    1073778688
        0x0000052c:    4000a000    ...@    DCD    1073782784
        0x00000530:    40011000    ...@    DCD    1073811456
        0x00000534:    40013000    .0.@    DCD    1073819648
        0x00000538:    40014000    .@.@    DCD    1073823744
        0x0000053c:    40015000    .P.@    DCD    1073827840
        0x00000540:    40019000    ...@    DCD    1073844224
        0x00000544:    4001a000    ...@    DCD    1073848320
    $t
    i.CLK_RefClkSrcConfig
    CLK_RefClkSrcConfig
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (101)
        0x00000548:    b510        ..      PUSH     {r4,lr}
        0x0000054a:    4c1a        .L      LDR      r4,[pc,#104] ; [0x5b4] = 0x40040000
        0x0000054c:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0000054e:    2203        ."      MOVS     r2,#3
        0x00000550:    0212        ..      LSLS     r2,r2,#8
        0x00000552:    4391        .C      BICS     r1,r1,r2
        0x00000554:    6221        !b      STR      r1,[r4,#0x20]
        0x00000556:    2800        .(      CMP      r0,#0
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (101)
        0x00000558:    d006        ..      BEQ      0x568 ; CLK_RefClkSrcConfig + 32
;;;102    //    uint32_t tmpreg;
;;;103        CLK->CLK_TOP_CTRL &= ~CLK_TOPCTL_SYS_CLK_SEL_Msk;
;;;104        switch(u32ClkSrc)
        0x0000055a:    1fc1        ..      SUBS     r1,r0,#7
        0x0000055c:    39f9        .9      SUBS     r1,r1,#0xf9
        0x0000055e:    d00b        ..      BEQ      0x578 ; CLK_RefClkSrcConfig + 48
        0x00000560:    39ff        .9      SUBS     r1,r1,#0xff
        0x00000562:    2901        .)      CMP      r1,#1
        0x00000564:    d117        ..      BNE      0x596 ; CLK_RefClkSrcConfig + 78
        0x00000566:    e019        ..      B        0x59c ; CLK_RefClkSrcConfig + 84
;;;105        {
;;;106            case CLK_SYS_SRCSEL_RCH: 
;;;107                CLK->CLK_TOP_CTRL |= CLK_TOPCTL_RCH_EN_Msk;
        0x00000568:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0000056a:    2202        ."      MOVS     r2,#2
        0x0000056c:    4311        .C      ORRS     r1,r1,r2
        0x0000056e:    6221        !b      STR      r1,[r4,#0x20]
;;;108    #ifdef SYNC_3V_REG_MANUALLY
;;;109                CLK_Wait3vSyncReady();
;;;110    #endif
;;;111    			CLK_WaitClockReady(u32ClkSrc);
        0x00000570:    f000f860    ..`.    BL       CLK_WaitClockReady ; 0x634
;;;112                CLK->CLK_TOP_CTRL |= CLK_SYS_SRCSEL_RCH;
        0x00000574:    6a20         j      LDR      r0,[r4,#0x20]
;;;113                break;
        0x00000576:    e00d        ..      B        0x594 ; CLK_RefClkSrcConfig + 76
;;; ..\..\..\..\pan108\device\Include\pan_clk.h
;;;195        CLK->XTH_CTRL |= (CLK_XTHCTL_FSYN_EN_Msk | CLK_XTHCTL_START_FAST_Msk);
        0x00000578:    6b21        !k      LDR      r1,[r4,#0x30]
        0x0000057a:    2205        ."      MOVS     r2,#5
        0x0000057c:    4311        .C      ORRS     r1,r1,r2
        0x0000057e:    6321        !c      STR      r1,[r4,#0x30]
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c
;;;116                CLK->CLK_TOP_CTRL |= CLK_TOPCTL_XTH_EN_Msk;
        0x00000580:    6a21        !j      LDR      r1,[r4,#0x20]
        0x00000582:    2208        ."      MOVS     r2,#8
        0x00000584:    4311        .C      ORRS     r1,r1,r2
        0x00000586:    6221        !b      STR      r1,[r4,#0x20]
;;;117    #ifdef SYNC_3V_REG_MANUALLY
;;;118                CLK_Wait3vSyncReady();
;;;119    #endif
;;;120    			CLK_WaitClockReady(u32ClkSrc);
        0x00000588:    f000f854    ..T.    BL       CLK_WaitClockReady ; 0x634
;;;121                CLK->CLK_TOP_CTRL |= CLK_SYS_SRCSEL_XTH;
        0x0000058c:    6a20         j      LDR      r0,[r4,#0x20]
        0x0000058e:    21ff        .!      MOVS     r1,#0xff
        0x00000590:    3101        .1      ADDS     r1,#1
;;;122                break;
        0x00000592:    e00c        ..      B        0x5ae ; CLK_RefClkSrcConfig + 102
        0x00000594:    6220         b      STR      r0,[r4,#0x20]
        0x00000596:    f000fff9    ....    BL       SystemCoreClockUpdate ; 0x158c
        0x0000059a:    bd10        ..      POP      {r4,pc}
;;;123    //        case CLK_SYS_SRCSEL_RCL: 
;;;124    //            CLK->CLK_TOP_CTRL |= (CLK_SYS_SRCSEL_RCL | CLK_TOPCTL_RCL_EN_Msk);
;;;125    //            break;
;;;126    //        case CLK_SYS_SRCSEL_XTL: 
;;;127    //            CLK->CLK_TOP_CTRL |= (CLK_SYS_SRCSEL_XTL | CLK_TOPCTL_XTL_EN_Msk); 
;;;128    //            break;
;;;129            case CLK_SYS_SRCSEL_DPLL: 
;;;130                CLK->CLK_TOP_CTRL |= CLK_TOPCTL_DPLL_EN_Msk;
        0x0000059c:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0000059e:    2210        ."      MOVS     r2,#0x10
        0x000005a0:    4311        .C      ORRS     r1,r1,r2
        0x000005a2:    6221        !b      STR      r1,[r4,#0x20]
;;;131    #ifdef SYNC_3V_REG_MANUALLY
;;;132                CLK_Wait3vSyncReady();
;;;133    #endif
;;;134    			CLK_WaitClockReady(u32ClkSrc);
        0x000005a4:    f000f846    ..F.    BL       CLK_WaitClockReady ; 0x634
;;;135                CLK->CLK_TOP_CTRL |= CLK_SYS_SRCSEL_DPLL;
        0x000005a8:    6a20         j      LDR      r0,[r4,#0x20]
        0x000005aa:    2101        .!      MOVS     r1,#1
        0x000005ac:    0249        I.      LSLS     r1,r1,#9
        0x000005ae:    4308        .C      ORRS     r0,r0,r1
        0x000005b0:    e7f0        ..      B        0x594 ; CLK_RefClkSrcConfig + 76
    $d
        0x000005b2:    0000        ..      DCW    0
        0x000005b4:    40040000    ...@    DCD    1074003968
    $t
    i.CLK_SYSCLKConfig
    CLK_SYSCLKConfig
;;;136                break;
;;;137            default: break;
;;;138        }
;;;139    
;;;140        //wait xtal clock stable
;;;141    //    CLK_WaitClockReady(u32ClkSrc);
;;;142    	SystemCoreClockUpdate();
;;;143    }
;;;144    /**
;;;145    * @brief  This function set HCLK clock source
;;;146    * @param[in]  u32ClkSrc is HCLK clock source. Including :
;;;147    *                  - \ref CLK_DPLL_REF_CLKSEL_RCH
;;;148    *                  - \ref CLK_DPLL_REF_CLKSEL_XTH
;;;149    * @return None
;;;150    */
;;;151    void CLK_SYSCLKConfig(uint32_t u32ClkSrc,uint32_t freq_out)
;;;152    {
        0x000005b8:    b500        ..      PUSH     {lr}
        0x000005ba:    2302        .#      MOVS     r3,#2
        0x000005bc:    4a0d        .J      LDR      r2,[pc,#52] ; [0x5f4] = 0x40040000
        0x000005be:    2800        .(      CMP      r0,#0
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (152)
        0x000005c0:    d002        ..      BEQ      0x5c8 ; CLK_SYSCLKConfig + 16
        0x000005c2:    2802        .(      CMP      r0,#2
        0x000005c4:    d003        ..      BEQ      0x5ce ; CLK_SYSCLKConfig + 22
        0x000005c6:    e005        ..      B        0x5d4 ; CLK_SYSCLKConfig + 28
;;;153        if(u32ClkSrc == CLK_DPLL_REF_CLKSEL_RCH){
;;;154            CLK->DPLL_CTRL &= ~CLK_DPLLCTL_RCLK_SEL_Msk;
        0x000005c8:    6b50        Pk      LDR      r0,[r2,#0x34]
        0x000005ca:    4398        .C      BICS     r0,r0,r3
        0x000005cc:    e001        ..      B        0x5d2 ; CLK_SYSCLKConfig + 26
;;;155        }
;;;156        else if(u32ClkSrc == CLK_DPLL_REF_CLKSEL_XTH){
;;;157            CLK->DPLL_CTRL |= CLK_DPLLCTL_RCLK_SEL_Msk;
        0x000005ce:    6b50        Pk      LDR      r0,[r2,#0x34]
        0x000005d0:    4318        .C      ORRS     r0,r0,r3
        0x000005d2:    6350        Pc      STR      r0,[r2,#0x34]
;;; ..\..\..\..\pan108\device\Include\pan_clk.h
;;;301        CLK->DPLL_CTRL &= ~CLK_DPLLCTL_FREQ_OUT_Msk;
        0x000005d4:    6b50        Pk      LDR      r0,[r2,#0x34]
        0x000005d6:    0840        @.      LSRS     r0,r0,#1
        0x000005d8:    0040        @.      LSLS     r0,r0,#1
        0x000005da:    6350        Pc      STR      r0,[r2,#0x34]
;;;302        CLK->DPLL_CTRL |= freq;
        0x000005dc:    6b50        Pk      LDR      r0,[r2,#0x34]
        0x000005de:    4308        .C      ORRS     r0,r0,r1
        0x000005e0:    6350        Pc      STR      r0,[r2,#0x34]
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c
;;;163        CLK->CLK_TOP_CTRL |=  CLK_TOPCTL_DPLL_EN_Msk;
        0x000005e2:    6a10        .j      LDR      r0,[r2,#0x20]
        0x000005e4:    2110        .!      MOVS     r1,#0x10
        0x000005e6:    4308        .C      ORRS     r0,r0,r1
        0x000005e8:    6210        .b      STR      r0,[r2,#0x20]
;;;164    #ifdef SYNC_3V_REG_MANUALLY
;;;165        CLK_Wait3vSyncReady();
;;;166    #endif
;;;167        CLK_WaitClockReady(CLK_SYS_SRCSEL_DPLL);
        0x000005ea:    0148        H.      LSLS     r0,r1,#5
        0x000005ec:    f000f822    ..".    BL       CLK_WaitClockReady ; 0x634
;;;168    
;;;169        /* Update System Core Clock */
;;;170    //    SystemCoreClockUpdate();
;;;171    }
        0x000005f0:    bd00        ..      POP      {pc}
    $d
        0x000005f2:    0000        ..      DCW    0
        0x000005f4:    40040000    ...@    DCD    1074003968
    $t
    i.CLK_Set3vSyncAuto
    CLK_Set3vSyncAuto
;;;172    
;;;173    
;;;174    
;;;175    //void CLK_SetClkDivide(uint32_t u32ClkSel,uint32_t u32ClkDiv)
;;;176    //{
;;;177    //    switch(u32ClkSel){
;;;178    //        case CLK_DivideSource_Apb1:
;;;179    //            CLK->CLK_TOP_CTRL = (CLK->CLK_TOP_CTRL & (~CLK_TOPCTL_APB1_DIV_Msk))| u32ClkDiv;
;;;180    //            break;
;;;181    //        case CLK_DivideSource_Apb2:
;;;182    //            CLK->CLK_TOP_CTRL = (CLK->CLK_TOP_CTRL & (~CLK_TOPCTL_APB2_DIV_Msk))| u32ClkDiv;
;;;183    //            break;
;;;184    //        default: break;
;;;185    //    }
;;;186    //}
;;;187    /**
;;;188      * @brief  Enables or disables the AHB peripheral clock.
;;;189      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;190      *         is disabled and the application software has to enable this clock before 
;;;191      *         using it. 
;;;192      * @param  CLK_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
;;;193      *          This parameter can be any combination of the following values:
;;;194      *            @arg CLK_AHBPeriph_DMAC   
;;;195      *            @arg CLK_AHBPeriph_GPIO   
;;;196      *            @arg CLK_AHBPeriph_SYSTICK
;;;197      *            @arg CLK_AHBPeriph_APB1   
;;;198      *            @arg CLK_AHBPeriph_APB2   
;;;199      *            @arg CLK_AHBPeriph_AHB    
;;;200      *            @arg CLK_AHBPeriph_RF 
;;;201      *            @arg CLK_AHBPeriph_All
;;;202      * @param  NewState    : new state of the specified peripheral clock.
;;;203      *          This parameter can be: ENABLE or DISABLE.
;;;204      * @retval None
;;;205      */
;;;206    void CLK_AHBPeriphClockCmd(uint32_t CLK_AHBPeriph, FunctionalState NewState)
;;;207    {
;;;208        (NewState != DISABLE)?(CLK->AHB_CLK_CTRL |= CLK_AHBPeriph):(CLK->AHB_CLK_CTRL &= ~CLK_AHBPeriph);
;;;209    }
;;;210    
;;;211    /**
;;;212      * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
;;;213      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;214      *         is disabled and the application software has to enable this clock before 
;;;215      *         using it. 
;;;216      * @param  CLK_APB1Periph: specifies the APB1 peripheral to gates its clock.
;;;217      *          This parameter can be any combination of the following values:
;;;218      *            @arg CLK_APB1Periph_I2C0              
;;;219      *            @arg CLK_APB1Periph_SPI0       
;;;220      *            @arg CLK_APB1Periph_UART0     
;;;221      *            @arg CLK_APB1Periph_PWM01    
;;;222      *            @arg CLK_APB1Periph_PWM23      
;;;223      *            @arg CLK_APB1Periph_PWM45  
;;;224      *            @arg CLK_APB1Periph_PWM67   
;;;225      *            @arg CLK_APB1Periph_PWMEN    
;;;226      *            @arg CLK_APB1Periph_ADC    
;;;227      *            @arg CLK_APB1Periph_WDT   
;;;228      *            @arg CLK_APB1Periph_WWDT    
;;;229      *            @arg CLK_APB1Periph_TMR0    
;;;230      *            @arg CLK_APB1Periph_All
;;;231      * @param  NewState  : new state of the specified peripheral clock.
;;;232      *          This parameter can be: ENABLE or DISABLE.
;;;233      * @retval None
;;;234      */
;;;235    void CLK_APB1PeriphClockCmd(uint32_t CLK_APB1Periph, FunctionalState NewState)
;;;236    {
;;;237      (NewState != DISABLE)?(CLK->APB1_CLK_CTRL |= CLK_APB1Periph):(CLK->APB1_CLK_CTRL &= ~CLK_APB1Periph);
;;;238    }
;;;239    
;;;240    /**
;;;241      * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
;;;242      * @note   After reset, the peripheral clock (used for registers read/write access)
;;;243      *         is disabled and the application software has to enable this clock before 
;;;244      *         using it.
;;;245      * @param  CLK_APB2Periph: specifies the APB2 peripheral to gates its clock.
;;;246      *          This parameter can be any combination of the following values:
;;;247      *            @arg CLK_APB2Periph_SPI1 
;;;248      *            @arg CLK_APB2Periph_UART1
;;;249      *            @arg CLK_APB2Periph_TMR1 
;;;250      *            @arg CLK_APB2Periph_TMR2 
;;;251      *            @arg CLK_APB2Periph_All  
;;;252      * @param  NewState: new state of the specified peripheral clock.
;;;253      *          This parameter can be: ENABLE or DISABLE.
;;;254      * @retval None
;;;255      */
;;;256    void CLK_APB2PeriphClockCmd(uint32_t CLK_APB2Periph, FunctionalState NewState)
;;;257    {
;;;258        (NewState != DISABLE)?(CLK->APB2_CLK_CTRL |= CLK_APB2Periph):(CLK->APB2_CLK_CTRL &= ~CLK_APB2Periph); 
;;;259    }
;;;260    
;;;261     /**
;;;262       * @brief  This function check selected clock source status
;;;263       * @param[in]  u32ClkMask is selected clock source. Including
;;;264       *                  - \ref CLK_RCL_SELECT
;;;265       *                  - \ref CLK_RCH_SELECT
;;;266       *                  - \ref CLK_XTL_SELECT
;;;267       *                  - \ref CLK_XTH_SELECT
;;;268       *                  - \ref CLK_DPLL_SELECT
;;;269       * @return   0  clock is not stable
;;;270       *           1  clock is stable
;;;271       *
;;;272       * @details  To wait for clock ready by specified CLKSTATUS bit or timeout (~5ms)
;;;273       */
;;;274    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
;;;275    {
;;;276        int32_t i32TimeOutCnt = 2160000;
;;;277        uint32_t u32ClkTmp = 0;
;;;278        while(1) 
;;;279        {
;;;280    		switch(u32ClkMask){
;;;281    				case CLK_SYS_SRCSEL_RCH :    u32ClkTmp = CLK->RCH_CTRL; break;
;;;282    				case CLK_SYS_SRCSEL_XTH :    u32ClkTmp = CLK->XTH_CTRL; break;
;;;283    //				case CLK_SYS_SRCSEL_RCL :    u32ClkTmp = CLK->RCL_CTRL; break;
;;;284    //				case CLK_SYS_SRCSEL_XTL :    u32ClkTmp = CLK->XTL_CTRL; break;
;;;285    				case CLK_SYS_SRCSEL_DPLL:    u32ClkTmp = CLK->DPLL_CTRL; break;
;;;286    				default: break;
;;;287    		}		
;;;288            if((u32ClkTmp & CLK_STABLE_STATUS_Msk) != CLK_STABLE_STATUS_Msk){
;;;289                if(i32TimeOutCnt-- <= 0)
;;;290                 return 0;
;;;291            }else{
;;;292                break;
;;;293            }  
;;;294        }
;;;295        return 1;
;;;296    }
;;;297     /**
;;;298       * @brief  This function wait sync 3v clock locale stable
;;;299       * @param[in]  none
;;;300       * @return   0  clock sync is not stable
;;;301       *           1  clock sync is stable
;;;302       *
;;;303       * @details  To wait for clock ready by specified CLKSTATUS bit or timeout (~5ms)
;;;304       */
;;;305     uint32_t CLK_Wait3vSyncReady(void)
;;;306     {
;;;307         int32_t i32TimeOutCnt = 2160000;
;;;308    
;;;309        ANA->LP_REG_SYNC |= ANAC_LP_REG_SYNC_3V_Msk;
;;;310        while(ANA->LP_REG_SYNC & (ANAC_LP_REG_SYNC_3V_Msk | ANAC_LP_REG_SYNC_STS_Msk))
;;;311        {
;;;312             if(i32TimeOutCnt-- <= 0)
;;;313                 return 0;
;;;314        }
;;;315    
;;;316         return 1;
;;;317     }
;;;318    /**
;;;319    * @brief  This function wait sync 3v clock locale stable by hardware
;;;320    * @param[in]  none
;;;321    * @return   none
;;;322    */
;;;323    void CLK_Set3vSyncAuto(void)
;;;324    {
;;;325        ANA->LP_REG_SYNC |= ANAC_LP_REG_AUTOSYNC_Msk;
        0x000005f8:    4802        .H      LDR      r0,[pc,#8] ; [0x604] = 0x40070000
        0x000005fa:    6801        .h      LDR      r1,[r0,#0]
        0x000005fc:    2204        ."      MOVS     r2,#4
        0x000005fe:    4311        .C      ORRS     r1,r1,r2
        0x00000600:    6001        .`      STR      r1,[r0,#0]
;;;326    }
        0x00000602:    4770        pG      BX       lr
    $d
        0x00000604:    40070000    ...@    DCD    1074200576
    $t
    i.CLK_Wait3vSyncReady
    CLK_Wait3vSyncReady
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (309)
        0x00000608:    4809        .H      LDR      r0,[pc,#36] ; [0x630] = 0x40070000
        0x0000060a:    4908        .I      LDR      r1,[pc,#32] ; [0x62c] = 0x20f580
        0x0000060c:    6802        .h      LDR      r2,[r0,#0]
        0x0000060e:    2301        .#      MOVS     r3,#1
        0x00000610:    431a        .C      ORRS     r2,r2,r3
        0x00000612:    6002        .`      STR      r2,[r0,#0]
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (306)
        0x00000614:    e005        ..      B        0x622 ; CLK_Wait3vSyncReady + 26
        0x00000616:    460a        .F      MOV      r2,r1
        0x00000618:    1e49        I.      SUBS     r1,r1,#1
        0x0000061a:    2a00        .*      CMP      r2,#0
        0x0000061c:    dc01        ..      BGT      0x622 ; CLK_Wait3vSyncReady + 26
        0x0000061e:    2000        .       MOVS     r0,#0
        0x00000620:    4770        pG      BX       lr
;;;307         int32_t i32TimeOutCnt = 2160000;
;;;308    
;;;309        ANA->LP_REG_SYNC |= ANAC_LP_REG_SYNC_3V_Msk;
;;;310        while(ANA->LP_REG_SYNC & (ANAC_LP_REG_SYNC_3V_Msk | ANAC_LP_REG_SYNC_STS_Msk))
        0x00000622:    6802        .h      LDR      r2,[r0,#0]
        0x00000624:    0792        ..      LSLS     r2,r2,#30
        0x00000626:    d1f6        ..      BNE      0x616 ; CLK_Wait3vSyncReady + 14
;;;311        {
;;;312             if(i32TimeOutCnt-- <= 0)
;;;313                 return 0;
;;;314        }
;;;315    
;;;316         return 1;
        0x00000628:    2001        .       MOVS     r0,#1
;;;317     }
        0x0000062a:    4770        pG      BX       lr
    $d
        0x0000062c:    0020f580    .. .    DCD    2160000
        0x00000630:    40070000    ...@    DCD    1074200576
    $t
    i.CLK_WaitClockReady
    CLK_WaitClockReady
;;; .\..\..\..\..\pan108\device\Source\pan_clk.c (275)
        0x00000634:    b510        ..      PUSH     {r4,lr}
;;;276        int32_t i32TimeOutCnt = 2160000;
        0x00000636:    4c0d        .L      LDR      r4,[pc,#52] ; [0x66c] = 0x20f580
        0x00000638:    4b0d        .K      LDR      r3,[pc,#52] ; [0x670] = 0x40040000
;;;277        uint32_t u32ClkTmp = 0;
        0x0000063a:    2100        .!      MOVS     r1,#0
;;;278        while(1) 
;;;279        {
;;;280    		switch(u32ClkMask){
        0x0000063c:    2800        .(      CMP      r0,#0
        0x0000063e:    d006        ..      BEQ      0x64e ; CLK_WaitClockReady + 26
        0x00000640:    1fc2        ..      SUBS     r2,r0,#7
        0x00000642:    3af9        .:      SUBS     r2,r2,#0xf9
        0x00000644:    d005        ..      BEQ      0x652 ; CLK_WaitClockReady + 30
        0x00000646:    3aff        .:      SUBS     r2,r2,#0xff
        0x00000648:    2a01        .*      CMP      r2,#1
        0x0000064a:    d105        ..      BNE      0x658 ; CLK_WaitClockReady + 36
        0x0000064c:    e003        ..      B        0x656 ; CLK_WaitClockReady + 34
;;;281    				case CLK_SYS_SRCSEL_RCH :    u32ClkTmp = CLK->RCH_CTRL; break;
        0x0000064e:    6a99        .j      LDR      r1,[r3,#0x28]
        0x00000650:    e002        ..      B        0x658 ; CLK_WaitClockReady + 36
;;;282    				case CLK_SYS_SRCSEL_XTH :    u32ClkTmp = CLK->XTH_CTRL; break;
        0x00000652:    6b19        .k      LDR      r1,[r3,#0x30]
        0x00000654:    e000        ..      B        0x658 ; CLK_WaitClockReady + 36
;;;283    //				case CLK_SYS_SRCSEL_RCL :    u32ClkTmp = CLK->RCL_CTRL; break;
;;;284    //				case CLK_SYS_SRCSEL_XTL :    u32ClkTmp = CLK->XTL_CTRL; break;
;;;285    				case CLK_SYS_SRCSEL_DPLL:    u32ClkTmp = CLK->DPLL_CTRL; break;
        0x00000656:    6b59        Yk      LDR      r1,[r3,#0x34]
;;;286    				default: break;
;;;287    		}		
;;;288            if((u32ClkTmp & CLK_STABLE_STATUS_Msk) != CLK_STABLE_STATUS_Msk){
        0x00000658:    01ca        ..      LSLS     r2,r1,#7
        0x0000065a:    d405        ..      BMI      0x668 ; CLK_WaitClockReady + 52
;;;289                if(i32TimeOutCnt-- <= 0)
        0x0000065c:    4622        "F      MOV      r2,r4
        0x0000065e:    1e64        d.      SUBS     r4,r4,#1
        0x00000660:    2a00        .*      CMP      r2,#0
        0x00000662:    dceb        ..      BGT      0x63c ; CLK_WaitClockReady + 8
;;;290                 return 0;
        0x00000664:    2000        .       MOVS     r0,#0
        0x00000666:    bd10        ..      POP      {r4,pc}
;;;291            }else{
;;;292                break;
;;;293            }  
;;;294        }
;;;295        return 1;
        0x00000668:    2001        .       MOVS     r0,#1
;;;296    }
        0x0000066a:    bd10        ..      POP      {r4,pc}
    $d
        0x0000066c:    0020f580    .. .    DCD    2160000
        0x00000670:    40040000    ...@    DCD    1074003968
    $t
    i.FMC_EnterEnhanceMode
    FMC_EnterEnhanceMode
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c
;;;971        if (mode == FLASH_X2_MODE)
        0x00000674:    2901        .)      CMP      r1,#1
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c (970)
        0x00000676:    d002        ..      BEQ      0x67e ; FMC_EnterEnhanceMode + 10
        0x00000678:    2902        .)      CMP      r1,#2
        0x0000067a:    d005        ..      BEQ      0x688 ; FMC_EnterEnhanceMode + 20
        0x0000067c:    e009        ..      B        0x692 ; FMC_EnterEnhanceMode + 30
;;;971        if (mode == FLASH_X2_MODE)
;;;972        {
;;;973            fmc->X_FL_WD[0]   = 0xBB;
        0x0000067e:    21bb        .!      MOVS     r1,#0xbb
        0x00000680:    7181        .q      STRB     r1,[r0,#6]
;;;974            fmc->X_FL_CTL = (1<<8) | (5<<0);
        0x00000682:    21ff        .!      MOVS     r1,#0xff
        0x00000684:    3106        .1      ADDS     r1,#6
        0x00000686:    e003        ..      B        0x690 ; FMC_EnterEnhanceMode + 28
;;;975        }
;;;976        else if (mode == FLASH_X4_MODE)
;;;977        {
;;;978            fmc->X_FL_WD[0]   = 0xEB;
        0x00000688:    21eb        .!      MOVS     r1,#0xeb
        0x0000068a:    7181        .q      STRB     r1,[r0,#6]
;;;979            fmc->X_FL_CTL = (1<<8) | (7<<0);
        0x0000068c:    21ff        .!      MOVS     r1,#0xff
        0x0000068e:    3108        .1      ADDS     r1,r1,#8
        0x00000690:    6001        .`      STR      r1,[r0,#0]
;;;980        }
;;;981    
;;;982        fmc->X_FL_WD[4]   = 0xAF;  //8'b10_10_1111 for both GD & PUYA flash
        0x00000692:    21af        .!      MOVS     r1,#0xaf
        0x00000694:    7281        .r      STRB     r1,[r0,#0xa]
;;;983    	fmc->X_FL_X_MODE |= (0x1 << 18);
        0x00000696:    68c1        .h      LDR      r1,[r0,#0xc]
        0x00000698:    2201        ."      MOVS     r2,#1
        0x0000069a:    0492        ..      LSLS     r2,r2,#18
        0x0000069c:    4311        .C      ORRS     r1,r1,r2
        0x0000069e:    60c1        .`      STR      r1,[r0,#0xc]
;;;984    	fmc->X_FL_TRIG = CMD_TRIG;
        0x000006a0:    2101        .!      MOVS     r1,#1
        0x000006a2:    7101        .q      STRB     r1,[r0,#4]
;;;985    	while(fmc->X_FL_TRIG){};
        0x000006a4:    7901        .y      LDRB     r1,[r0,#4]
        0x000006a6:    2900        .)      CMP      r1,#0
        0x000006a8:    d1fc        ..      BNE      0x6a4 ; FMC_EnterEnhanceMode + 48
;;;986    }
        0x000006aa:    4770        pG      BX       lr
    i.FMC_ExitEnhanceMode
    FMC_ExitEnhanceMode
        0x000006ac:    21ff        .!      MOVS     r1,#0xff
        0x000006ae:    7181        .q      STRB     r1,[r0,#6]
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c (958)
        0x000006b0:    71c1        .q      STRB     r1,[r0,#7]
;;;959    	fmc->X_FL_WD[2] = 0xff;
        0x000006b2:    7201        .r      STRB     r1,[r0,#8]
;;;960    	fmc->X_FL_WD[3] = 0xff;
        0x000006b4:    7241        Ar      STRB     r1,[r0,#9]
;;;961        fmc->X_FL_CTL = (0<<8) | (4<<0);
        0x000006b6:    2104        .!      MOVS     r1,#4
        0x000006b8:    6001        .`      STR      r1,[r0,#0]
;;;962        fmc->X_FL_X_MODE &= ~(1 << 18);
        0x000006ba:    68c1        .h      LDR      r1,[r0,#0xc]
        0x000006bc:    2201        ."      MOVS     r2,#1
        0x000006be:    0492        ..      LSLS     r2,r2,#18
        0x000006c0:    4391        .C      BICS     r1,r1,r2
        0x000006c2:    60c1        .`      STR      r1,[r0,#0xc]
;;;963    	fmc->X_FL_TRIG = 0X01;
        0x000006c4:    2101        .!      MOVS     r1,#1
        0x000006c6:    7101        .q      STRB     r1,[r0,#4]
;;;964    	while(fmc->X_FL_TRIG){};
        0x000006c8:    7901        .y      LDRB     r1,[r0,#4]
        0x000006ca:    2900        .)      CMP      r1,#0
        0x000006cc:    d1fc        ..      BNE      0x6c8 ; FMC_ExitEnhanceMode + 28
;;;965    }
        0x000006ce:    4770        pG      BX       lr
    i.FMC_ReadStatusReg
    FMC_ReadStatusReg
        0x000006d0:    22ff        ."      MOVS     r2,#0xff
        0x000006d2:    3202        .2      ADDS     r2,#2
        0x000006d4:    6002        .`      STR      r2,[r0,#0]
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c (74)
        0x000006d6:    7181        .q      STRB     r1,[r0,#6]
;;;75     	fmc->X_FL_TRIG = CMD_TRIG;
        0x000006d8:    2101        .!      MOVS     r1,#1
        0x000006da:    7101        .q      STRB     r1,[r0,#4]
;;;76     	while(fmc->X_FL_TRIG){};
        0x000006dc:    7901        .y      LDRB     r1,[r0,#4]
        0x000006de:    2900        .)      CMP      r1,#0
        0x000006e0:    d1fc        ..      BNE      0x6dc ; FMC_ReadStatusReg + 12
;;;77     
;;;78     	return FLCTL_BUFF->X_FL_BUFFER[0];
        0x000006e2:    4801        .H      LDR      r0,[pc,#4] ; [0x6e8] = 0x40050400
        0x000006e4:    7800        .x      LDRB     r0,[r0,#0]
;;;79     }
        0x000006e6:    4770        pG      BX       lr
    $d
        0x000006e8:    40050400    ...@    DCD    1074070528
    $t
    i.FMC_SetFlashMode
    FMC_SetFlashMode
;;;80     
;;;81     /**
;;;82       * @brief  This function is used to enable write function,
;;;83       * @param  fmc: where fmc is a flash peripheral.
;;;84       * @retval enable or not
;;;85       */
;;;86     unsigned char FMC_WriteEnable(FLCTL_T *fmc)
;;;87     {
;;;88     	fmc->X_FL_CTL = (0<<8) | (1<<0);
;;;89     	fmc->X_FL_WD[0] = CMD_WRITE_ENABLE;
;;;90     	fmc->X_FL_TRIG = CMD_TRIG;
;;;91     	while(fmc->X_FL_TRIG){};
;;;92     
;;;93         return 1;
;;;94     }
;;;95     /**
;;;96       * @brief  This is a internal function used to erase flash,
;;;97       * @param  fmc: where fmc is a flash peripheral.
;;;98       * @param  Addr: where addr is a erase start address.  
;;;99       * @param  cmd: where cmd can be CMD_ERASE_PAGE
;;;100    	*							  CMD_ERASE_SECTOR
;;;101    	*							  CMD_ERASE_32K
;;;102    	*							  CMD_ERASE_64K
;;;103    	*							  CMD_ERASE_CHIP
;;;104      * @retval 0: Success
;;;105      * @retval -1: Fail
;;;106      */
;;;107    static int FMC_Erase(FLCTL_T *fmc,unsigned int Addr,unsigned char cmd)
;;;108    {
;;;109    	unsigned char offset = 0;
;;;110    	unsigned char bytes_num_w;
;;;111    
;;;112    	FMC_WriteEnable(fmc);
;;;113    
;;;114    	if(cmd != CMD_ERASE_CHIP)
;;;115    	// - it's page/sector/block erase
;;;116    		bytes_num_w = 0x04;
;;;117    	else
;;;118    	// - it's chip erase
;;;119    		bytes_num_w = 0x01;
;;;120    			
;;;121    	fmc->X_FL_CTL = (0<<8) | (bytes_num_w<<0);
;;;122    	fmc->X_FL_WD[offset++] = cmd;
;;;123    
;;;124    	fmc->X_FL_WD[offset++] = (Addr & 0x00ff0000)>>16;
;;;125    	fmc->X_FL_WD[offset++] = (Addr & 0x0000ff00)>>8;
;;;126    	fmc->X_FL_WD[offset++] = Addr & 0xff;
;;;127    	fmc->X_FL_X_MODE |= (0x01<<Long_Time_Op_Pos);
;;;128    	fmc->X_FL_TRIG = CMD_TRIG;
;;;129    	while(fmc->X_FL_TRIG){}
;;;130    
;;;131    	while(FMC_ReadStatusReg(fmc,CMD_READ_STATUS_L) & Write_In_Process_Msk) {}
;;;132    	return 0;
;;;133    }
;;;134    
;;;135    /**
;;;136      * @brief Erase a 4KB Sector in Flash Memory.
;;;137      *
;;;138      * This function is used to erase a 4KB flash sector
;;;139      * in flash code area.
;;;140      *
;;;141      * @param fmc: where fmc is a flash peripheral.
;;;142      * @param adr: where addr is a erase start address.
;;;143      * @retval 0: Success.
;;;144      * @retval -1: Fail.
;;;145      */
;;;146    int FMC_EraseSector(FLCTL_T *fmc,unsigned long addr)
;;;147    {
;;;148        if (addr >= FMC_GetFlashCodeAreaSize(fmc)) {
;;;149            return -1;
;;;150        }
;;;151        return FMC_Erase(fmc,addr,CMD_ERASE_SECTOR);
;;;152    }
;;;153    
;;;154    /**
;;;155      * @brief Erase a 32KB Block in Flash Memory.
;;;156      *
;;;157      * This function is used to erase a 32KB flash block
;;;158      * in flash code area.
;;;159      *
;;;160      * @note The 1st 28KB flash block is not allowed to be erased
;;;161      * as the Info Area resides in this physical 32KB flash block.
;;;162      * @note The 32KB flash block start address is 0x7000, 0xF000,
;;;163      * 0x17000, 0x1F000, 0x27000, 0x2F000, ...
;;;164      *
;;;165      * @param fmc: where fmc is a flash peripheral.
;;;166      * @param adr: where addr is a erase start address.
;;;167      * @retval 0: Success.
;;;168      * @retval -1: Fail.
;;;169      */
;;;170    int FMC_EraseBlock32k(FLCTL_T *fmc,unsigned long addr)
;;;171    {
;;;172        if ((addr >= FMC_GetFlashCodeAreaSize(fmc))
;;;173            || (addr < 0x7000)) {
;;;174            return -1;
;;;175        }
;;;176        return FMC_Erase(fmc,addr,CMD_ERASE_32K);
;;;177    }
;;;178    
;;;179    /**
;;;180      * @brief Erase a 64KB Block in Flash Memory.
;;;181      *
;;;182      * This function is used to erase a 64KB flash block
;;;183      * in flash code area.
;;;184      *
;;;185      * @note The 1st 60KB flash block is not allowed to be erased
;;;186      * as the Info Area resides in this physical 64KB flash block.
;;;187      * @note The 64KB flash block start address is 0xF000, 0x1F000,
;;;188      * 0x2F000, 0x3F000, 0x4F000, 0x5F000, ...
;;;189      *
;;;190      * @param fmc: where fmc is a flash peripheral.
;;;191      * @param adr: where addr is a erase start address.
;;;192      * @retval 0: Success.
;;;193      * @retval -1: Fail.
;;;194      */
;;;195    int FMC_EraseBlock64k(FLCTL_T *fmc,unsigned long addr)
;;;196    {
;;;197        if ((addr >= FMC_GetFlashCodeAreaSize(fmc))
;;;198            || (addr < 0xF000)) {
;;;199            return -1;
;;;200        }
;;;201        return FMC_Erase(fmc,addr,CMD_ERASE_64K);
;;;202    }
;;;203    
;;;204    /**
;;;205      * @brief Erase the whole flash memory.
;;;206      *
;;;207      * This function is used to erase all data in flash, include
;;;208      * Code Area and Info Area.
;;;209      *
;;;210      * @note This API should only be used when you really know what
;;;211      * you are doing.
;;;212      *
;;;213      * @param fmc: where fmc is a flash peripheral.
;;;214      * @retval 0: Success.
;;;215      * @retval -1: Fail.
;;;216      */
;;;217    int FMC_EraseChip(FLCTL_T *fmc)
;;;218    {
;;;219        return FMC_Erase(fmc,0x0,CMD_ERASE_CHIP);
;;;220    }
;;;221    
;;;222    static void find_special_chunk_in_range(size_t chunk_pattern, uint32_t range_start_sector_idx, uint16_t range_sector_num,
;;;223                                            uint32_t *chunk_start_sector_idx, uint16_t *chunk_sector_num)
;;;224    {
;;;225        size_t remainder = range_start_sector_idx % chunk_pattern;
;;;226    
;;;227        for (size_t sector_idx = remainder ? (range_start_sector_idx - remainder + chunk_pattern) : range_start_sector_idx;
;;;228                sector_idx <= range_start_sector_idx + range_sector_num;
;;;229                sector_idx += chunk_pattern) {
;;;230            if (*chunk_start_sector_idx == 0) {
;;;231                *chunk_start_sector_idx = (sector_idx == 0) ? chunk_pattern : sector_idx;    //Found chunk start position (and should not be 1st block)
;;;232            } else {
;;;233                *chunk_sector_num += chunk_pattern; //Found multiple expected chunk
;;;234            }
;;;235        }
;;;236    }
;;;237    
;;;238    /**
;;;239      * @brief Erase specific data in flash code area.
;;;240      *
;;;241      * This function is used to erase specific data in flash Code
;;;242      * Area.
;;;243      *
;;;244      * @note This API is the most recommended function used to erase
;;;245      * data in flash code area.
;;;246      *
;;;247      * @param fmc: where fmc is a flash peripheral.
;;;248      * @param addr: start address to erase, should be 4KB aligned.
;;;249      * @param len: length to erase in bytes.
;;;250      * @retval 0: Success.
;;;251      * @retval -1: Fail.
;;;252      */
;;;253    int FMC_EraseCodeArea(FLCTL_T *fmc, uint32_t addr, uint32_t len)
;;;254    {
;;;255        uint32_t block_64k_start_sector_idx = 0;
;;;256        uint16_t block_64k_sector_num = 0;
;;;257        uint32_t block_32k_start_sector_idx = 0;
;;;258        uint16_t block_32k_sector_num = 0;
;;;259    
;;;260        uint32_t start_phy_sector_idx = addr / SECTOR_SIZE + 1;
;;;261        uint16_t sector_num = len / SECTOR_SIZE + (len % SECTOR_SIZE ? 1 : 0);
;;;262        uint16_t total_phy_sector_num = FMC_GetFlashCodeAreaSize(fmc) / SECTOR_SIZE + 1;
;;;263    
;;;264        // Check if erase start address and len are 4KB aligned and size not out of flash range
;;;265        if ((addr % SECTOR_SIZE != 0) || ((start_phy_sector_idx + sector_num) > total_phy_sector_num)) {
;;;266            return -1;
;;;267        }
;;;268    
;;;269        // Fine 32K blocks from the initial data chunk
;;;270        find_special_chunk_in_range(8, start_phy_sector_idx, sector_num, &block_32k_start_sector_idx, &block_32k_sector_num);
;;;271    
;;;272        if (block_32k_sector_num == 0) { // No 32k-block found
;;;273            // Do only sector erase
;;;274            for (size_t i = 0; i < sector_num; i++) {
;;;275                FMC_EraseSector(FLCTL, (start_phy_sector_idx + i - 1) * SECTOR_SIZE);
;;;276            }
;;;277        } else { // Found at least 1 32k-block
;;;278            // Do sector erase for leading sectors
;;;279            for (size_t i = 0; i < block_32k_start_sector_idx - start_phy_sector_idx; i++) {
;;;280                FMC_EraseSector(FLCTL, (start_phy_sector_idx + i - 1) * SECTOR_SIZE);
;;;281            }
;;;282            // Do sector erase for trailing sectors
;;;283            for (size_t i = 0; i < start_phy_sector_idx + sector_num - block_32k_start_sector_idx - block_32k_sector_num; i++) {
;;;284                FMC_EraseSector(FLCTL, (block_32k_start_sector_idx + block_32k_sector_num + i - 1) * SECTOR_SIZE);
;;;285            }
;;;286    
;;;287            // Find 64K blocks from the 32K-block chunk if there are
;;;288            find_special_chunk_in_range(16, block_32k_start_sector_idx, block_32k_sector_num, &block_64k_start_sector_idx, &block_64k_sector_num);
;;;289    
;;;290            if (block_64k_sector_num == 0) { // No 64k-block found
;;;291                // Do only block-32k erase
;;;292                for (size_t i = 0; i < block_32k_sector_num; i += 8) {
;;;293                    FMC_EraseBlock32k(FLCTL, (block_32k_start_sector_idx + i - 1) * SECTOR_SIZE);
;;;294                }
;;;295            } else { // Found at least 1 64k-block
;;;296                // Do block-32k erase for leading sectors if there are
;;;297                if (block_32k_start_sector_idx % 16 != 0) {
;;;298                    FMC_EraseBlock32k(FLCTL, (block_32k_start_sector_idx - 1) * SECTOR_SIZE);
;;;299                }
;;;300                // Do block-32k erase for trailing sectors if there are
;;;301                if ((block_32k_start_sector_idx + block_32k_sector_num) % 16 != 0) {
;;;302                    FMC_EraseBlock32k(FLCTL, (block_64k_start_sector_idx + block_64k_sector_num - 1) * SECTOR_SIZE);
;;;303                }
;;;304                // Do block_64k erase
;;;305                for (size_t i = 0; i < block_64k_sector_num; i += 16) {
;;;306                    FMC_EraseBlock64k(FLCTL, (block_64k_start_sector_idx + i - 1) * SECTOR_SIZE);
;;;307                }
;;;308            }
;;;309        }
;;;310    
;;;311        return 0;
;;;312    }
;;;313    
;;;314    /**
;;;315      * @brief  This function is used to write status,
;;;316      * The Read Status Register can be read at any time
;;;317      * @param  fmc: where fmc is a flash peripheral.
;;;318      * @param  ops: where ops can be OPS_WR_STU_REG_ALL
;;;319      *                               OPS_WR_STU_REG_NOR
;;;320      * @param  buf: where buf is write value
;;;321      * @retval none
;;;322      */
;;;323    void FMC_WriteStatusReg(FLCTL_T *fmc,unsigned char ops,unsigned int buf)
;;;324    {
;;;325    	unsigned char offset =0;
;;;326    	unsigned char bytes_num_w;
;;;327    
;;;328    	if(FMC_WriteEnable(fmc) == 0)
;;;329    		return;	
;;;330    
;;;331    	if(ops == OPS_WR_STU_REG_ALL)
;;;332    	// - write staus [15:0]
;;;333    		bytes_num_w = 0x03; 
;;;334    	else
;;;335    	// - write staus [ 7:0]
;;;336    		bytes_num_w = 0x02;
;;;337    
;;;338        fmc->X_FL_CONFIG &= ~BIT2;  //clear tx_address_transaction bit
;;;339    	
;;;340    	fmc->X_FL_CTL = (0<<8) | (bytes_num_w<<0);
;;;341    	fmc->X_FL_WD[offset++] = CMD_WRITE_STATUS;
;;;342    	fmc->X_FL_WD[offset++] = buf&0xff;
;;;343    	fmc->X_FL_WD[offset++] = (buf>>8)&0xff;
;;;344    	fmc->X_FL_X_MODE |= (0x01<<Long_Time_Op_Pos);
;;;345    	fmc->X_FL_TRIG = CMD_TRIG;
;;;346    	while(fmc->X_FL_TRIG){};
;;;347    
;;;348        fmc->X_FL_CONFIG |= BIT2;  //reset tx_address_transaction bit
;;;349    
;;;350    //	while(FMC_ReadStatusReg(fmc,CMD_READ_STATUS_L) & Write_In_Process_Msk);
;;;351    }
;;;352    /**
;;;353      * @brief  This function is used to read flash,
;;;354      * @param  fmc: where fmc is a flash peripheral.
;;;355    	* @param  Addr: where Addr is start address to read
;;;356    	* @param  cmd: where cmd can be CMD_FAST_READ or CMD_NOR_READ
;;;357      * @retval 4byte data
;;;358      */
;;;359    unsigned int FMC_ReadWord(FLCTL_T *fmc,unsigned int Addr, unsigned char cmd)
;;;360    {
;;;361    //	unsigned char offset =0;
;;;362    	unsigned char bytes_num_w;
;;;363    
;;;364    	if(cmd == CMD_FAST_READ || cmd == CMD_QREAD || cmd == CMD_2READ || cmd == CMD_DREAD)
;;;365    		bytes_num_w = 0x05; 
;;;366    	else if (cmd == CMD_4READ)
;;;367            bytes_num_w = 0x07;
;;;368        else if (cmd == CMD_NORM_READ)
;;;369    		bytes_num_w = 0x04;
;;;370        else
;;;371            bytes_num_w = 0x04;
;;;372    
;;;373        fmc->X_FL_CTL = (4<<8) | (bytes_num_w<<0);
;;;374    	fmc->X_FL_WD[0] = cmd;
;;;375    	fmc->X_FL_WD[1] = (Addr & 0x00ff0000)>>16;
;;;376    	fmc->X_FL_WD[2] = (Addr & 0x0000ff00)>>8;
;;;377    	fmc->X_FL_WD[3] = Addr & 0xff;
;;;378        fmc->X_FL_WD[4] = 0xff;
;;;379        fmc->X_FL_WD[5] = 0xff;
;;;380    	fmc->X_FL_TRIG = CMD_TRIG;
;;;381    	while(fmc->X_FL_TRIG){};
;;;382    	
;;;383    	return *((__I uint32_t*)FLCTL_BUFF->X_FL_BUFFER);
;;;384    }
;;;385    /**
;;;386      * @brief  This function is used to read flash,
;;;387      * @param  fmc: where fmc is a flash peripheral.
;;;388    	* @param  Addr: where Addr is start address to read
;;;389    	* @param  cmd: where cmd can be CMD_FAST_READ or CMD_NOR_READ
;;;390      * @retval 1byte data
;;;391      */
;;;392    unsigned char FMC_ReadByte(FLCTL_T *fmc,unsigned int Addr,unsigned char cmd)
;;;393    {
;;;394    	unsigned char bytes_num_w;
;;;395    
;;;396    	if(cmd == CMD_FAST_READ || cmd == CMD_QREAD || cmd == CMD_2READ || cmd == CMD_DREAD)
;;;397    		bytes_num_w = 0x05; 
;;;398    	else if (cmd == CMD_4READ)
;;;399            bytes_num_w = 0x07;
;;;400        else if (cmd == CMD_NORM_READ)
;;;401    		bytes_num_w = 0x04;
;;;402        else
;;;403    		bytes_num_w = 0x04;
;;;404    
;;;405    	fmc->X_FL_CTL = (1<<8) | (bytes_num_w<<0);
;;;406    	fmc->X_FL_WD[0] = cmd;
;;;407    	fmc->X_FL_WD[1] = (Addr & 0x00ff0000)>>16;
;;;408    	fmc->X_FL_WD[2] = (Addr & 0x0000ff00)>>8;
;;;409    	fmc->X_FL_WD[3] = Addr & 0xff;
;;;410        fmc->X_FL_WD[4] = 0xff;
;;;411        fmc->X_FL_WD[5] = 0xff;
;;;412    	
;;;413    	fmc->X_FL_TRIG = CMD_TRIG;
;;;414    	while(fmc->X_FL_TRIG){};
;;;415    
;;;416    	return FLCTL_BUFF->X_FL_BUFFER[0];
;;;417    	 
;;;418    }
;;;419    /**
;;;420      * @brief  This function is used to read a page size (256 bytes) of data from flash
;;;421      * @param  fmc     where fmc is a flash peripheral.
;;;422      * @param  Addr    where Addr is start address to read
;;;423      * @param  cmd     where cmd can be CMD_FAST_READ or CMD_NORM_READ
;;;424      * @retval Internal Buffer address
;;;425      */
;;;426    unsigned char *FMC_ReadPage(FLCTL_T *fmc,unsigned int Addr,unsigned char cmd)
;;;427    {
;;;428    	unsigned char bytes_num_w;
;;;429    
;;;430    	if(cmd == CMD_FAST_READ || cmd == CMD_QREAD || cmd == CMD_2READ || cmd == CMD_DREAD)
;;;431    		bytes_num_w = 0x05; 
;;;432    	else if (cmd == CMD_4READ)
;;;433            bytes_num_w = 0x07;
;;;434        else if (cmd == CMD_NORM_READ)
;;;435    		bytes_num_w = 0x04;
;;;436        else
;;;437            bytes_num_w = 0x04;
;;;438    
;;;439        fmc->X_FL_CTL = (256<<8) | (bytes_num_w<<0);
;;;440    	fmc->X_FL_WD[0] = cmd;
;;;441    	fmc->X_FL_WD[1] = (Addr & 0x00ff0000)>>16;
;;;442    	fmc->X_FL_WD[2] = (Addr & 0x0000ff00)>>8;
;;;443    	fmc->X_FL_WD[3] = Addr & 0xff;
;;;444        fmc->X_FL_WD[4] = 0xff;
;;;445        fmc->X_FL_WD[5] = 0xff;
;;;446    	
;;;447    	fmc->X_FL_TRIG = CMD_TRIG;
;;;448    	while(fmc->X_FL_TRIG){};
;;;449    
;;;450    	return (unsigned char *)&(FLCTL_BUFF->X_FL_BUFFER[0]);
;;;451    }
;;;452    
;;;453    /**
;;;454      * Read small data (less than 256 bytes) from flash (for internal use).
;;;455      */
;;;456    static unsigned char *FMC_ReadInternal(FLCTL_T *fmc,unsigned int Addr,unsigned char cmd, unsigned int len)
;;;457    {
;;;458    	unsigned char bytes_num_w;
;;;459    
;;;460    	if(cmd == CMD_FAST_READ || cmd == CMD_QREAD || cmd == CMD_2READ || cmd == CMD_DREAD)
;;;461    		bytes_num_w = 0x05; 
;;;462    	else if (cmd == CMD_4READ)
;;;463            bytes_num_w = 0x07;
;;;464        else if (cmd == CMD_NORM_READ)
;;;465    		bytes_num_w = 0x04;
;;;466        else
;;;467            bytes_num_w = 0x04;
;;;468    
;;;469        fmc->X_FL_CTL = (len<<8) | (bytes_num_w<<0);
;;;470    	fmc->X_FL_WD[0] = cmd;
;;;471    	fmc->X_FL_WD[1] = (Addr & 0x00ff0000)>>16;
;;;472    	fmc->X_FL_WD[2] = (Addr & 0x0000ff00)>>8;
;;;473    	fmc->X_FL_WD[3] = Addr & 0xff;
;;;474        fmc->X_FL_WD[4] = 0xff;
;;;475        fmc->X_FL_WD[5] = 0xff;
;;;476    	fmc->X_FL_TRIG = CMD_TRIG;
;;;477    	while(fmc->X_FL_TRIG){};
;;;478    
;;;479    	return (unsigned char *)&(FLCTL_BUFF->X_FL_BUFFER[0]);
;;;480    }
;;;481    
;;;482    /**
;;;483      * @brief  This function is used to read data stream from flash
;;;484      * @param  fmc     where fmc is a flash peripheral.
;;;485      * @param  Addr    where Addr is start address to read
;;;486      * @param  cmd     where cmd can be CMD_FAST_READ or CMD_NORM_READ
;;;487      * @param  buf     where buf is a buffer to store read data
;;;488      * @param  len     where len is data length of bytes to read
;;;489      * @retval None
;;;490      */
;;;491    int FMC_ReadStream(FLCTL_T *fmc, unsigned int Addr, unsigned char cmd, unsigned char *buf, unsigned int len)
;;;492    {
;;;493        unsigned int tmp_addr = Addr;
;;;494        unsigned int tmp_size = len;
;;;495        unsigned int code_area_size = FMC_GetFlashCodeAreaSize(fmc);
;;;496        
;;;497        if ((Addr >= code_area_size) || (Addr + len > code_area_size))
;;;498        {
;;;499            return -1;
;;;500        }
;;;501    
;;;502        while (tmp_size >= 256)
;;;503        {
;;;504            memcpy(&buf[tmp_addr - Addr], FMC_ReadPage(fmc, tmp_addr, cmd), 256);
;;;505            tmp_addr += 256;
;;;506            tmp_size -= 256;
;;;507        }
;;;508    
;;;509        if (tmp_size)
;;;510        {
;;;511            memcpy(&buf[tmp_addr - Addr], FMC_ReadInternal(fmc, tmp_addr, cmd, tmp_size), tmp_size);
;;;512        }
;;;513    
;;;514        return 0;
;;;515    }
;;;516    /**
;;;517      * @brief  This function is used to write data to buffer,
;;;518      * @param  fmc_w_buff: where fmc_w_buff is a cache to store write data.
;;;519    	* @param  size: where size is write data size
;;;520    	* @param  pData: write data
;;;521      * @retval none
;;;522      */
;;;523    static inline uint32_t FMC_PrepBuf(unsigned int size,unsigned char *pData)
;;;524    {
;;;525    	uint32_t i;
;;;526        uint32_t len = size > 256 ? 256 : size;
;;;527    	for(i = 0; i < len; i++)
;;;528    	{
;;;529    		FLCTL_BUFF->X_FL_BUFFER[i] = *pData;
;;;530    		pData ++;
;;;531    	}
;;;532        while(i < 256){
;;;533            FLCTL_BUFF->X_FL_BUFFER[i] = 0xFF;
;;;534            i++;
;;;535        }
;;;536        return len;
;;;537    }
;;;538    
;;;539    void FMC_SetFlashMode(FLCTL_T *fmc, uint32_t mode, bool enhance)
;;;540    {
        0x000006ec:    b570        p.      PUSH     {r4-r6,lr}
        0x000006ee:    4615        .F      MOV      r5,r2
        0x000006f0:    460b        .F      MOV      r3,r1
        0x000006f2:    4604        .F      MOV      r4,r0
;;;541        FMC_ExitEnhanceMode(fmc);
        0x000006f4:    f7ffffda    ....    BL       FMC_ExitEnhanceMode ; 0x6ac
;;;542    
;;;543        if (mode == FLASH_X1_MODE)
        0x000006f8:    2b00        .+      CMP      r3,#0
        0x000006fa:    d004        ..      BEQ      0x706 ; FMC_SetFlashMode + 26
        0x000006fc:    2b01        .+      CMP      r3,#1
        0x000006fe:    d007        ..      BEQ      0x710 ; FMC_SetFlashMode + 36
        0x00000700:    2b02        .+      CMP      r3,#2
        0x00000702:    d00e        ..      BEQ      0x722 ; FMC_SetFlashMode + 54
        0x00000704:    e043        C.      B        0x78e ; FMC_SetFlashMode + 162
;;;544        {
;;;545            // set cpu to x1_mode
;;;546            fmc->X_FL_X_MODE = (fmc->X_FL_X_MODE & ~0x3);
        0x00000706:    68e0        .h      LDR      r0,[r4,#0xc]
        0x00000708:    0880        ..      LSRS     r0,r0,#2
        0x0000070a:    0080        ..      LSLS     r0,r0,#2
        0x0000070c:    60e0        .`      STR      r0,[r4,#0xc]
        0x0000070e:    e03e        >.      B        0x78e ; FMC_SetFlashMode + 162
;;;547        }
;;;548        else if (mode == FLASH_X2_MODE)
;;;549        {
;;;550            // set cpu to x2_mode
;;;551            fmc->X_FL_X_MODE = ((fmc->X_FL_X_MODE & ~0x3) | FLASH_X2_MODE);
        0x00000710:    68e0        .h      LDR      r0,[r4,#0xc]
        0x00000712:    0880        ..      LSRS     r0,r0,#2
        0x00000714:    0080        ..      LSLS     r0,r0,#2
        0x00000716:    1c40        @.      ADDS     r0,r0,#1
        0x00000718:    60e0        .`      STR      r0,[r4,#0xc]
;;;552    
;;;553            if (enhance)
        0x0000071a:    2d00        .-      CMP      r5,#0
        0x0000071c:    d037        7.      BEQ      0x78e ; FMC_SetFlashMode + 162
;;;554            {
;;;555                FMC_EnterEnhanceMode(fmc, FLASH_X2_MODE);
        0x0000071e:    2101        .!      MOVS     r1,#1
        0x00000720:    e032        2.      B        0x788 ; FMC_SetFlashMode + 156
;;;556            }
;;;557        }
;;;558        else if (mode == FLASH_X4_MODE)
;;;559        {
;;;560            uint16_t status;
;;;561            // Ensure QE bit is set
;;;562            status = FMC_ReadStatusReg(fmc, CMD_READ_STATUS_H);
        0x00000722:    2135        5!      MOVS     r1,#0x35
        0x00000724:    4620         F      MOV      r0,r4
        0x00000726:    f7ffffd3    ....    BL       FMC_ReadStatusReg ; 0x6d0
        0x0000072a:    2601        .&      MOVS     r6,#1
        0x0000072c:    4603        .F      MOV      r3,r0
        0x0000072e:    0276        v.      LSLS     r6,r6,#9
;;;563            while ((status&0x02) != 0x02)
        0x00000730:    e010        ..      B        0x754 ; FMC_SetFlashMode + 104
;;;564            {
;;;565                status = (status << 8) | FMC_ReadStatusReg(fmc, CMD_READ_STATUS_L) | QUAD_ENABLE_Msk;
        0x00000732:    2105        .!      MOVS     r1,#5
        0x00000734:    4620         F      MOV      r0,r4
        0x00000736:    f7ffffcb    ....    BL       FMC_ReadStatusReg ; 0x6d0
        0x0000073a:    0219        ..      LSLS     r1,r3,#8
        0x0000073c:    4308        .C      ORRS     r0,r0,r1
        0x0000073e:    4330        0C      ORRS     r0,r0,r6
        0x00000740:    4602        .F      MOV      r2,r0
;;;566                FMC_WriteStatusReg(fmc, OPS_WR_STU_REG_ALL, status);
        0x00000742:    2101        .!      MOVS     r1,#1
        0x00000744:    4620         F      MOV      r0,r4
        0x00000746:    f000f831    ..1.    BL       FMC_WriteStatusReg ; 0x7ac
;;;567                status = FMC_ReadStatusReg(fmc, CMD_READ_STATUS_H);
        0x0000074a:    2135        5!      MOVS     r1,#0x35
        0x0000074c:    4620         F      MOV      r0,r4
        0x0000074e:    f7ffffbf    ....    BL       FMC_ReadStatusReg ; 0x6d0
        0x00000752:    4603        .F      MOV      r3,r0
        0x00000754:    0798        ..      LSLS     r0,r3,#30
        0x00000756:    d5ec        ..      BPL      0x732 ; FMC_SetFlashMode + 70
;;;568            }
;;;569    
;;;570            // set cpu to x4_mode
;;;571            fmc->X_FL_X_MODE = ((fmc->X_FL_X_MODE & ~0x3) | FLASH_X4_MODE);
        0x00000758:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0000075a:    0880        ..      LSRS     r0,r0,#2
        0x0000075c:    0080        ..      LSLS     r0,r0,#2
        0x0000075e:    1c80        ..      ADDS     r0,r0,#2
        0x00000760:    60e0        .`      STR      r0,[r4,#0xc]
;;;572    
;;;573            // en_burst_wrap
;;;574            fmc->X_FL_X_MODE |= (0x1 << 16);  // 32bit reg
        0x00000762:    68e0        .h      LDR      r0,[r4,#0xc]
        0x00000764:    2101        .!      MOVS     r1,#1
        0x00000766:    0409        ..      LSLS     r1,r1,#16
        0x00000768:    4308        .C      ORRS     r0,r0,r1
        0x0000076a:    60e0        .`      STR      r0,[r4,#0xc]
;;;575    
;;;576            // issue burst_wrap command to spi flash
;;;577            fmc->X_FL_CTL = (0<<8) | (0x05<<0);
        0x0000076c:    2005        .       MOVS     r0,#5
        0x0000076e:    6020         `      STR      r0,[r4,#0]
;;;578            fmc->X_FL_WD[0] = CMD_BURST_READ;
        0x00000770:    2077        w       MOVS     r0,#0x77
        0x00000772:    71a0        .q      STRB     r0,[r4,#6]
;;;579            fmc->X_FL_WD[4] = BURST_READ_MODE_32<<5;
        0x00000774:    2040        @       MOVS     r0,#0x40
        0x00000776:    72a0        .r      STRB     r0,[r4,#0xa]
;;;580            fmc->X_FL_TRIG = CMD_TRIG;
        0x00000778:    2001        .       MOVS     r0,#1
        0x0000077a:    7120         q      STRB     r0,[r4,#4]
;;;581            while(fmc->X_FL_TRIG){};
        0x0000077c:    7920         y      LDRB     r0,[r4,#4]
        0x0000077e:    2800        .(      CMP      r0,#0
        0x00000780:    d1fc        ..      BNE      0x77c ; FMC_SetFlashMode + 144
;;;582    
;;;583            if (enhance)
        0x00000782:    2d00        .-      CMP      r5,#0
        0x00000784:    d003        ..      BEQ      0x78e ; FMC_SetFlashMode + 162
;;;584            {
;;;585                FMC_EnterEnhanceMode(fmc, FLASH_X4_MODE);
        0x00000786:    2102        .!      MOVS     r1,#2
        0x00000788:    4620         F      MOV      r0,r4
        0x0000078a:    f7ffff73    ..s.    BL       FMC_EnterEnhanceMode ; 0x674
        0x0000078e:    69a0        .i      LDR      r0,[r4,#0x18]
        0x00000790:    0840        @.      LSRS     r0,r0,#1
        0x00000792:    0040        @.      LSLS     r0,r0,#1
        0x00000794:    61a0        .a      STR      r0,[r4,#0x18]
;;;586            }
;;;587        }
;;;588    
;;;589        /* Disable FMC Auto DP to ensure sleep mode works properly */
;;;590        FMC_DisableAutoDp(fmc);
;;;591    }
        0x00000796:    bd70        p.      POP      {r4-r6,pc}
    i.FMC_WriteEnable
    FMC_WriteEnable
        0x00000798:    2101        .!      MOVS     r1,#1
        0x0000079a:    6001        .`      STR      r1,[r0,#0]
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c (89)
        0x0000079c:    2206        ."      MOVS     r2,#6
        0x0000079e:    7182        .q      STRB     r2,[r0,#6]
;;;90     	fmc->X_FL_TRIG = CMD_TRIG;
        0x000007a0:    7101        .q      STRB     r1,[r0,#4]
;;;91     	while(fmc->X_FL_TRIG){};
        0x000007a2:    7901        .y      LDRB     r1,[r0,#4]
        0x000007a4:    2900        .)      CMP      r1,#0
        0x000007a6:    d1fc        ..      BNE      0x7a2 ; FMC_WriteEnable + 10
;;;92     
;;;93         return 1;
        0x000007a8:    2001        .       MOVS     r0,#1
;;;94     }
        0x000007aa:    4770        pG      BX       lr
    i.FMC_WriteStatusReg
    FMC_WriteStatusReg
;;;95     /**
;;;96       * @brief  This is a internal function used to erase flash,
;;;97       * @param  fmc: where fmc is a flash peripheral.
;;;98       * @param  Addr: where addr is a erase start address.  
;;;99       * @param  cmd: where cmd can be CMD_ERASE_PAGE
;;;100    	*							  CMD_ERASE_SECTOR
;;;101    	*							  CMD_ERASE_32K
;;;102    	*							  CMD_ERASE_64K
;;;103    	*							  CMD_ERASE_CHIP
;;;104      * @retval 0: Success
;;;105      * @retval -1: Fail
;;;106      */
;;;107    static int FMC_Erase(FLCTL_T *fmc,unsigned int Addr,unsigned char cmd)
;;;108    {
;;;109    	unsigned char offset = 0;
;;;110    	unsigned char bytes_num_w;
;;;111    
;;;112    	FMC_WriteEnable(fmc);
;;;113    
;;;114    	if(cmd != CMD_ERASE_CHIP)
;;;115    	// - it's page/sector/block erase
;;;116    		bytes_num_w = 0x04;
;;;117    	else
;;;118    	// - it's chip erase
;;;119    		bytes_num_w = 0x01;
;;;120    			
;;;121    	fmc->X_FL_CTL = (0<<8) | (bytes_num_w<<0);
;;;122    	fmc->X_FL_WD[offset++] = cmd;
;;;123    
;;;124    	fmc->X_FL_WD[offset++] = (Addr & 0x00ff0000)>>16;
;;;125    	fmc->X_FL_WD[offset++] = (Addr & 0x0000ff00)>>8;
;;;126    	fmc->X_FL_WD[offset++] = Addr & 0xff;
;;;127    	fmc->X_FL_X_MODE |= (0x01<<Long_Time_Op_Pos);
;;;128    	fmc->X_FL_TRIG = CMD_TRIG;
;;;129    	while(fmc->X_FL_TRIG){}
;;;130    
;;;131    	while(FMC_ReadStatusReg(fmc,CMD_READ_STATUS_L) & Write_In_Process_Msk) {}
;;;132    	return 0;
;;;133    }
;;;134    
;;;135    /**
;;;136      * @brief Erase a 4KB Sector in Flash Memory.
;;;137      *
;;;138      * This function is used to erase a 4KB flash sector
;;;139      * in flash code area.
;;;140      *
;;;141      * @param fmc: where fmc is a flash peripheral.
;;;142      * @param adr: where addr is a erase start address.
;;;143      * @retval 0: Success.
;;;144      * @retval -1: Fail.
;;;145      */
;;;146    int FMC_EraseSector(FLCTL_T *fmc,unsigned long addr)
;;;147    {
;;;148        if (addr >= FMC_GetFlashCodeAreaSize(fmc)) {
;;;149            return -1;
;;;150        }
;;;151        return FMC_Erase(fmc,addr,CMD_ERASE_SECTOR);
;;;152    }
;;;153    
;;;154    /**
;;;155      * @brief Erase a 32KB Block in Flash Memory.
;;;156      *
;;;157      * This function is used to erase a 32KB flash block
;;;158      * in flash code area.
;;;159      *
;;;160      * @note The 1st 28KB flash block is not allowed to be erased
;;;161      * as the Info Area resides in this physical 32KB flash block.
;;;162      * @note The 32KB flash block start address is 0x7000, 0xF000,
;;;163      * 0x17000, 0x1F000, 0x27000, 0x2F000, ...
;;;164      *
;;;165      * @param fmc: where fmc is a flash peripheral.
;;;166      * @param adr: where addr is a erase start address.
;;;167      * @retval 0: Success.
;;;168      * @retval -1: Fail.
;;;169      */
;;;170    int FMC_EraseBlock32k(FLCTL_T *fmc,unsigned long addr)
;;;171    {
;;;172        if ((addr >= FMC_GetFlashCodeAreaSize(fmc))
;;;173            || (addr < 0x7000)) {
;;;174            return -1;
;;;175        }
;;;176        return FMC_Erase(fmc,addr,CMD_ERASE_32K);
;;;177    }
;;;178    
;;;179    /**
;;;180      * @brief Erase a 64KB Block in Flash Memory.
;;;181      *
;;;182      * This function is used to erase a 64KB flash block
;;;183      * in flash code area.
;;;184      *
;;;185      * @note The 1st 60KB flash block is not allowed to be erased
;;;186      * as the Info Area resides in this physical 64KB flash block.
;;;187      * @note The 64KB flash block start address is 0xF000, 0x1F000,
;;;188      * 0x2F000, 0x3F000, 0x4F000, 0x5F000, ...
;;;189      *
;;;190      * @param fmc: where fmc is a flash peripheral.
;;;191      * @param adr: where addr is a erase start address.
;;;192      * @retval 0: Success.
;;;193      * @retval -1: Fail.
;;;194      */
;;;195    int FMC_EraseBlock64k(FLCTL_T *fmc,unsigned long addr)
;;;196    {
;;;197        if ((addr >= FMC_GetFlashCodeAreaSize(fmc))
;;;198            || (addr < 0xF000)) {
;;;199            return -1;
;;;200        }
;;;201        return FMC_Erase(fmc,addr,CMD_ERASE_64K);
;;;202    }
;;;203    
;;;204    /**
;;;205      * @brief Erase the whole flash memory.
;;;206      *
;;;207      * This function is used to erase all data in flash, include
;;;208      * Code Area and Info Area.
;;;209      *
;;;210      * @note This API should only be used when you really know what
;;;211      * you are doing.
;;;212      *
;;;213      * @param fmc: where fmc is a flash peripheral.
;;;214      * @retval 0: Success.
;;;215      * @retval -1: Fail.
;;;216      */
;;;217    int FMC_EraseChip(FLCTL_T *fmc)
;;;218    {
;;;219        return FMC_Erase(fmc,0x0,CMD_ERASE_CHIP);
;;;220    }
;;;221    
;;;222    static void find_special_chunk_in_range(size_t chunk_pattern, uint32_t range_start_sector_idx, uint16_t range_sector_num,
;;;223                                            uint32_t *chunk_start_sector_idx, uint16_t *chunk_sector_num)
;;;224    {
;;;225        size_t remainder = range_start_sector_idx % chunk_pattern;
;;;226    
;;;227        for (size_t sector_idx = remainder ? (range_start_sector_idx - remainder + chunk_pattern) : range_start_sector_idx;
;;;228                sector_idx <= range_start_sector_idx + range_sector_num;
;;;229                sector_idx += chunk_pattern) {
;;;230            if (*chunk_start_sector_idx == 0) {
;;;231                *chunk_start_sector_idx = (sector_idx == 0) ? chunk_pattern : sector_idx;    //Found chunk start position (and should not be 1st block)
;;;232            } else {
;;;233                *chunk_sector_num += chunk_pattern; //Found multiple expected chunk
;;;234            }
;;;235        }
;;;236    }
;;;237    
;;;238    /**
;;;239      * @brief Erase specific data in flash code area.
;;;240      *
;;;241      * This function is used to erase specific data in flash Code
;;;242      * Area.
;;;243      *
;;;244      * @note This API is the most recommended function used to erase
;;;245      * data in flash code area.
;;;246      *
;;;247      * @param fmc: where fmc is a flash peripheral.
;;;248      * @param addr: start address to erase, should be 4KB aligned.
;;;249      * @param len: length to erase in bytes.
;;;250      * @retval 0: Success.
;;;251      * @retval -1: Fail.
;;;252      */
;;;253    int FMC_EraseCodeArea(FLCTL_T *fmc, uint32_t addr, uint32_t len)
;;;254    {
;;;255        uint32_t block_64k_start_sector_idx = 0;
;;;256        uint16_t block_64k_sector_num = 0;
;;;257        uint32_t block_32k_start_sector_idx = 0;
;;;258        uint16_t block_32k_sector_num = 0;
;;;259    
;;;260        uint32_t start_phy_sector_idx = addr / SECTOR_SIZE + 1;
;;;261        uint16_t sector_num = len / SECTOR_SIZE + (len % SECTOR_SIZE ? 1 : 0);
;;;262        uint16_t total_phy_sector_num = FMC_GetFlashCodeAreaSize(fmc) / SECTOR_SIZE + 1;
;;;263    
;;;264        // Check if erase start address and len are 4KB aligned and size not out of flash range
;;;265        if ((addr % SECTOR_SIZE != 0) || ((start_phy_sector_idx + sector_num) > total_phy_sector_num)) {
;;;266            return -1;
;;;267        }
;;;268    
;;;269        // Fine 32K blocks from the initial data chunk
;;;270        find_special_chunk_in_range(8, start_phy_sector_idx, sector_num, &block_32k_start_sector_idx, &block_32k_sector_num);
;;;271    
;;;272        if (block_32k_sector_num == 0) { // No 32k-block found
;;;273            // Do only sector erase
;;;274            for (size_t i = 0; i < sector_num; i++) {
;;;275                FMC_EraseSector(FLCTL, (start_phy_sector_idx + i - 1) * SECTOR_SIZE);
;;;276            }
;;;277        } else { // Found at least 1 32k-block
;;;278            // Do sector erase for leading sectors
;;;279            for (size_t i = 0; i < block_32k_start_sector_idx - start_phy_sector_idx; i++) {
;;;280                FMC_EraseSector(FLCTL, (start_phy_sector_idx + i - 1) * SECTOR_SIZE);
;;;281            }
;;;282            // Do sector erase for trailing sectors
;;;283            for (size_t i = 0; i < start_phy_sector_idx + sector_num - block_32k_start_sector_idx - block_32k_sector_num; i++) {
;;;284                FMC_EraseSector(FLCTL, (block_32k_start_sector_idx + block_32k_sector_num + i - 1) * SECTOR_SIZE);
;;;285            }
;;;286    
;;;287            // Find 64K blocks from the 32K-block chunk if there are
;;;288            find_special_chunk_in_range(16, block_32k_start_sector_idx, block_32k_sector_num, &block_64k_start_sector_idx, &block_64k_sector_num);
;;;289    
;;;290            if (block_64k_sector_num == 0) { // No 64k-block found
;;;291                // Do only block-32k erase
;;;292                for (size_t i = 0; i < block_32k_sector_num; i += 8) {
;;;293                    FMC_EraseBlock32k(FLCTL, (block_32k_start_sector_idx + i - 1) * SECTOR_SIZE);
;;;294                }
;;;295            } else { // Found at least 1 64k-block
;;;296                // Do block-32k erase for leading sectors if there are
;;;297                if (block_32k_start_sector_idx % 16 != 0) {
;;;298                    FMC_EraseBlock32k(FLCTL, (block_32k_start_sector_idx - 1) * SECTOR_SIZE);
;;;299                }
;;;300                // Do block-32k erase for trailing sectors if there are
;;;301                if ((block_32k_start_sector_idx + block_32k_sector_num) % 16 != 0) {
;;;302                    FMC_EraseBlock32k(FLCTL, (block_64k_start_sector_idx + block_64k_sector_num - 1) * SECTOR_SIZE);
;;;303                }
;;;304                // Do block_64k erase
;;;305                for (size_t i = 0; i < block_64k_sector_num; i += 16) {
;;;306                    FMC_EraseBlock64k(FLCTL, (block_64k_start_sector_idx + i - 1) * SECTOR_SIZE);
;;;307                }
;;;308            }
;;;309        }
;;;310    
;;;311        return 0;
;;;312    }
;;;313    
;;;314    /**
;;;315      * @brief  This function is used to write status,
;;;316      * The Read Status Register can be read at any time
;;;317      * @param  fmc: where fmc is a flash peripheral.
;;;318      * @param  ops: where ops can be OPS_WR_STU_REG_ALL
;;;319      *                               OPS_WR_STU_REG_NOR
;;;320      * @param  buf: where buf is write value
;;;321      * @retval none
;;;322      */
;;;323    void FMC_WriteStatusReg(FLCTL_T *fmc,unsigned char ops,unsigned int buf)
;;;324    {
        0x000007ac:    b530        0.      PUSH     {r4,r5,lr}
        0x000007ae:    4614        .F      MOV      r4,r2
        0x000007b0:    460d        .F      MOV      r5,r1
        0x000007b2:    4603        .F      MOV      r3,r0
;;;325    	unsigned char offset =0;
;;;326    	unsigned char bytes_num_w;
;;;327    
;;;328    	if(FMC_WriteEnable(fmc) == 0)
        0x000007b4:    f7fffff0    ....    BL       FMC_WriteEnable ; 0x798
        0x000007b8:    2800        .(      CMP      r0,#0
        0x000007ba:    d018        ..      BEQ      0x7ee ; FMC_WriteStatusReg + 66
;;;329    		return;	
;;;330    
;;;331    	if(ops == OPS_WR_STU_REG_ALL)
        0x000007bc:    2d01        .-      CMP      r5,#1
        0x000007be:    d017        ..      BEQ      0x7f0 ; FMC_WriteStatusReg + 68
;;;332    	// - write staus [15:0]
;;;333    		bytes_num_w = 0x03; 
;;;334    	else
;;;335    	// - write staus [ 7:0]
;;;336    		bytes_num_w = 0x02;
        0x000007c0:    2002        .       MOVS     r0,#2
;;;337    
;;;338        fmc->X_FL_CONFIG &= ~BIT2;  //clear tx_address_transaction bit
        0x000007c2:    7959        Yy      LDRB     r1,[r3,#5]
        0x000007c4:    22fb        ."      MOVS     r2,#0xfb
        0x000007c6:    4011        .@      ANDS     r1,r1,r2
        0x000007c8:    7159        Yq      STRB     r1,[r3,#5]
;;;339    	
;;;340    	fmc->X_FL_CTL = (0<<8) | (bytes_num_w<<0);
        0x000007ca:    6018        .`      STR      r0,[r3,#0]
;;;341    	fmc->X_FL_WD[offset++] = CMD_WRITE_STATUS;
        0x000007cc:    2001        .       MOVS     r0,#1
        0x000007ce:    7198        .q      STRB     r0,[r3,#6]
;;;342    	fmc->X_FL_WD[offset++] = buf&0xff;
        0x000007d0:    71dc        .q      STRB     r4,[r3,#7]
;;;343    	fmc->X_FL_WD[offset++] = (buf>>8)&0xff;
        0x000007d2:    0a21        !.      LSRS     r1,r4,#8
        0x000007d4:    7219        .r      STRB     r1,[r3,#8]
;;;344    	fmc->X_FL_X_MODE |= (0x01<<Long_Time_Op_Pos);
        0x000007d6:    68d9        .h      LDR      r1,[r3,#0xc]
        0x000007d8:    0442        B.      LSLS     r2,r0,#17
        0x000007da:    4311        .C      ORRS     r1,r1,r2
        0x000007dc:    60d9        .`      STR      r1,[r3,#0xc]
;;;345    	fmc->X_FL_TRIG = CMD_TRIG;
        0x000007de:    7118        .q      STRB     r0,[r3,#4]
;;;346    	while(fmc->X_FL_TRIG){};
        0x000007e0:    7918        .y      LDRB     r0,[r3,#4]
        0x000007e2:    2800        .(      CMP      r0,#0
        0x000007e4:    d1fc        ..      BNE      0x7e0 ; FMC_WriteStatusReg + 52
;;;347    
;;;348        fmc->X_FL_CONFIG |= BIT2;  //reset tx_address_transaction bit
        0x000007e6:    7958        Xy      LDRB     r0,[r3,#5]
        0x000007e8:    2104        .!      MOVS     r1,#4
        0x000007ea:    4308        .C      ORRS     r0,r0,r1
        0x000007ec:    7158        Xq      STRB     r0,[r3,#5]
;;;349    
;;;350    //	while(FMC_ReadStatusReg(fmc,CMD_READ_STATUS_L) & Write_In_Process_Msk);
;;;351    }
        0x000007ee:    bd30        0.      POP      {r4,r5,pc}
        0x000007f0:    2003        .       MOVS     r0,#3
        0x000007f2:    e7e6        ..      B        0x7c2 ; FMC_WriteStatusReg + 22
    i.Factory_Read
    Factory_Read
;;; ..\..\..\..\radio\pan216.c
;;;5      {
        0x000007f4:    b510        ..      PUSH     {r4,lr}
        0x000007f6:    4604        .F      MOV      r4,r0
;;;6          uint8_t val;
;;;7          PAN216_SetPage(1);
        0x000007f8:    2001        .       MOVS     r0,#1
        0x000007fa:    f000fc41    ..A.    BL       PAN216_SetPage ; 0x1080
;;;8          PAN216_WriteRegUnchecked(0x04, addr << 1);
        0x000007fe:    0660        `.      LSLS     r0,r4,#25
        0x00000800:    0e01        ..      LSRS     r1,r0,#24
        0x00000802:    2004        .       MOVS     r0,#4
        0x00000804:    f000fe92    ....    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;9          val = PAN216_ReadReg(0x04);
        0x00000808:    2004        .       MOVS     r0,#4
        0x0000080a:    f000fafe    ....    BL       PAN216_ReadReg ; 0xe0a
        0x0000080e:    4604        .F      MOV      r4,r0
;;;10         PAN216_SetPage(0);
        0x00000810:    2000        .       MOVS     r0,#0
        0x00000812:    f000fc35    ..5.    BL       PAN216_SetPage ; 0x1080
;;;11         Pan216_Funs.delayus(100);
        0x00000816:    4805        .H      LDR      r0,[pc,#20] ; [0x82c] = 0x2000000c
        0x00000818:    6901        .i      LDR      r1,[r0,#0x10]
        0x0000081a:    2064        d       MOVS     r0,#0x64
        0x0000081c:    4788        .G      BLX      r1
;;;12         PAN216_WriteRegUnchecked(0x73, 0x01);
        0x0000081e:    2101        .!      MOVS     r1,#1
        0x00000820:    2073        s       MOVS     r0,#0x73
        0x00000822:    f000fe83    ....    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;13     
;;;14         return val;
        0x00000826:    4620         F      MOV      r0,r4
;;;15     }
        0x00000828:    bd10        ..      POP      {r4,pc}
    $d
        0x0000082a:    0000        ..      DCW    0
        0x0000082c:    2000000c    ...     DCD    536870924
    $t
    i.GPIO_SetMode
    GPIO_SetMode
;;; .\..\..\..\..\pan108\peripheral\src\pan_gpio.c
;;;44     {
        0x00000830:    b5f0        ..      PUSH     {r4-r7,lr}
;;;45         uint32_t i;
;;;46     
;;;47         for (i=0; i<GPIO_PIN_MAX; i++) {
        0x00000832:    2300        .#      MOVS     r3,#0
        0x00000834:    2401        .$      MOVS     r4,#1
        0x00000836:    4625        %F      MOV      r5,r4
        0x00000838:    409d        .@      LSLS     r5,r5,r3
        0x0000083a:    420d        .B      TST      r5,r1
        0x0000083c:    d008        ..      BEQ      0x850 ; GPIO_SetMode + 32
        0x0000083e:    6806        .h      LDR      r6,[r0,#0]
        0x00000840:    005d        ].      LSLS     r5,r3,#1
        0x00000842:    2703        .'      MOVS     r7,#3
        0x00000844:    40af        .@      LSLS     r7,r7,r5
        0x00000846:    43be        .C      BICS     r6,r6,r7
        0x00000848:    4617        .F      MOV      r7,r2
        0x0000084a:    40af        .@      LSLS     r7,r7,r5
        0x0000084c:    433e        >C      ORRS     r6,r6,r7
        0x0000084e:    6006        .`      STR      r6,[r0,#0]
        0x00000850:    1c5b        [.      ADDS     r3,r3,#1
        0x00000852:    2b08        .+      CMP      r3,#8
        0x00000854:    d3ef        ..      BCC      0x836 ; GPIO_SetMode + 6
;;;48             if (u32PinMask & (1 << i)) {
;;;49                 gpio->MODE = (gpio->MODE & ~(0x3 << (i << 1))) | (Mode << (i << 1));
;;;50             }
;;;51         }
;;;52         if((GPIO_MODE_INPUT==Mode)|(GPIO_MODE_QUASI==Mode))
        0x00000856:    2a00        .*      CMP      r2,#0
        0x00000858:    d002        ..      BEQ      0x860 ; GPIO_SetMode + 48
        0x0000085a:    2400        .$      MOVS     r4,#0
        0x0000085c:    2a03        .*      CMP      r2,#3
        0x0000085e:    d007        ..      BEQ      0x870 ; GPIO_SetMode + 64
        0x00000860:    2200        ."      MOVS     r2,#0
        0x00000862:    4314        .C      ORRS     r4,r4,r2
        0x00000864:    d003        ..      BEQ      0x86e ; GPIO_SetMode + 62
        0x00000866:    6842        Bh      LDR      r2,[r0,#4]
        0x00000868:    0409        ..      LSLS     r1,r1,#16
        0x0000086a:    438a        .C      BICS     r2,r2,r1
        0x0000086c:    6042        B`      STR      r2,[r0,#4]
        0x0000086e:    bdf0        ..      POP      {r4-r7,pc}
        0x00000870:    2201        ."      MOVS     r2,#1
        0x00000872:    e7f6        ..      B        0x862 ; GPIO_SetMode + 50
    i.GPIO_SetModeByPin
    GPIO_SetModeByPin
;;; ..\..\..\..\pan108\bsp.c
;;;234    {
        0x00000874:    b570        p.      PUSH     {r4-r6,lr}
        0x00000876:    460d        .F      MOV      r5,r1
        0x00000878:    4604        .F      MOV      r4,r0
;;;235        uint8_t port = PinID / 0x10;
        0x0000087a:    0900        ..      LSRS     r0,r0,#4
;;;236        uint8_t bit = PinID % 0x10;
        0x0000087c:    0722        ".      LSLS     r2,r4,#28
        0x0000087e:    0f12        ..      LSRS     r2,r2,#28
;;;237    
;;;238        GPIO_SetMode((GPIO_T*)(P0_BASE + 0x40 * port), BIT0 << bit, Mode);
        0x00000880:    2101        .!      MOVS     r1,#1
        0x00000882:    4091        .@      LSLS     r1,r1,r2
        0x00000884:    0180        ..      LSLS     r0,r0,#6
        0x00000886:    4a09        .J      LDR      r2,[pc,#36] ; [0x8ac] = 0x40020000
        0x00000888:    1880        ..      ADDS     r0,r0,r2
        0x0000088a:    462a        *F      MOV      r2,r5
        0x0000088c:    f7ffffd0    ....    BL       GPIO_SetMode ; 0x830
;;;239    
;;;240        if (Mode == GPIO_MODE_INPUT || Mode == GPIO_MODE_QUASI)
        0x00000890:    2d00        .-      CMP      r5,#0
        0x00000892:    d001        ..      BEQ      0x898 ; GPIO_SetModeByPin + 36
        0x00000894:    2d03        .-      CMP      r5,#3
        0x00000896:    d107        ..      BNE      0x8a8 ; GPIO_SetModeByPin + 52
;;;241        {
;;;242            if (PinID == P5_6 || PinID == P4_6 || PinID == P4_7)
        0x00000898:    2c56        V,      CMP      r4,#0x56
        0x0000089a:    d003        ..      BEQ      0x8a4 ; GPIO_SetModeByPin + 48
        0x0000089c:    2c46        F,      CMP      r4,#0x46
        0x0000089e:    d001        ..      BEQ      0x8a4 ; GPIO_SetModeByPin + 48
        0x000008a0:    2c47        G,      CMP      r4,#0x47
        0x000008a2:    d101        ..      BNE      0x8a8 ; GPIO_SetModeByPin + 52
;;;243            {
;;;244                // These Pins' DINOFF bits should be synced to 3v area
;;;245                CLK_Wait3vSyncReady();
        0x000008a4:    f7fffeb0    ....    BL       CLK_Wait3vSyncReady ; 0x608
;;;246            }
;;;247        }
;;;248    }
        0x000008a8:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x000008aa:    0000        ..      DCW    0
        0x000008ac:    40020000    ...@    DCD    1073872896
    $t
    i.Hard_Fault_Handler
    Hard_Fault_Handler
    __tagsym$$used
;;; .\..\..\..\..\pan108\device\Source\pan_retarget.c
;;;45     {
        0x000008b0:    4604        .F      MOV      r4,r0
;;;46         printf("In Hard Fault Handler\r\n");
        0x000008b2:    a003        ..      ADR      r0,{pc}+0xe ; 0x8c0
        0x000008b4:    f000ff78    ..x.    BL       __0printf$8 ; 0x17a8
;;;47     
;;;48         stackDump(stack);
        0x000008b8:    4620         F      MOV      r0,r4
        0x000008ba:    f001faed    ....    BL       stackDump ; 0x1e98
;;;49     
;;;50         while(1);
        0x000008be:    e7fe        ..      B        0x8be ; Hard_Fault_Handler + 14
    $d
        0x000008c0:    48206e49    In H    DCD    1210084937
        0x000008c4:    20647261    ard     DCD    543453793
        0x000008c8:    6c756146    Faul    DCD    1819631942
        0x000008cc:    61482074    t Ha    DCD    1632116852
        0x000008d0:    656c646e    ndle    DCD    1701602414
        0x000008d4:    000a0d72    r...    DCD    658802
    $t
    i.InitIcache
    InitIcache
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c
;;;805    	CR->X_CACHE_EN = 0x00;
        0x000008d8:    2200        ."      MOVS     r2,#0
        0x000008da:    2001        .       MOVS     r0,#1
        0x000008dc:    0580        ..      LSLS     r0,r0,#22
        0x000008de:    6002        .`      STR      r2,[r0,#0]
        0x000008e0:    2202        ."      MOVS     r2,#2
        0x000008e2:    2900        .)      CMP      r1,#0
;;; .\..\..\..\..\pan108\peripheral\src\pan_fmc.c (803)
        0x000008e4:    d004        ..      BEQ      0x8f0 ; InitIcache + 24
;;;804    	// Disable cache
;;;805    	CR->X_CACHE_EN = 0x00;
;;;806    
;;;807        if ((mode == FLASH_X1_MODE) || (mode == FLASH_X2_MODE))
        0x000008e6:    2901        .)      CMP      r1,#1
        0x000008e8:    d002        ..      BEQ      0x8f0 ; InitIcache + 24
        0x000008ea:    2902        .)      CMP      r1,#2
        0x000008ec:    d003        ..      BEQ      0x8f6 ; InitIcache + 30
        0x000008ee:    e005        ..      B        0x8fc ; InitIcache + 36
;;;808        {
;;;809            CR->X_CACHE_INI |= 0x02;    // flash_has_no_wrap = 1
        0x000008f0:    6881        .h      LDR      r1,[r0,#8]
        0x000008f2:    4311        .C      ORRS     r1,r1,r2
        0x000008f4:    e001        ..      B        0x8fa ; InitIcache + 34
;;;810        }
;;;811        else if (mode == FLASH_X4_MODE)
;;;812        {
;;;813            CR->X_CACHE_INI &= ~0x02;   // flash_has_no_wrap = 0
        0x000008f6:    6881        .h      LDR      r1,[r0,#8]
        0x000008f8:    4391        .C      BICS     r1,r1,r2
        0x000008fa:    6081        .`      STR      r1,[r0,#8]
;;;814        }
;;;815    
;;;816    	// Flush cache, ini_trg = 1
;;;817    	CR->X_CACHE_INI |= 0x01; //inv_all
        0x000008fc:    6882        .h      LDR      r2,[r0,#8]
        0x000008fe:    2101        .!      MOVS     r1,#1
        0x00000900:    430a        .C      ORRS     r2,r2,r1
        0x00000902:    6082        .`      STR      r2,[r0,#8]
;;;818    
;;;819    	while(CR->X_CACHE_INI & 0x1){};
        0x00000904:    6882        .h      LDR      r2,[r0,#8]
        0x00000906:    07d2        ..      LSLS     r2,r2,#31
        0x00000908:    d1fc        ..      BNE      0x904 ; InitIcache + 44
;;;820    
;;;821    	// Enable cache
;;;822    	CR->X_CACHE_EN = 0x01;
        0x0000090a:    6001        .`      STR      r1,[r0,#0]
;;;823    }
        0x0000090c:    4770        pG      BX       lr
        0x0000090e:    0000        ..      MOVS     r0,r0
    i.PAN216_Calibration
    PAN216_Calibration
;;; ..\..\..\..\radio\pan216.c
;;;169    {
        0x00000910:    b510        ..      PUSH     {r4,lr}
;;;170        /* Set Page 1 */
;;;171        PAN216_WriteReg(0x00, 0x01);
        0x00000912:    2101        .!      MOVS     r1,#1
        0x00000914:    2000        .       MOVS     r0,#0
        0x00000916:    f000fda9    ....    BL       PAN216_WriteReg ; 0x146c
;;;172        /* Start VCO calibration */
;;;173        PAN216_WriteReg(0x1b, BIT3);
        0x0000091a:    2108        .!      MOVS     r1,#8
        0x0000091c:    201b        .       MOVS     r0,#0x1b
        0x0000091e:    f000fda5    ....    BL       PAN216_WriteReg ; 0x146c
;;;174        /* Wait for VCO calibration to complete, 30 (32M Crystal)/ 48 (16M Crystal) us minimum */
;;;175        Pan216_Funs.delayus(300);
        0x00000922:    4c15        .L      LDR      r4,[pc,#84] ; [0x978] = 0x2000000c
        0x00000924:    20ff        .       MOVS     r0,#0xff
        0x00000926:    6921        !i      LDR      r1,[r4,#0x10]
        0x00000928:    302d        -0      ADDS     r0,r0,#0x2d
        0x0000092a:    4788        .G      BLX      r1
;;;176        // while (((PAN216_ReadReg(0x70) & BIT6) != BIT6))
;;;177        //     ;
;;;178        /* Start TP calibration */
;;;179        PAN216_WriteReg(0x1b, BIT4);
        0x0000092c:    2110        .!      MOVS     r1,#0x10
        0x0000092e:    201b        .       MOVS     r0,#0x1b
        0x00000930:    f000fd9c    ....    BL       PAN216_WriteReg ; 0x146c
;;;180        /* Wait for TP calibration to complete, 44 ms minimum */
;;;181        Pan216_Funs.delayms(55);
        0x00000934:    6961        ai      LDR      r1,[r4,#0x14]
        0x00000936:    2037        7       MOVS     r0,#0x37
        0x00000938:    4788        .G      BLX      r1
;;;182        /* Enter RX mode */
;;;183        PAN216_WriteReg(0x02, 0x76);
        0x0000093a:    2176        v!      MOVS     r1,#0x76
        0x0000093c:    2002        .       MOVS     r0,#2
        0x0000093e:    f000fd95    ....    BL       PAN216_WriteReg ; 0x146c
;;;184        Pan216_Funs.delayus(200);
        0x00000942:    6921        !i      LDR      r1,[r4,#0x10]
        0x00000944:    20c8        .       MOVS     r0,#0xc8
        0x00000946:    4788        .G      BLX      r1
;;;185        /* Start Offset calibration */
;;;186        PAN216_WriteReg(0x1b, BIT5);
        0x00000948:    2120         !      MOVS     r1,#0x20
        0x0000094a:    201b        .       MOVS     r0,#0x1b
        0x0000094c:    f000fd8e    ....    BL       PAN216_WriteReg ; 0x146c
;;;187        /* Wait for Offset calibration to complete, 370 (32M Crystal)/ 590 (16M Crystal) us minimum */
;;;188        Pan216_Funs.delayus(700);
        0x00000950:    20af        .       MOVS     r0,#0xaf
        0x00000952:    6921        !i      LDR      r1,[r4,#0x10]
        0x00000954:    0080        ..      LSLS     r0,r0,#2
        0x00000956:    4788        .G      BLX      r1
;;;189        // while (((PAN216_ReadReg(0x7f) & BIT7) != BIT7));
;;;190        /* Start BW calibration */
;;;191        PAN216_WriteReg(0x1b, BIT6);
        0x00000958:    2140        @!      MOVS     r1,#0x40
        0x0000095a:    201b        .       MOVS     r0,#0x1b
        0x0000095c:    f000fd86    ....    BL       PAN216_WriteReg ; 0x146c
;;;192        /* Wait for BW calibration to complete, 340 us minimum */
;;;193        Pan216_Funs.delayus(400);
        0x00000960:    20ff        .       MOVS     r0,#0xff
        0x00000962:    6921        !i      LDR      r1,[r4,#0x10]
        0x00000964:    3091        .0      ADDS     r0,r0,#0x91
        0x00000966:    4788        .G      BLX      r1
;;;194        // while (((PAN216_ReadReg(0x6d) & BIT7) != BIT7))
;;;195        //     ;
;;;196        /* Start DCOC calibration */
;;;197        PAN216_WriteReg(0x1b, BIT7);
        0x00000968:    2180        .!      MOVS     r1,#0x80
        0x0000096a:    201b        .       MOVS     r0,#0x1b
        0x0000096c:    f000fd7e    ..~.    BL       PAN216_WriteReg ; 0x146c
;;;198        /* Wait for DCOC calibration to complete, 1030 us minimum */
;;;199        Pan216_Funs.delayus(1100);
        0x00000970:    6921        !i      LDR      r1,[r4,#0x10]
        0x00000972:    4802        .H      LDR      r0,[pc,#8] ; [0x97c] = 0x44c
        0x00000974:    4788        .G      BLX      r1
;;;200        // while (((PAN216_ReadReg(0x7f) & BIT7) != BIT7))
;;;201        //  ;
;;;202    }
        0x00000976:    bd10        ..      POP      {r4,pc}
    $d
        0x00000978:    2000000c    ...     DCD    536870924
        0x0000097c:    0000044c    L...    DCD    1100
    $t
    i.PAN216_ClearIRQFlags
    PAN216_ClearIRQFlags
;;;203    
;;;204    void PAN216_FinishCalibration(void)
;;;205    {
;;;206        /* Stop DCOC calibration */
;;;207        PAN216_WriteReg(0x1b, 0x00);
;;;208    
;;;209        /* Enter STB3 mode */
;;;210        PAN216_WriteReg(0x02, 0x74);
;;;211        /* Set Page 0 */
;;;212        PAN216_WriteReg(0x00, 0x00);
;;;213    }
;;;214    
;;;215    /**
;;;216     * @brief Enter Sleep Mode from Standby Mode
;;;217     *
;;;218     * @return PAN216_Err_t
;;;219     */
;;;220    PAN216_Err_t PAN216_EnterSleep(void)
;;;221    {
;;;222        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;223    #if INTERFACE_MODE == USE_I2C
;;;224        P_ASSERT(PAN216_WriteReg(0x02, 0x71));
;;;225    #else
;;;226        P_ASSERT(PAN216_WriteReg(0x02, 0x21));
;;;227    #endif
;;;228    
;;;229        return PAN216_OK;
;;;230    }
;;;231    
;;;232    /**
;;;233     * @brief Exit Sleep Mode and enter Standby Mode
;;;234     *
;;;235     * @return PAN216_Err_t
;;;236     */
;;;237    PAN216_Err_t PAN216_ExitSleep(void)
;;;238    {
;;;239        P_ASSERT(PAN216_WriteReg(0x02, 0x22)); // stb1
;;;240        P_ASSERT(PAN216_WriteReg(0x02, 0x74)); // stb3
;;;241        Pan216_Funs.delayus(500);              // waiting for CLKRDY, 440us(32M)
;;;242    
;;;243        return PAN216_OK;
;;;244    }
;;;245    
;;;246    /**
;;;247     * @brief Exit the TX state and enter standby mode. Make sure IRQ is cleared before calling this
;;;248     * function
;;;249     *
;;;250     * @param None
;;;251     *
;;;252     * @return Result of the operation
;;;253     *         - PAN216_OK
;;;254     *         - PAN216_ERR
;;;255     */
;;;256    PAN216_Err_t PAN216_ExitTxMode(void)
;;;257    {
;;;258        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;259    
;;;260        return PAN216_OK;
;;;261    }
;;;262    
;;;263    /**
;;;264     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;265     * function
;;;266     *
;;;267     * @param None
;;;268     *
;;;269     * @return Result of the operation
;;;270     *         - PAN216_OK
;;;271     *         - PAN216_ERR
;;;272     */
;;;273    PAN216_Err_t PAN216_ExitRxMode(void)
;;;274    {
;;;275        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;276    
;;;277        return PAN216_OK;
;;;278    }
;;;279    
;;;280    /**
;;;281     * @brief Prepares the PAN216 transceiver to enter TX or RX mode.
;;;282     *
;;;283     * This function configures the transceiver to switch between TX and RX modes. It sets the
;;;284     * appropriate registers to ensure the transceiver is ready for transmission or reception.
;;;285     * If the transceiver is already in the desired mode, this function does nothing.
;;;286     *
;;;287     * @param mode The desired mode to set, either PAN216_TX or PAN216_RX.
;;;288     *
;;;289     * @return PAN216_Err_t Result of the operation
;;;290     *         - PAN216_OK: Operation was successful
;;;291     *         - PAN216_ERR: Operation failed
;;;292     */
;;;293    PAN216_Err_t PAN216_PrepareTRxWithAck(PAN216_TRXMode_t Mode, bool EnAck)
;;;294    {
;;;295        if (EnAck == true)
;;;296        {
;;;297            /* Uses Tx confiruration if ACK is enabled */
;;;298            Mode = PAN216_TX;
;;;299        }
;;;300    
;;;301        if (Mode == PAN216_TX)
;;;302        {
;;;303            PAN216_WriteReg(0x00, 0x01);
;;;304            PAN216_WriteReg(0x42, 0xa4);
;;;305            PAN216_WriteReg(0x00, 0x00);
;;;306        }
;;;307        else if (Mode == PAN216_RX)
;;;308        {
;;;309            PAN216_WriteReg(0x00, 0x01);
;;;310            PAN216_WriteReg(0x42, 0xa0);
;;;311            PAN216_WriteReg(0x00, 0x00);
;;;312        }
;;;313    
;;;314        return PAN216_OK;
;;;315    }
;;;316    
;;;317    /**
;;;318     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;319     * function
;;;320     *
;;;321     * @return PAN216_Err_t
;;;322     */
;;;323    PAN216_Err_t PAN216_TxStart(void)
;;;324    {
;;;325        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;326        P_ASSERT(PAN216_WriteReg(0x02, 0x75));
;;;327    
;;;328        return PAN216_OK;
;;;329    }
;;;330    
;;;331    /**
;;;332     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;333     function
;;;334    
;;;335     *
;;;336     * @return PAN216_Err_t
;;;337     */
;;;338    PAN216_Err_t PAN216_RxStart(void)
;;;339    {
;;;340        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;341        P_ASSERT(PAN216_WriteReg(0x02, 0x76));
;;;342    
;;;343        return PAN216_OK;
;;;344    }
;;;345    
;;;346    /**
;;;347     * @brief Sets the frequency channel of the PAN216 transceiver
;;;348     *
;;;349     * @param Channel The desired radio frequency channel, as a value from 0 to 83
;;;350     *
;;;351     * @note The actual frequency will be (2400 + Channel)MHz
;;;352     * @note The PLOS_CNT[7:4] bits of the OBSERVER_TX register will be reset
;;;353     *
;;;354     * @return uint8_t Result of the operation
;;;355     *         - PAN216_OK
;;;356     *         - PAN216_ERR
;;;357     */
;;;358    PAN216_Err_t PAN216_SetChannel(uint8_t Channel)
;;;359    {
;;;360        return PAN216_WriteReg(REG_P0_0X39, Channel);
;;;361    }
;;;362    
;;;363    /**
;;;364     * @brief Sets the address width of the PAN216 transceiver
;;;365     *
;;;366     * This function is used to set the RX/TX address field width of the PAN216 transceiver.
;;;367     * The address width is specified as a value between 3 and 5.
;;;368     *
;;;369     * @param AddrWidth The desired address width, as a value from 3 to 5
;;;370     *          - 00 2bytes
;;;371     *          - 01 3bytes
;;;372     *          - 10 4bytes
;;;373     *          - 11 5bytes
;;;374     * @return uint8_t Result of the operation
;;;375     *         - PAN216_OK
;;;376     *         - PAN216_ERR
;;;377     */
;;;378    PAN216_Err_t PAN216_SetAddrWidth(PAN216_AddrWidth_t AddrWidth)
;;;379    {
;;;380        P_ASSERT(PAN216_WriteRegBits(WMODE_CFG1, AddrWidth - 2, WMODE_CFG1_ADDR_BYTE_LENGTH));
;;;381    
;;;382        return PAN216_OK;
;;;383    }
;;;384    
;;;385    /**
;;;386     * @brief Set static RX address for a specified pipe
;;;387     *
;;;388     * @param Pipe - pipe to configure address, one of PAN216_Pipe_t values
;;;389     * @param Addr - pointer to the buffer with address
;;;390     * @param len - length of address
;;;391     * @note Pipe can be a number from 0 to 5 (RX pipes)
;;;392     * @note Buffer length must be equal to current address width of transceiver
;;;393     * @note For pipes[2..5] only the first byte of address will be written because other bytes of
;;;394     * address equals to pipe1
;;;395     * @note For pipes[2..5] only the first byte of address will be written because pipes 1-5 share the
;;;396     * four most significant address bytes
;;;397     * @return uint8_t Result of the operation
;;;398     *         - PAN216_OK
;;;399     *         - PAN216_ERR
;;;400     */
;;;401    PAN216_Err_t PAN216_SetRxAddr(PAN216_Pipe_t Pipe, uint8_t *Addr, uint8_t len)
;;;402    {
;;;403    
;;;404        switch (Pipe)
;;;405        {
;;;406        case PAN216_PIPE0:
;;;407            P_ASSERT(PAN216_WriteRegs(PIPE0_RXADDR0_CFG, Addr, len));
;;;408            break;
;;;409        case PAN216_PIPE1:
;;;410            P_ASSERT(PAN216_WriteRegs(PIPE1_RXADDR0_CFG, Addr, len));
;;;411            break;
;;;412        case PAN216_PIPE2:
;;;413            P_ASSERT(PAN216_WriteReg(PIPE2_RXADDR0_CFG, Addr[0]));
;;;414            break;
;;;415        case PAN216_PIPE3:
;;;416            P_ASSERT(PAN216_WriteReg(PIPE3_RXADDR0_CFG, Addr[0]));
;;;417            break;
;;;418        case PAN216_PIPE4:
;;;419            P_ASSERT(PAN216_WriteReg(PIPE4_RXADDR0_CFG, Addr[0]));
;;;420            break;
;;;421        case PAN216_PIPE5:
;;;422            P_ASSERT(PAN216_WriteReg(PIPE5_RXADDR0_CFG, Addr[0]));
;;;423            break;
;;;424        default:
;;;425            return PAN216_ERR;
;;;426        }
;;;427    
;;;428        return PAN216_OK;
;;;429    }
;;;430    
;;;431    /**
;;;432     * @brief Set static TX address for the transceiver
;;;433     *
;;;434     * @param Addr Pointer to the buffer with address
;;;435     * @param AddrWidth TX address field width, value from 3 to 5
;;;436     * @return uint8_t Result of the operation
;;;437     *         - PAN216_OK
;;;438     *         - PAN216_ERR
;;;439     */
;;;440    PAN216_Err_t PAN216_SetTxAddr(uint8_t *Addr, uint8_t len)
;;;441    {
;;;442        return PAN216_WriteRegs(TXADDR0_CFG, Addr, len);
;;;443    }
;;;444    
;;;445    /**
;;;446     * @brief Get the pipe number for the payload available for reading from RX FIFO
;;;447     *
;;;448     * @return uint8_t Pipe number or 0xFF if the RX FIFO is empty
;;;449     *         - 0x00: Pipe 0
;;;450     *         - 0x01: Pipe 1
;;;451     *         - 0x02: Pipe 2
;;;452     *         - 0x03: Pipe 3
;;;453     *         - 0x04: Pipe 4
;;;454     *         - 0x05: Pipe 5
;;;455     * @return uint8_t Result of the operation
;;;456     *         - PAN216_OK
;;;457     *         - PAN216_ERR
;;;458     */
;;;459    PAN216_Pipe_t PAN216_GetRxPipeNum(void)
;;;460    {
;;;461        uint8_t pipeNum = (PAN216_ReadReg(STATUS0) >> 4) & 0x07;
;;;462    
;;;463        return (PAN216_Pipe_t)pipeNum;
;;;464    }
;;;465    
;;;466    /**
;;;467     * @brief Get pending IRQ flags
;;;468     *
;;;469     * @return Current status of RX_DONE, TX_DONE, RX_TIMEOUT, and MAX_RT bits of the STATUS register
;;;470     */
;;;471    uint8_t PAN216_GetIRQFlags(void)
;;;472    {
;;;473        return PAN216_ReadReg(RFIRQFLG);
;;;474    }
;;;475    
;;;476    /**
;;;477     * @brief Clears any pending IRQ flags of the PAN216 transceiver
;;;478     *
;;;479     * This function clears any pending IRQ flags of the PAN216 transceiver.
;;;480     *         - RF_IT_TX_IRQ
;;;481     *         - RF_IT_MAX_RT_IRQ
;;;482     *         - RF_IT_ADDR_ERR_IRQ
;;;483     *         - RF_IT_CRC_ERR_IRQ
;;;484     *         - RF_IT_LEN_ERR_IRQ
;;;485     *         - RF_IT_PID_ERR_IRQ
;;;486     *         - RF_IT_RX_TIMEOUT_IRQ
;;;487     *         - RF_IT_RX_IRQ
;;;488     * @return Result of the operation
;;;489     *         - PAN216_OK
;;;490     *         - PAN216_ERR
;;;491     */
;;;492    PAN216_Err_t PAN216_ClearIRQFlags(uint8_t flags)
;;;493    {
        0x00000980:    b510        ..      PUSH     {r4,lr}
;;;494        return PAN216_WriteRegUnchecked(RFIRQFLG, flags);
        0x00000982:    4601        .F      MOV      r1,r0
        0x00000984:    2073        s       MOVS     r0,#0x73
        0x00000986:    f000fdd1    ....    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;495    }
        0x0000098a:    bd10        ..      POP      {r4,pc}
    i.PAN216_ConfigIT
    PAN216_ConfigIT
;;;496    
;;;497    /**
;;;498     * @brief  This function is used to enable or disable RF interrupts
;;;499     * @param  NewState: which can be ENABLE or DISABLE
;;;500     * @param  RF_IT: Which can be
;;;501     *         - RF_IT_TX_IRQ
;;;502     *         - RF_IT_MAX_RT_IRQ
;;;503     *         - RF_IT_ADDR_ERR_IRQ
;;;504     *         - RF_IT_CRC_ERR_IRQ
;;;505     *         - RF_IT_LEN_ERR_IRQ
;;;506     *         - RF_IT_PID_ERR_IRQ
;;;507     *         - RF_IT_RX_TIMEOUT_IRQ
;;;508     *         - RF_IT_RX_IRQ
;;;509     * @return Result of the operation:
;;;510     *         - PAN216_OK
;;;511     *         - PAN216_ERR
;;;512     */
;;;513    PAN216_Err_t PAN216_ConfigIT(uint8_t RF_IT)
;;;514    {
;;;515        return PAN216_WriteReg(RFIRQ_CFG, ~RF_IT);
        0x0000098c:    43c0        .C      MVNS     r0,r0
;;; ..\..\..\..\radio\pan216.c (514)
        0x0000098e:    b510        ..      PUSH     {r4,lr}
;;;515        return PAN216_WriteReg(RFIRQ_CFG, ~RF_IT);
        0x00000990:    b2c1        ..      UXTB     r1,r0
        0x00000992:    200b        .       MOVS     r0,#0xb
        0x00000994:    f000fd6a    ..j.    BL       PAN216_WriteReg ; 0x146c
;;;516    }
        0x00000998:    bd10        ..      POP      {r4,pc}
    i.PAN216_CrcSkipAddr
    PAN216_CrcSkipAddr
;;; ..\..\..\..\radio\pan216_ext.c
;;;667    {
        0x0000099a:    b510        ..      PUSH     {r4,lr}
        0x0000099c:    2800        .(      CMP      r0,#0
        0x0000099e:    d005        ..      BEQ      0x9ac ; PAN216_CrcSkipAddr + 18
;;;668        if (exclude)
;;;669        {
;;;670            return PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
        0x000009a0:    2204        ."      MOVS     r2,#4
        0x000009a2:    2107        .!      MOVS     r1,#7
        0x000009a4:    2000        .       MOVS     r0,#0
        0x000009a6:    f000fb74    ..t.    BL       PAN216_SetRegBits ; 0x1092
        0x000009aa:    bd10        ..      POP      {r4,pc}
;;;671        }
;;;672        else
;;;673        {
;;;674            return PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
        0x000009ac:    2204        ."      MOVS     r2,#4
        0x000009ae:    2107        .!      MOVS     r1,#7
        0x000009b0:    2000        .       MOVS     r0,#0
        0x000009b2:    f000fa37    ..7.    BL       PAN216_ResetRegBits ; 0xe24
;;;675        }
;;;676    }
        0x000009b6:    bd10        ..      POP      {r4,pc}
    i.PAN216_DRModConfig
    PAN216_DRModConfig
;;; ..\..\..\..\radio\pan216_ext.c (225)
        0x000009b8:    b510        ..      PUSH     {r4,lr}
        0x000009ba:    4832        2H      LDR      r0,[pc,#200] ; [0xa84] = 0x20000024
        0x000009bc:    7840        @x      LDRB     r0,[r0,#1]
        0x000009be:    2800        .(      CMP      r0,#0
;;; ..\..\..\..\radio\pan216_ext.c (225)
        0x000009c0:    d004        ..      BEQ      0x9cc ; PAN216_DRModConfig + 20
;;;226        switch (_gDataRate)
        0x000009c2:    2801        .(      CMP      r0,#1
        0x000009c4:    d03d        =.      BEQ      0xa42 ; PAN216_DRModConfig + 138
        0x000009c6:    2802        .(      CMP      r0,#2
        0x000009c8:    d139        9.      BNE      0xa3e ; PAN216_DRModConfig + 134
        0x000009ca:    e014        ..      B        0x9f6 ; PAN216_DRModConfig + 62
;;;227        {
;;;228        case PAN216_DR_1Mbps:
;;;229            PAN216_WritePageRegBits(PAN216_PAGE0, 0x43, 0, BIT2);
        0x000009cc:    2200        ."      MOVS     r2,#0
        0x000009ce:    2304        .#      MOVS     r3,#4
        0x000009d0:    2143        C!      MOVS     r1,#0x43
        0x000009d2:    4610        .F      MOV      r0,r2
        0x000009d4:    f000fd18    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;230            PAN216_WritePageRegBits(PAN216_PAGE0, 0x43, 2, BIT1 | BIT0);
        0x000009d8:    2303        .#      MOVS     r3,#3
        0x000009da:    2202        ."      MOVS     r2,#2
        0x000009dc:    2143        C!      MOVS     r1,#0x43
        0x000009de:    2000        .       MOVS     r0,#0
        0x000009e0:    f000fd12    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;231            PAN216_WritePageRegBits(PAN216_PAGE1, 0x3A, 0, BIT7 | BIT6);
        0x000009e4:    23c0        .#      MOVS     r3,#0xc0
        0x000009e6:    2200        ."      MOVS     r2,#0
        0x000009e8:    213a        :!      MOVS     r1,#0x3a
        0x000009ea:    2001        .       MOVS     r0,#1
        0x000009ec:    f000fd0c    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;232            PAN216_WritePageRegBits(PAN216_PAGE1, 0x49, 1, BIT7);
        0x000009f0:    2380        .#      MOVS     r3,#0x80
        0x000009f2:    2201        ."      MOVS     r2,#1
;;;233            PAN216_WritePageRegBits(PAN216_PAGE1, 0x49, 4, BIT6 | BIT5 | BIT4);
;;;234            PAN216_WritePageRegBits(PAN216_PAGE1, 0x4C, 0, BIT5);
;;;235            break;
        0x000009f4:    e013        ..      B        0xa1e ; PAN216_DRModConfig + 102
;;;236        case PAN216_DR_250Kbps:
;;;237            PAN216_WritePageRegBits(PAN216_PAGE0, 0x43, 0, BIT2);
        0x000009f6:    2200        ."      MOVS     r2,#0
        0x000009f8:    2304        .#      MOVS     r3,#4
        0x000009fa:    2143        C!      MOVS     r1,#0x43
        0x000009fc:    4610        .F      MOV      r0,r2
        0x000009fe:    f000fd03    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;238            PAN216_WritePageRegBits(PAN216_PAGE0, 0x43, 3, BIT1 | BIT0);
        0x00000a02:    2303        .#      MOVS     r3,#3
        0x00000a04:    461a        .F      MOV      r2,r3
        0x00000a06:    2143        C!      MOVS     r1,#0x43
        0x00000a08:    2000        .       MOVS     r0,#0
        0x00000a0a:    f000fcfd    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;239            PAN216_WritePageRegBits(PAN216_PAGE1, 0x3A, 1, BIT7 | BIT6);
        0x00000a0e:    2201        ."      MOVS     r2,#1
        0x00000a10:    23c0        .#      MOVS     r3,#0xc0
        0x00000a12:    213a        :!      MOVS     r1,#0x3a
        0x00000a14:    4610        .F      MOV      r0,r2
        0x00000a16:    f000fcf7    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;240            PAN216_WritePageRegBits(PAN216_PAGE1, 0x49, 0, BIT7);
        0x00000a1a:    2380        .#      MOVS     r3,#0x80
        0x00000a1c:    2200        ."      MOVS     r2,#0
        0x00000a1e:    2149        I!      MOVS     r1,#0x49
        0x00000a20:    2001        .       MOVS     r0,#1
        0x00000a22:    f000fcf1    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000a26:    2370        p#      MOVS     r3,#0x70
        0x00000a28:    2204        ."      MOVS     r2,#4
        0x00000a2a:    2149        I!      MOVS     r1,#0x49
        0x00000a2c:    2001        .       MOVS     r0,#1
        0x00000a2e:    f000fceb    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000a32:    2320         #      MOVS     r3,#0x20
        0x00000a34:    2200        ."      MOVS     r2,#0
        0x00000a36:    214c        L!      MOVS     r1,#0x4c
        0x00000a38:    2001        .       MOVS     r0,#1
        0x00000a3a:    f000fce5    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000a3e:    2000        .       MOVS     r0,#0
        0x00000a40:    bd10        ..      POP      {r4,pc}
;;;241            PAN216_WritePageRegBits(PAN216_PAGE1, 0x49, 4, BIT6 | BIT5 | BIT4);
;;;242            PAN216_WritePageRegBits(PAN216_PAGE1, 0x4C, 0, BIT5);
;;;243            break;
;;;244        case PAN216_DR_2Mbps:
;;;245            PAN216_WritePageRegBits(PAN216_PAGE0, 0x43, 1, BIT2);
        0x00000a42:    2304        .#      MOVS     r3,#4
        0x00000a44:    2201        ."      MOVS     r2,#1
        0x00000a46:    2143        C!      MOVS     r1,#0x43
        0x00000a48:    2000        .       MOVS     r0,#0
        0x00000a4a:    f000fcdd    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;246            PAN216_WritePageRegBits(PAN216_PAGE0, 0x43, 2, BIT1 | BIT0);
        0x00000a4e:    2303        .#      MOVS     r3,#3
        0x00000a50:    2202        ."      MOVS     r2,#2
        0x00000a52:    2143        C!      MOVS     r1,#0x43
        0x00000a54:    2000        .       MOVS     r0,#0
        0x00000a56:    f000fcd7    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;247            PAN216_WritePageRegBits(PAN216_PAGE1, 0x3A, 0, BIT7 | BIT6);
        0x00000a5a:    23c0        .#      MOVS     r3,#0xc0
        0x00000a5c:    2200        ."      MOVS     r2,#0
        0x00000a5e:    213a        :!      MOVS     r1,#0x3a
        0x00000a60:    2001        .       MOVS     r0,#1
        0x00000a62:    f000fcd1    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;248            PAN216_WritePageRegBits(PAN216_PAGE1, 0x49, 1, BIT7);
        0x00000a66:    2201        ."      MOVS     r2,#1
        0x00000a68:    2380        .#      MOVS     r3,#0x80
        0x00000a6a:    2149        I!      MOVS     r1,#0x49
        0x00000a6c:    4610        .F      MOV      r0,r2
        0x00000a6e:    f000fccb    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;249            PAN216_WritePageRegBits(PAN216_PAGE1, 0x49, 4, BIT6 | BIT5 | BIT4);
        0x00000a72:    2370        p#      MOVS     r3,#0x70
        0x00000a74:    2204        ."      MOVS     r2,#4
        0x00000a76:    2149        I!      MOVS     r1,#0x49
        0x00000a78:    2001        .       MOVS     r0,#1
        0x00000a7a:    f000fcc5    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;250            PAN216_WritePageRegBits(PAN216_PAGE1, 0x4C, 1, BIT5);
        0x00000a7e:    2320         #      MOVS     r3,#0x20
        0x00000a80:    2201        ."      MOVS     r2,#1
;;;251            break;
        0x00000a82:    e7d8        ..      B        0xa36 ; PAN216_DRModConfig + 126
    $d
        0x00000a84:    20000024    $..     DCD    536870948
    $t
    i.PAN216_DisableRxPipe
    PAN216_DisableRxPipe
;;;252        default:
;;;253            break;
;;;254        }
;;;255        return PAN216_OK;
;;;256    }
;;;257    
;;;258    PAN216_Err_t PAN216_EnableFifo128bytes(bool NewState)
;;;259    {
;;;260        if (NewState)
;;;261        {
;;;262            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG1, 1, WMODE_CFG1_FIFO_128_EN));
;;;263        }
;;;264        else
;;;265        {
;;;266            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG1, 0, WMODE_CFG1_FIFO_128_EN));
;;;267        }
;;;268    
;;;269        return PAN216_OK;
;;;270    }
;;;271    
;;;272    /**
;;;273     * @brief Set the transmit mode of PAN216 transceiver.
;;;274     *
;;;275     * @param TxMode The transmit mode to be set.
;;;276     *        - PAN216_TX_MODE_SINGLE: single transmission
;;;277     *        - PAN216_TX_MODE_CONTINOUS: continuous transmission
;;;278     *
;;;279     * @return Result of the operation
;;;280     *         - PAN216_OK
;;;281     *         - PAN216_ERR
;;;282     */
;;;283    PAN216_Err_t PAN216_SetTxMode(PAN216_TxMode_t TxMode)
;;;284    {
;;;285        switch (TxMode)
;;;286        {
;;;287        case PAN216_TX_MODE_SINGLE:
;;;288            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_TX_MODE_SINGLE,
;;;289                                             TRXMODE_CFG_REG_TX_CFG_MODE));
;;;290            break;
;;;291        case PAN216_TX_MODE_CONTINOUS:
;;;292            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_TX_MODE_CONTINOUS,
;;;293                                             TRXMODE_CFG_REG_TX_CFG_MODE));
;;;294            break;
;;;295        default:
;;;296            return PAN216_ERR;
;;;297        }
;;;298    
;;;299        return PAN216_OK;
;;;300    }
;;;301    
;;;302    /**
;;;303     * @brief Set the receive mode of PAN216 transceiver.It has to be initialized  as STB3 mode before
;;;304     * entering RX mode.
;;;305     *
;;;306     * @param TxMode The receive mode to be set.
;;;307     *        - PAN216_RX_MODE_SINGLE: single reception
;;;308     *        - PAN216_RX_MODE_SINGLE_WITH_TIMEOUT: single reception with timeout
;;;309     *        - PAN216_RX_MODE_CONTINOUS: continuous reception
;;;310     *
;;;311     * @return Result of the operation
;;;312     *         - PAN216_OK
;;;313     *         - PAN216_ERR
;;;314     */
;;;315    PAN216_Err_t PAN216_SetRxMode(PAN216_RxMode_t RxMode)
;;;316    {
;;;317        switch (RxMode)
;;;318        {
;;;319        case PAN216_RX_MODE_SINGLE:
;;;320            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_RX_MODE_SINGLE,
;;;321                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;322            break;
;;;323        case PAN216_RX_MODE_SINGLE_WITH_TIMEOUT:
;;;324            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG,
;;;325                                             PAN216_RX_MODE_SINGLE_WITH_TIMEOUT,
;;;326                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;327            break;
;;;328        case PAN216_RX_MODE_CONTINOUS:
;;;329            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_RX_MODE_CONTINOUS,
;;;330                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;331            break;
;;;332        default:
;;;333            break;
;;;334        }
;;;335    
;;;336        return PAN216_OK;
;;;337    }
;;;338    
;;;339    /**
;;;340     * @brief  Performs a soft reset of the PAN216 transceiver module.
;;;341     *
;;;342     * @param  None
;;;343     *
;;;344     * @return uint8_t Result of the operation
;;;345     *         - PAN216_OK
;;;346     *         - PAN216_ERR
;;;347     * @note This function is designed for general operations.
;;;348     */
;;;349    PAN216_Err_t PAN216_SoftReset(void)
;;;350    {
;;;351        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, STATE_CFG, 0, STATE_CFG_POR_NRSTL));
;;;352        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, SYS_CFG, 0, SYS_CFG_REG_SOFT_RSTL));
;;;353        Pan216_Funs.delayms(1);
;;;354        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, STATE_CFG, 1, STATE_CFG_POR_NRSTL));
;;;355        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, SYS_CFG, 1, SYS_CFG_REG_SOFT_RSTL));
;;;356    
;;;357        return PAN216_OK;
;;;358    }
;;;359    
;;;360    PAN216_State_t PAN216_GetState(void)
;;;361    {
;;;362        uint8_t idleFlag;
;;;363        PAN216_State_t State;
;;;364    
;;;365        idleFlag = PAN216_ReadReg(0x7D) >> 7; // bit7为1表示mac处于IDLE
;;;366        State = (PAN216_State_t)(PAN216_ReadReg(0x7F) >> 6);
;;;367    
;;;368        if (State == 0)
;;;369        {
;;;370            State = idleFlag > 0 ? PAN216_STATE_IDLE : PAN216_STATE_ARD_WAIT;
;;;371        }
;;;372    
;;;373        return State;
;;;374    }
;;;375    
;;;376    /**
;;;377     * @brief Writes the PAN216 transceiver's TX PID value of a enhanced shockburst packet
;;;378     *
;;;379     * @param Pid 0~3
;;;380     * @return PAN216_Err_t
;;;381     */
;;;382    PAN216_Err_t PAN216_WriteTxManualPid(uint8_t Pid)
;;;383    {
;;;384        PAN216_WriteRegBits(PID_CFG, Pid, PID_CFG_TX_PID_MANUAL);
;;;385    
;;;386        return PAN216_OK;
;;;387    }
;;;388    
;;;389    /**
;;;390     * @brief Writes the PAN216 transceiver's RX PID value of a enhanced shockburst packet
;;;391     *
;;;392     * @param Pid 0~3
;;;393     * @return PAN216_Err_t
;;;394     */
;;;395    PAN216_Err_t PAN216_WriteRxManualPid(uint8_t Pid)
;;;396    {
;;;397        PAN216_WriteRegBits(PID_CFG, Pid, PID_CFG_RX_PID_MANUAL);
;;;398    
;;;399        return PAN216_OK;
;;;400    }
;;;401    
;;;402    /**
;;;403     * @brief Sets the DynamicPayloadLength feature for all pipes of the PAN216 transceiver
;;;404     *
;;;405     * This function is used to enable or disable the DynamicPayloadLength feature for all
;;;406     * pipes of the PAN216 transceiver.
;;;407     *
;;;408     * @param NewState ENABLE to enable the feature, DISABLE to disable the feature
;;;409     *
;;;410     * @return uint8_t Result of the operation
;;;411     *         - PAN216_OK
;;;412     *         - PAN216_ERR
;;;413     */
;;;414    PAN216_Err_t PAN216_EnableDynamicPL(uint8_t NewState)
;;;415    {
;;;416        if (NewState)
;;;417        {
;;;418            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
;;;419        }
;;;420        else
;;;421        {
;;;422            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
;;;423        }
;;;424    
;;;425        return PAN216_OK;
;;;426    }
;;;427    
;;;428    /**
;;;429     * @brief Configures the CRC scheme of the PAN216 transceiver
;;;430     *
;;;431     * This function is used to configure the CRC scheme of the PAN216 transceiver.
;;;432     *
;;;433     * @param Crc The desired CRC scheme, as a value of type PAN216_Crc_t
;;;434     *
;;;435     * @note The transceiver will forcibly turn on the CRC if auto-acknowledgment is enabled
;;;436     *       for at least one receive (RX) pipe
;;;437     *
;;;438     * @return uint8_t Result of the operation
;;;439     *         - PAN216_OK
;;;440     *         - PAN216_ERR
;;;441     */
;;;442    PAN216_Err_t PAN216_SetCrcScheme(PAN216_Crc_t Crc)
;;;443    {
;;;444        if (Crc > PAN216_CRC_3byte)
;;;445        {
;;;446            return PAN216_ERR;
;;;447        }
;;;448    
;;;449        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Crc, WMODE_CFG0_CRC_MODE_1_0));
;;;450    
;;;451        return PAN216_OK;
;;;452    }
;;;453    
;;;454    /**
;;;455     * @brief Configures the data rate of the PAN216 transceiver
;;;456     *
;;;457     * This function is used to configure the data rate of the PAN216 transceiver. The
;;;458     * data rate is specified as one of the members of PAN216_DataRate_t.
;;;459     *
;;;460     * @param DataRate The desired data rate, as one of the members of PAN216_DataRate_t
;;;461     *
;;;462     * @return uint8_t Result of the operation
;;;463     *         - PAN216_OK
;;;464     *         - PAN216_ERR
;;;465     */
;;;466    PAN216_Err_t PAN216_SetDataRate(PAN216_DataRate_t DataRate)
;;;467    {
;;;468        uint8_t DataRateVal;
;;;469    
;;;470        if (DataRate >= PAN216_DR_Max)
;;;471        {
;;;472            return PAN216_ERR;
;;;473        }
;;;474    
;;;475        switch (DataRate)
;;;476        {
;;;477        case PAN216_DR_1Mbps:
;;;478            DataRateVal = 0x00;
;;;479            _gDataRate = PAN216_DR_1Mbps;
;;;480            break;
;;;481        case PAN216_DR_2Mbps:
;;;482            DataRateVal = 0x01;
;;;483            _gDataRate = PAN216_DR_2Mbps;
;;;484            break;
;;;485        case PAN216_DR_250Kbps:
;;;486            DataRateVal = 0x03;
;;;487            _gDataRate = PAN216_DR_250Kbps;
;;;488            break;
;;;489        default:
;;;490            return PAN216_ERR;
;;;491        }
;;;492    
;;;493        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, REG_P0_0X36, DataRateVal, REG_P0_0X36_BW_MODE));
;;;494    
;;;495        PAN216_DRModConfig();
;;;496        WriteTxDemodConfig();
;;;497        WriteRxDemodConfig();
;;;498        PAN216_Calibration();
;;;499    #if CALIBRATION_DEBUG_ON
;;;500        PAN216_ReadVCOCode();
;;;501        PAN216_ReadTpCode();
;;;502        ReadBWDcocCal(FILTER_OFFSET_CAL_MODE, 0);
;;;503        ReadBWDcocCal(FILTER_BW_CAL_MODE, 0);
;;;504        ReadBWDcocCal(FILTER_BW_CAL_MODE, 1);
;;;505        ReadBWDcocCal(FILTER_BW_CAL_MODE, 2);
;;;506        ReadBWDcocCal(FILTER_DCOC_CAL_MODE, 0);
;;;507    #endif
;;;508        PAN216_FinishCalibration();
;;;509        return PAN216_OK;
;;;510    }
;;;511    
;;;512    PAN216_Err_t PAN216_EnableRxPipe(PAN216_Pipe_t Pipe)
;;;513    {
;;;514        if (Pipe > PAN216_PIPE5)
;;;515        {
;;;516            return PAN216_ERR;
;;;517        }
;;;518    
;;;519        return PAN216_SetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;520    }
;;;521    
;;;522    PAN216_Err_t PAN216_DisableRxPipe(PAN216_Pipe_t Pipe)
;;;523    {
        0x00000a88:    b510        ..      PUSH     {r4,lr}
        0x00000a8a:    2805        .(      CMP      r0,#5
;;; ..\..\..\..\radio\pan216_ext.c (523)
        0x00000a8c:    d901        ..      BLS      0xa92 ; PAN216_DisableRxPipe + 10
;;;524        if (Pipe > PAN216_PIPE5)
;;;525        {
;;;526            return PAN216_ERR;
        0x00000a8e:    2001        .       MOVS     r0,#1
        0x00000a90:    bd10        ..      POP      {r4,pc}
;;;527        }
;;;528    
;;;529        return PAN216_ResetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
        0x00000a92:    2101        .!      MOVS     r1,#1
        0x00000a94:    4081        .@      LSLS     r1,r1,r0
        0x00000a96:    b2ca        ..      UXTB     r2,r1
        0x00000a98:    211f        .!      MOVS     r1,#0x1f
        0x00000a9a:    2000        .       MOVS     r0,#0
        0x00000a9c:    f000f9c2    ....    BL       PAN216_ResetRegBits ; 0xe24
;;;530    }
        0x00000aa0:    bd10        ..      POP      {r4,pc}
    i.PAN216_EnableDynamicPL
    PAN216_EnableDynamicPL
        0x00000aa2:    b510        ..      PUSH     {r4,lr}
        0x00000aa4:    2800        .(      CMP      r0,#0
;;; ..\..\..\..\radio\pan216_ext.c (415)
        0x00000aa6:    d005        ..      BEQ      0xab4 ; PAN216_EnableDynamicPL + 18
;;;416        if (NewState)
;;;417        {
;;;418            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
        0x00000aa8:    2210        ."      MOVS     r2,#0x10
        0x00000aaa:    2108        .!      MOVS     r1,#8
        0x00000aac:    2000        .       MOVS     r0,#0
        0x00000aae:    f000faf0    ....    BL       PAN216_SetRegBits ; 0x1092
        0x00000ab2:    e004        ..      B        0xabe ; PAN216_EnableDynamicPL + 28
        0x00000ab4:    2210        ."      MOVS     r2,#0x10
        0x00000ab6:    2108        .!      MOVS     r1,#8
        0x00000ab8:    2000        .       MOVS     r0,#0
        0x00000aba:    f000f9b3    ....    BL       PAN216_ResetRegBits ; 0xe24
        0x00000abe:    2800        .(      CMP      r0,#0
        0x00000ac0:    d000        ..      BEQ      0xac4 ; PAN216_EnableDynamicPL + 34
;;;419        }
;;;420        else
;;;421        {
;;;422            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
        0x00000ac2:    2001        .       MOVS     r0,#1
;;;423        }
;;;424    
;;;425        return PAN216_OK;
;;;426    }
        0x00000ac4:    bd10        ..      POP      {r4,pc}
    i.PAN216_EnableFifo128bytes
    PAN216_EnableFifo128bytes
;;; ..\..\..\..\radio\pan216_ext.c (259)
        0x00000ac6:    b510        ..      PUSH     {r4,lr}
        0x00000ac8:    2800        .(      CMP      r0,#0
        0x00000aca:    d002        ..      BEQ      0xad2 ; PAN216_EnableFifo128bytes + 12
;;;260        if (NewState)
;;;261        {
;;;262            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG1, 1, WMODE_CFG1_FIFO_128_EN));
        0x00000acc:    2320         #      MOVS     r3,#0x20
        0x00000ace:    2201        ."      MOVS     r2,#1
        0x00000ad0:    e001        ..      B        0xad6 ; PAN216_EnableFifo128bytes + 16
        0x00000ad2:    2320         #      MOVS     r3,#0x20
        0x00000ad4:    2200        ."      MOVS     r2,#0
        0x00000ad6:    2108        .!      MOVS     r1,#8
        0x00000ad8:    2000        .       MOVS     r0,#0
        0x00000ada:    f000fc95    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000ade:    2800        .(      CMP      r0,#0
        0x00000ae0:    d000        ..      BEQ      0xae4 ; PAN216_EnableFifo128bytes + 30
;;;263        }
;;;264        else
;;;265        {
;;;266            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG1, 0, WMODE_CFG1_FIFO_128_EN));
        0x00000ae2:    2001        .       MOVS     r0,#1
;;;267        }
;;;268    
;;;269        return PAN216_OK;
;;;270    }
        0x00000ae4:    bd10        ..      POP      {r4,pc}
    i.PAN216_EnableInterfaceMuxIRQ
    PAN216_EnableInterfaceMuxIRQ
;;; ..\..\..\..\radio\pan216.c
;;;543        return PAN216_OK;
        0x00000ae6:    2000        .       MOVS     r0,#0
;;;544    }
        0x00000ae8:    4770        pG      BX       lr
    i.PAN216_EnableRxPipe
    PAN216_EnableRxPipe
;;; ..\..\..\..\radio\pan216_ext.c
;;;513    {
        0x00000aea:    b510        ..      PUSH     {r4,lr}
        0x00000aec:    2805        .(      CMP      r0,#5
        0x00000aee:    d901        ..      BLS      0xaf4 ; PAN216_EnableRxPipe + 10
;;;514        if (Pipe > PAN216_PIPE5)
;;;515        {
;;;516            return PAN216_ERR;
        0x00000af0:    2001        .       MOVS     r0,#1
        0x00000af2:    bd10        ..      POP      {r4,pc}
;;;517        }
;;;518    
;;;519        return PAN216_SetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
        0x00000af4:    2101        .!      MOVS     r1,#1
        0x00000af6:    4081        .@      LSLS     r1,r1,r0
        0x00000af8:    b2ca        ..      UXTB     r2,r1
        0x00000afa:    211f        .!      MOVS     r1,#0x1f
        0x00000afc:    2000        .       MOVS     r0,#0
        0x00000afe:    f000fac8    ....    BL       PAN216_SetRegBits ; 0x1092
;;;520    }
        0x00000b02:    bd10        ..      POP      {r4,pc}
    i.PAN216_EnableTxNoAck
    PAN216_EnableTxNoAck
;;;521    
;;;522    PAN216_Err_t PAN216_DisableRxPipe(PAN216_Pipe_t Pipe)
;;;523    {
;;;524        if (Pipe > PAN216_PIPE5)
;;;525        {
;;;526            return PAN216_ERR;
;;;527        }
;;;528    
;;;529        return PAN216_ResetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;530    }
;;;531    
;;;532    /**
;;;533     * @brief Configure a specified RX pipe
;;;534     *
;;;535     * @param Pipe        Number of the RX pipe, value from 0 to 6
;;;536     * @param PayloadLen  Payload length in bytes
;;;537     *
;;;538     * @return Result of the operation
;;;539     *         - PAN216_OK
;;;540     *         - PAN216_ERR
;;;541     */
;;;542    PAN216_Err_t PAN216_SetRxPayloadLen(uint8_t PayloadLen)
;;;543    {
;;;544        return PAN216_WritePageReg(PAN216_PAGE0, RXPLLEN_CFG, PayloadLen);
;;;545    }
;;;546    
;;;547    PAN216_Err_t PAN216_SetTxPayloadLen(uint8_t PayloadLen)
;;;548    {
;;;549        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXPLLEN_CFG, PayloadLen));
;;;550        return PAN216_OK;
;;;551    }
;;;552    
;;;553    /**
;;;554     * @brief Set enhanced shockburst mode for the PAN216 transceiver
;;;555     *
;;;556     * @param Mode Enhanced shockburst mode to set, one of PAN216_Mode_t values
;;;557     *
;;;558     * @return uint8_t Result of the operation
;;;559     *         - PAN216_OK
;;;560     *         - PAN216_ERR
;;;561     */
;;;562    PAN216_Err_t PAN216_SetWorkMode(PAN216_WorkMode_t Mode)
;;;563    {
;;;564    
;;;565        switch (Mode)
;;;566        {
;;;567        case PAN216_WORKMODE_NORMAL:
;;;568            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1,
;;;569                                         WMODE_CFG1_NORMAL_M1 | WMODE_CFG1_ENHANCE));
;;;570            break;
;;;571        case PAN216_WORKMODE_ENHANCE:
;;;572            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_ENHANCE));
;;;573            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;574            break;
;;;575        default:
;;;576            return PAN216_ERR;
;;;577        }
;;;578    
;;;579        return PAN216_OK;
;;;580    }
;;;581    
;;;582    PAN216_Err_t PAN216_GetChipMode(PAN216_ChipMode_t *chipMode)
;;;583    {
;;;584        *chipMode = (PAN216_ChipMode_t)_gChipMode;
;;;585        return PAN216_OK;
;;;586    }
;;;587    
;;;588    /**
;;;589     * @brief  This function set noack for tx
;;;590     * @param  NewState: ENABLE/DISABLE
;;;591     * @return Result of the operation
;;;592     *         - PAN216_OK
;;;593     *         - PAN216_ERR
;;;594     * @note  This function is called after PAN216_SetWorkMode
;;;595     */
;;;596    PAN216_Err_t PAN216_EnableTxNoAck(uint8_t NewState)
;;;597    {
        0x00000b04:    b510        ..      PUSH     {r4,lr}
        0x00000b06:    4604        .F      MOV      r4,r0
;;;598        uint8_t modeCfg1 = PAN216_ReadPageReg(PAN216_PAGE0, WMODE_CFG1);
        0x00000b08:    2108        .!      MOVS     r1,#8
        0x00000b0a:    2000        .       MOVS     r0,#0
        0x00000b0c:    f000f966    ..f.    BL       PAN216_ReadPageReg ; 0xddc
;;;599    
;;;600        if (modeCfg1 & WMODE_CFG1_ENHANCE)
        0x00000b10:    0700        ..      LSLS     r0,r0,#28
        0x00000b12:    d511        ..      BPL      0xb38 ; PAN216_EnableTxNoAck + 52
;;;601        {
;;;602            if (NewState)
        0x00000b14:    2c00        .,      CMP      r4,#0
        0x00000b16:    d005        ..      BEQ      0xb24 ; PAN216_EnableTxNoAck + 32
;;;603            {
;;;604                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
        0x00000b18:    2202        ."      MOVS     r2,#2
        0x00000b1a:    2107        .!      MOVS     r1,#7
        0x00000b1c:    2000        .       MOVS     r0,#0
        0x00000b1e:    f000fab8    ....    BL       PAN216_SetRegBits ; 0x1092
        0x00000b22:    e004        ..      B        0xb2e ; PAN216_EnableTxNoAck + 42
;;;605            }
;;;606            else
;;;607            {
;;;608                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
        0x00000b24:    2202        ."      MOVS     r2,#2
        0x00000b26:    2107        .!      MOVS     r1,#7
        0x00000b28:    2000        .       MOVS     r0,#0
        0x00000b2a:    f000f97b    ..{.    BL       PAN216_ResetRegBits ; 0xe24
        0x00000b2e:    2800        .(      CMP      r0,#0
        0x00000b30:    d118        ..      BNE      0xb64 ; PAN216_EnableTxNoAck + 96
;;;609            }
;;;610            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
        0x00000b32:    2204        ."      MOVS     r2,#4
        0x00000b34:    2108        .!      MOVS     r1,#8
        0x00000b36:    e010        ..      B        0xb5a ; PAN216_EnableTxNoAck + 86
;;;611        }
;;;612        else
;;;613        {
;;;614            if (NewState)
        0x00000b38:    2c00        .,      CMP      r4,#0
        0x00000b3a:    d005        ..      BEQ      0xb48 ; PAN216_EnableTxNoAck + 68
;;;615            {
;;;616                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
        0x00000b3c:    2204        ."      MOVS     r2,#4
        0x00000b3e:    2108        .!      MOVS     r1,#8
        0x00000b40:    2000        .       MOVS     r0,#0
        0x00000b42:    f000f96f    ..o.    BL       PAN216_ResetRegBits ; 0xe24
        0x00000b46:    e004        ..      B        0xb52 ; PAN216_EnableTxNoAck + 78
;;;617            }
;;;618            else
;;;619            {
;;;620                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
        0x00000b48:    2204        ."      MOVS     r2,#4
        0x00000b4a:    2108        .!      MOVS     r1,#8
        0x00000b4c:    2000        .       MOVS     r0,#0
        0x00000b4e:    f000faa0    ....    BL       PAN216_SetRegBits ; 0x1092
        0x00000b52:    2800        .(      CMP      r0,#0
        0x00000b54:    d106        ..      BNE      0xb64 ; PAN216_EnableTxNoAck + 96
;;;621            }
;;;622            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
        0x00000b56:    2202        ."      MOVS     r2,#2
        0x00000b58:    2107        .!      MOVS     r1,#7
        0x00000b5a:    2000        .       MOVS     r0,#0
        0x00000b5c:    f000f962    ..b.    BL       PAN216_ResetRegBits ; 0xe24
        0x00000b60:    2800        .(      CMP      r0,#0
        0x00000b62:    d000        ..      BEQ      0xb66 ; PAN216_EnableTxNoAck + 98
        0x00000b64:    2001        .       MOVS     r0,#1
;;;623        }
;;;624    
;;;625        return PAN216_OK;
;;;626    }
        0x00000b66:    bd10        ..      POP      {r4,pc}
    i.PAN216_EnableWhiten
    PAN216_EnableWhiten
;;;627    
;;;628    /**
;;;629     * @brief After receiving a packet, reads the TxNoack bit of a enhanced shockburst packet
;;;630     *
;;;631     * @return uint8_t  1 : rx need ack
;;;632     *                  0 : rx need no ack
;;;633     */
;;;634    uint8_t PAN216_ReadTxNoackBit(void)
;;;635    {
;;;636        return !(PAN216_ReadReg(0x7D) & BIT6);
;;;637    }
;;;638    
;;;639    PAN216_Err_t PAN216_SetAckPipe(uint8_t pipe)
;;;640    {
;;;641        if (pipe > 5)
;;;642        {
;;;643            return PAN216_ERR;
;;;644        }
;;;645    
;;;646        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, pipe, 0x07));
;;;647    
;;;648        return PAN216_OK;
;;;649    }
;;;650    
;;;651    /**
;;;652     * @brief Enable CRC calculation for address field in PAN216.
;;;653     *
;;;654     * This function allows enabling or disabling
;;;655     *  CRC calculation for the address field in PAN216.
;;;656     *
;;;657     * @note By default, address field is not included in CRC calculation.
;;;658     *
;;;659     * @param[in] NewState Boolean value indicating whether to enable or disable CRC calculation for
;;;660     * address field.
;;;661     *
;;;662     * @return Result of the operation:
;;;663     *         - PAN216_OK
;;;664     *         - PAN216_ERR
;;;665     */
;;;666    PAN216_Err_t PAN216_CrcSkipAddr(bool exclude)
;;;667    {
;;;668        if (exclude)
;;;669        {
;;;670            return PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;671        }
;;;672        else
;;;673        {
;;;674            return PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;675        }
;;;676    }
;;;677    
;;;678    /**
;;;679     * @brief whiten(scramble) configurations
;;;680     * @param addr_excluded  whiten exclude access address(already include header, payload, crc)
;;;681     * @param initital_phase initital whiten phase
;;;682     *        - channel 37: 0x53
;;;683              - channel 38: 0x33
;;;684              - channel 39: 0x73
;;;685     * @return PAN216_Err_t
;;;686     */
;;;687    PAN216_Err_t PAN216_WhiteSkipAddr(bool addr_excluded)
;;;688    {
;;;689        PAN216_Err_t ret;
;;;690    
;;;691        if (addr_excluded)
;;;692        {
;;;693            ret = PAN216_SetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;694        }
;;;695        else
;;;696        {
;;;697            ret = PAN216_ResetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;698        }
;;;699    
;;;700        return ret;
;;;701    }
;;;702    
;;;703    /**
;;;704     * @brief
;;;705     *
;;;706     * @param Endian
;;;707     * @return uint8_t
;;;708     */
;;;709    PAN216_Err_t PAN216_SetEndian(PAN216_Endian_t Endian)
;;;710    {
;;;711    
;;;712        if (Endian == PAN216_ENDIAN_LITTLE)
;;;713        {
;;;714            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 1,
;;;715                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;716        }
;;;717        else
;;;718        {
;;;719            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 0,
;;;720                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;721        }
;;;722    
;;;723        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Endian, WMODE_CFG0_ENDIAN));
;;;724    
;;;725        return PAN216_OK;
;;;726    }
;;;727    
;;;728    PAN216_Err_t PAN216_EnableWhiten(bool NewState)
;;;729    {
        0x00000b68:    b510        ..      PUSH     {r4,lr}
        0x00000b6a:    2800        .(      CMP      r0,#0
;;; ..\..\..\..\radio\pan216_ext.c (729)
        0x00000b6c:    d005        ..      BEQ      0xb7a ; PAN216_EnableWhiten + 18
;;;730        if (NewState)
;;;731        {
;;;732            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_SCR_ENABLE));
        0x00000b6e:    2208        ."      MOVS     r2,#8
        0x00000b70:    2107        .!      MOVS     r1,#7
        0x00000b72:    2000        .       MOVS     r0,#0
        0x00000b74:    f000fa8d    ....    BL       PAN216_SetRegBits ; 0x1092
        0x00000b78:    e004        ..      B        0xb84 ; PAN216_EnableWhiten + 28
        0x00000b7a:    2208        ."      MOVS     r2,#8
        0x00000b7c:    2107        .!      MOVS     r1,#7
        0x00000b7e:    2000        .       MOVS     r0,#0
        0x00000b80:    f000f950    ..P.    BL       PAN216_ResetRegBits ; 0xe24
        0x00000b84:    2800        .(      CMP      r0,#0
        0x00000b86:    d000        ..      BEQ      0xb8a ; PAN216_EnableWhiten + 34
;;;733        }
;;;734        else
;;;735        {
;;;736            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_SCR_ENABLE));
        0x00000b88:    2001        .       MOVS     r0,#1
;;;737        }
;;;738    
;;;739        return PAN216_OK;
;;;740    }
        0x00000b8a:    bd10        ..      POP      {r4,pc}
    i.PAN216_FactoryCalibration
    PAN216_FactoryCalibration
;;; ..\..\..\..\radio\pan216.c
;;;18     {
        0x00000b8c:    b57c        |.      PUSH     {r2-r6,lr}
;;;19         uint8_t val[6] = {0};
        0x00000b8e:    2000        .       MOVS     r0,#0
        0x00000b90:    9000        ..      STR      r0,[sp,#0]
;;;20     
;;;21         PAN216_WriteRegUnchecked(0x73, 0x01);
        0x00000b92:    9001        ..      STR      r0,[sp,#4]
        0x00000b94:    2101        .!      MOVS     r1,#1
        0x00000b96:    2073        s       MOVS     r0,#0x73
        0x00000b98:    f000fcc8    ....    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;22         val[2] = Factory_Read(0x02);
        0x00000b9c:    2002        .       MOVS     r0,#2
        0x00000b9e:    f7fffe29    ..).    BL       Factory_Read ; 0x7f4
        0x00000ba2:    4669        iF      MOV      r1,sp
        0x00000ba4:    7088        .p      STRB     r0,[r1,#2]
        0x00000ba6:    4604        .F      MOV      r4,r0
;;;23         val[5] = Factory_Read(0x05);
        0x00000ba8:    2005        .       MOVS     r0,#5
        0x00000baa:    f7fffe23    ..#.    BL       Factory_Read ; 0x7f4
        0x00000bae:    4669        iF      MOV      r1,sp
        0x00000bb0:    7148        Hq      STRB     r0,[r1,#5]
;;;24     if ((val[5] >> 6) != 2 || (val[2] & 0x0F) != 5)
        0x00000bb2:    0980        ..      LSRS     r0,r0,#6
        0x00000bb4:    2802        .(      CMP      r0,#2
        0x00000bb6:    d103        ..      BNE      0xbc0 ; PAN216_FactoryCalibration + 52
        0x00000bb8:    0720         .      LSLS     r0,r4,#28
        0x00000bba:    0f00        ..      LSRS     r0,r0,#28
        0x00000bbc:    2805        .(      CMP      r0,#5
        0x00000bbe:    d00b        ..      BEQ      0xbd8 ; PAN216_FactoryCalibration + 76
;;;25         {
;;;26             PAN216_SetPage(1);
        0x00000bc0:    2001        .       MOVS     r0,#1
        0x00000bc2:    f000fa5d    ..].    BL       PAN216_SetPage ; 0x1080
;;;27             PAN216_WriteReg(0x05, 0x01);
        0x00000bc6:    2101        .!      MOVS     r1,#1
        0x00000bc8:    2005        .       MOVS     r0,#5
        0x00000bca:    f000fc4f    ..O.    BL       PAN216_WriteReg ; 0x146c
;;;28             PAN216_SetPage(0);
        0x00000bce:    2000        .       MOVS     r0,#0
        0x00000bd0:    f000fa56    ..V.    BL       PAN216_SetPage ; 0x1080
;;;29             return PAN216_ERR;
        0x00000bd4:    2001        .       MOVS     r0,#1
        0x00000bd6:    bd7c        |.      POP      {r2-r6,pc}
;;;30         }
;;;31     
;;;32         val[1] = Factory_Read(0x01);
        0x00000bd8:    2001        .       MOVS     r0,#1
        0x00000bda:    f7fffe0b    ....    BL       Factory_Read ; 0x7f4
        0x00000bde:    4669        iF      MOV      r1,sp
        0x00000be0:    7048        Hp      STRB     r0,[r1,#1]
        0x00000be2:    4604        .F      MOV      r4,r0
;;;33         val[3] = Factory_Read(0x03);
        0x00000be4:    2003        .       MOVS     r0,#3
        0x00000be6:    f7fffe05    ....    BL       Factory_Read ; 0x7f4
        0x00000bea:    4669        iF      MOV      r1,sp
        0x00000bec:    70c8        .p      STRB     r0,[r1,#3]
        0x00000bee:    4605        .F      MOV      r5,r0
;;;34         val[4] = Factory_Read(0x04);
        0x00000bf0:    2004        .       MOVS     r0,#4
        0x00000bf2:    f7fffdff    ....    BL       Factory_Read ; 0x7f4
        0x00000bf6:    4669        iF      MOV      r1,sp
        0x00000bf8:    7108        .q      STRB     r0,[r1,#4]
;;;35     
;;;36         PAN216_SetPage(1);
        0x00000bfa:    2001        .       MOVS     r0,#1
        0x00000bfc:    f000fa40    ..@.    BL       PAN216_SetPage ; 0x1080
;;;37         /* Recover cons_reg_en here */
;;;38         PAN216_WriteReg(0x05, 0x01);
        0x00000c00:    2101        .!      MOVS     r1,#1
        0x00000c02:    2005        .       MOVS     r0,#5
        0x00000c04:    f000fc32    ..2.    BL       PAN216_WriteReg ; 0x146c
        0x00000c08:    4621        !F      MOV      r1,r4
;;;39         /* LDO_ANA_TRIM: 0x01[7:4]->P1 0x48[7:4] */
;;;40         /* LDO_RFFE_TRIM: 0x01[4:0]->P1 0x48[4:0] */
;;;41         PAN216_WriteReg(0x48, val[1]);
        0x00000c0a:    2048        H       MOVS     r0,#0x48
        0x00000c0c:    f000fc2e    ....    BL       PAN216_WriteReg ; 0x146c
;;;42         /* IPOLY_TRIM: 0x02[7:5]->P1 0x47[6:4] */
;;;43         PAN216_WriteRegBits(0x47, (val[2] >> 5) & 0x07, BITMASK_6_4);
        0x00000c10:    4669        iF      MOV      r1,sp
        0x00000c12:    788c        .x      LDRB     r4,[r1,#2]
        0x00000c14:    2270        p"      MOVS     r2,#0x70
        0x00000c16:    0961        a.      LSRS     r1,r4,#5
        0x00000c18:    2047        G       MOVS     r0,#0x47
        0x00000c1a:    f000fc59    ..Y.    BL       PAN216_WriteRegBits ; 0x14d0
;;;44         /* LDO_HP_TRIM[3:0]: 0x03[3:0] -> P1 0x4C[3:0] */
;;;45         PAN216_WriteRegBits(0x4c, val[3] & 0x0f, BITMASK_4_0);
        0x00000c1e:    0729        ).      LSLS     r1,r5,#28
        0x00000c20:    0f09        ..      LSRS     r1,r1,#28
        0x00000c22:    221f        ."      MOVS     r2,#0x1f
        0x00000c24:    204c        L       MOVS     r0,#0x4c
        0x00000c26:    f000fc53    ..S.    BL       PAN216_WriteRegBits ; 0x14d0
;;;46         /* FSYNVCO[4]*/
;;;47         if ((val[2] & BIT4) == 0)
        0x00000c2a:    06e0        ..      LSLS     r0,r4,#27
        0x00000c2c:    d401        ..      BMI      0xc32 ; PAN216_FactoryCalibration + 166
;;;48         {
;;;49             PAN216_WriteReg(0x43, 0x11);
        0x00000c2e:    2111        .!      MOVS     r1,#0x11
        0x00000c30:    e000        ..      B        0xc34 ; PAN216_FactoryCalibration + 168
;;;50         }
;;;51         else
;;;52         {
;;;53             PAN216_WriteReg(0x43, 0x10);
        0x00000c32:    2110        .!      MOVS     r1,#0x10
        0x00000c34:    2043        C       MOVS     r0,#0x43
        0x00000c36:    f000fc19    ....    BL       PAN216_WriteReg ; 0x146c
;;;54         }
;;;55         PAN216_SetPage(0);
        0x00000c3a:    2000        .       MOVS     r0,#0
        0x00000c3c:    f000fa20    .. .    BL       PAN216_SetPage ; 0x1080
;;;56         /* VBG_TRIM_3V: 0x04[7:4]->P0 0x05[3:0] */
;;;57         /* LP_VREF_TRIM[3:0]: 0x03[7:4] -> P0 0x05[7:4] */
;;;58         PAN216_WriteReg(0x05, (val[3] & 0xF0) | (val[4] >> 4) & 0x0F);
        0x00000c40:    4668        hF      MOV      r0,sp
        0x00000c42:    78c0        .x      LDRB     r0,[r0,#3]
        0x00000c44:    0901        ..      LSRS     r1,r0,#4
        0x00000c46:    4668        hF      MOV      r0,sp
        0x00000c48:    7900        .y      LDRB     r0,[r0,#4]
        0x00000c4a:    0109        ..      LSLS     r1,r1,#4
        0x00000c4c:    0900        ..      LSRS     r0,r0,#4
        0x00000c4e:    4301        .C      ORRS     r1,r1,r0
        0x00000c50:    2005        .       MOVS     r0,#5
        0x00000c52:    f000fc0b    ....    BL       PAN216_WriteReg ; 0x146c
;;;59         return PAN216_OK;
        0x00000c56:    2000        .       MOVS     r0,#0
;;;60     }
        0x00000c58:    bd7c        |.      POP      {r2-r6,pc}
    i.PAN216_FinishCalibration
    PAN216_FinishCalibration
;;;61     
;;;62     /**
;;;63      * @brief Initialize the PAN216 transceiver from Deep Sleep Mode to STB3 Mode.
;;;64      *
;;;65      * @return PAN216_Err_t
;;;66      */
;;;67     PAN216_Err_t PAN216_Init(void)
;;;68     {
;;;69         PAN216_Err_t ret = PAN216_OK;
;;;70         const uint8_t gPAN216Page0Table[][2] = {PAN216_PAGE0TABLE};
;;;71         const uint8_t gPAN216Page1Table[][2] = {PAN216_PAGE1TABLE};
;;;72     
;;;73         /* Set Page 0 */
;;;74         PAN216_WriteRegUnchecked(0x00, 0x00);
;;;75     
;;;76         /* Initialize the SPI/IIC interface */
;;;77     #if (INTERFACE_MODE == USE_SPI_3LINE)
;;;78         PAN216_WriteRegUnchecked(SPI_CFG, 0x83);
;;;79         PAN216_WriteRegUnchecked(SYS_CFG, 0x02);
;;;80     #elif (INTERFACE_MODE == USE_I2C)
;;;81         /* Reset IIC in case of SDA of PAN216 is stuck at low */
;;;82         Pan216_Funs.i2c_reset();
;;;83     #endif
;;;84     #if INTERFACE_MODE == USE_SPI_4LINE
;;;85         PAN216_WriteRegUnchecked(SPI_CFG, 0x03);
;;;86         PAN216_WriteRegUnchecked(SYS_CFG, 0x03);
;;;87     #endif
;;;88         /* Enter STB1 Mode */
;;;89         P_ASSERT(PAN216_WriteReg(0x02, 0x02));
;;;90     
;;;91         /* Turn on EN_LS, POR_NRSTL, iso_to_0*/
;;;92         P_ASSERT(PAN216_WriteReg(0x02, 0x72));
;;;93     
;;;94         /* Wait for LDO to be stable*/
;;;95         Pan216_Funs.delayus(200);
;;;96     
;;;97     #if (XTAL_FREQ == XTAL_FREQ_16M)
;;;98         /* Set 16M crystal */
;;;99         PAN216_WriteReg(0x37, 0xE0); // This register is also configured in PAN216_SetDataRate()
;;;100        PAN216_SetPage(1);
;;;101        // PAN216_WriteReg(0x3f, 0xd4); // bit3:0 -> 4 default
;;;102        // PAN216_WriteReg(0x40, 0x28); // bit3 -> 1 default
;;;103        PAN216_WriteReg(0x41, 0xA6); // bit2 -> 1
;;;104    #else
;;;105        /* Set 32M crystal by default */
;;;106        PAN216_SetPage(1);
;;;107        PAN216_WriteReg(0x3f, 0xD2);
;;;108        PAN216_WriteReg(0x40, 0x20);
;;;109        PAN216_WriteReg(0x41, 0xA2);
;;;110    #endif
;;;111    
;;;112        /* Enter STB2 Mode */
;;;113        P_ASSERT(PAN216_WriteReg(0x02, 0x73));
;;;114    
;;;115        /* Wait for FSYNXO_CLKRDY, then turn off FSYNXO_STARTUP_FAST */
;;;116        while ((PAN216_ReadReg(0x6f) & BIT7) != BIT7)
;;;117            ;
;;;118        PAN216_WriteReg(0x4c, 0x68);
;;;119        
;;;120        /* Reset cons_reg_en, recover it later in PAN216_FactoryCalibration() */
;;;121        PAN216_WriteReg(0x05, 0x00);
;;;122    
;;;123        /* Enter STB3 Mode */
;;;124        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;125    
;;;126        /* Write preconfigured registers on Page 1 */
;;;127        for (int i = 0; i < (sizeof(gPAN216Page1Table) / sizeof(gPAN216Page1Table[0])); i++)
;;;128        {
;;;129            PAN216_WriteReg(gPAN216Page1Table[i][0], gPAN216Page1Table[i][1]);
;;;130        }
;;;131    
;;;132        PAN216_SetPage(0);
;;;133        /* Write preconfigured registers on Page 0 */
;;;134        for (int i = 0; i < (sizeof(gPAN216Page0Table) / sizeof(gPAN216Page0Table[0])); i++)
;;;135        {
;;;136            PAN216_WriteReg(gPAN216Page0Table[i][0], gPAN216Page0Table[i][1]);
;;;137        }
;;;138    
;;;139        (PAN216_FactoryCalibration());
;;;140    
;;;141    #if EASY_RF
;;;142        PAN216_Calibration();
;;;143        PAN216_FinishCalibration();
;;;144        if (EASY_RF_TxPower == PAN216_TXPWR_0dBm_LOWPWR || EASY_RF_TxPower == PAN216_TXPWR_n4dBm)
;;;145        {
;;;146            PAN216_SetPage(1);
;;;147            uint8_t tmp = PAN216_ReadReg(0x48);
;;;148            PAN216_WriteReg(0x48, (tmp & 0xF0) | 0x0C);
;;;149            PAN216_SetPage(0);
;;;150        }
;;;151    #else
;;;152        /* If EASY_RF is not defined, the user should call PAN216_SetUpConfig() to set the
;;;153         * configuration. PAN216_Calibration() will be called inside PAN216_SetUpConfig() to make
;;;154         * sure PAN216 works properly. Refer to PAN216_SetDataRate() for more details.
;;;155         */
;;;156    #endif
;;;157        return ret;
;;;158    }
;;;159    
;;;160    
;;;161    
;;;162    /**
;;;163     * @brief This function is used to calibrate the PAN216 transceiver after the ChipMode and DataRate
;;;164     * are set. The calibration process includes VCO, TP, BW, and DCOC calibration.
;;;165     * @note It should be called every time the transceiver is powered up from deep sleep mode. Going to
;;;166     *      Sleep Mode and waking up does not require calibration.
;;;167     */
;;;168    void PAN216_Calibration(void)
;;;169    {
;;;170        /* Set Page 1 */
;;;171        PAN216_WriteReg(0x00, 0x01);
;;;172        /* Start VCO calibration */
;;;173        PAN216_WriteReg(0x1b, BIT3);
;;;174        /* Wait for VCO calibration to complete, 30 (32M Crystal)/ 48 (16M Crystal) us minimum */
;;;175        Pan216_Funs.delayus(300);
;;;176        // while (((PAN216_ReadReg(0x70) & BIT6) != BIT6))
;;;177        //     ;
;;;178        /* Start TP calibration */
;;;179        PAN216_WriteReg(0x1b, BIT4);
;;;180        /* Wait for TP calibration to complete, 44 ms minimum */
;;;181        Pan216_Funs.delayms(55);
;;;182        /* Enter RX mode */
;;;183        PAN216_WriteReg(0x02, 0x76);
;;;184        Pan216_Funs.delayus(200);
;;;185        /* Start Offset calibration */
;;;186        PAN216_WriteReg(0x1b, BIT5);
;;;187        /* Wait for Offset calibration to complete, 370 (32M Crystal)/ 590 (16M Crystal) us minimum */
;;;188        Pan216_Funs.delayus(700);
;;;189        // while (((PAN216_ReadReg(0x7f) & BIT7) != BIT7));
;;;190        /* Start BW calibration */
;;;191        PAN216_WriteReg(0x1b, BIT6);
;;;192        /* Wait for BW calibration to complete, 340 us minimum */
;;;193        Pan216_Funs.delayus(400);
;;;194        // while (((PAN216_ReadReg(0x6d) & BIT7) != BIT7))
;;;195        //     ;
;;;196        /* Start DCOC calibration */
;;;197        PAN216_WriteReg(0x1b, BIT7);
;;;198        /* Wait for DCOC calibration to complete, 1030 us minimum */
;;;199        Pan216_Funs.delayus(1100);
;;;200        // while (((PAN216_ReadReg(0x7f) & BIT7) != BIT7))
;;;201        //  ;
;;;202    }
;;;203    
;;;204    void PAN216_FinishCalibration(void)
;;;205    {
        0x00000c5a:    b510        ..      PUSH     {r4,lr}
;;;206        /* Stop DCOC calibration */
;;;207        PAN216_WriteReg(0x1b, 0x00);
        0x00000c5c:    2100        .!      MOVS     r1,#0
        0x00000c5e:    201b        .       MOVS     r0,#0x1b
        0x00000c60:    f000fc04    ....    BL       PAN216_WriteReg ; 0x146c
;;;208    
;;;209        /* Enter STB3 mode */
;;;210        PAN216_WriteReg(0x02, 0x74);
        0x00000c64:    2174        t!      MOVS     r1,#0x74
        0x00000c66:    2002        .       MOVS     r0,#2
        0x00000c68:    f000fc00    ....    BL       PAN216_WriteReg ; 0x146c
;;;211        /* Set Page 0 */
;;;212        PAN216_WriteReg(0x00, 0x00);
        0x00000c6c:    2100        .!      MOVS     r1,#0
        0x00000c6e:    4608        .F      MOV      r0,r1
        0x00000c70:    f000fbfc    ....    BL       PAN216_WriteReg ; 0x146c
;;;213    }
        0x00000c74:    bd10        ..      POP      {r4,pc}
    i.PAN216_GetIRQFlags
    PAN216_GetIRQFlags
;;;214    
;;;215    /**
;;;216     * @brief Enter Sleep Mode from Standby Mode
;;;217     *
;;;218     * @return PAN216_Err_t
;;;219     */
;;;220    PAN216_Err_t PAN216_EnterSleep(void)
;;;221    {
;;;222        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;223    #if INTERFACE_MODE == USE_I2C
;;;224        P_ASSERT(PAN216_WriteReg(0x02, 0x71));
;;;225    #else
;;;226        P_ASSERT(PAN216_WriteReg(0x02, 0x21));
;;;227    #endif
;;;228    
;;;229        return PAN216_OK;
;;;230    }
;;;231    
;;;232    /**
;;;233     * @brief Exit Sleep Mode and enter Standby Mode
;;;234     *
;;;235     * @return PAN216_Err_t
;;;236     */
;;;237    PAN216_Err_t PAN216_ExitSleep(void)
;;;238    {
;;;239        P_ASSERT(PAN216_WriteReg(0x02, 0x22)); // stb1
;;;240        P_ASSERT(PAN216_WriteReg(0x02, 0x74)); // stb3
;;;241        Pan216_Funs.delayus(500);              // waiting for CLKRDY, 440us(32M)
;;;242    
;;;243        return PAN216_OK;
;;;244    }
;;;245    
;;;246    /**
;;;247     * @brief Exit the TX state and enter standby mode. Make sure IRQ is cleared before calling this
;;;248     * function
;;;249     *
;;;250     * @param None
;;;251     *
;;;252     * @return Result of the operation
;;;253     *         - PAN216_OK
;;;254     *         - PAN216_ERR
;;;255     */
;;;256    PAN216_Err_t PAN216_ExitTxMode(void)
;;;257    {
;;;258        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;259    
;;;260        return PAN216_OK;
;;;261    }
;;;262    
;;;263    /**
;;;264     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;265     * function
;;;266     *
;;;267     * @param None
;;;268     *
;;;269     * @return Result of the operation
;;;270     *         - PAN216_OK
;;;271     *         - PAN216_ERR
;;;272     */
;;;273    PAN216_Err_t PAN216_ExitRxMode(void)
;;;274    {
;;;275        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;276    
;;;277        return PAN216_OK;
;;;278    }
;;;279    
;;;280    /**
;;;281     * @brief Prepares the PAN216 transceiver to enter TX or RX mode.
;;;282     *
;;;283     * This function configures the transceiver to switch between TX and RX modes. It sets the
;;;284     * appropriate registers to ensure the transceiver is ready for transmission or reception.
;;;285     * If the transceiver is already in the desired mode, this function does nothing.
;;;286     *
;;;287     * @param mode The desired mode to set, either PAN216_TX or PAN216_RX.
;;;288     *
;;;289     * @return PAN216_Err_t Result of the operation
;;;290     *         - PAN216_OK: Operation was successful
;;;291     *         - PAN216_ERR: Operation failed
;;;292     */
;;;293    PAN216_Err_t PAN216_PrepareTRxWithAck(PAN216_TRXMode_t Mode, bool EnAck)
;;;294    {
;;;295        if (EnAck == true)
;;;296        {
;;;297            /* Uses Tx confiruration if ACK is enabled */
;;;298            Mode = PAN216_TX;
;;;299        }
;;;300    
;;;301        if (Mode == PAN216_TX)
;;;302        {
;;;303            PAN216_WriteReg(0x00, 0x01);
;;;304            PAN216_WriteReg(0x42, 0xa4);
;;;305            PAN216_WriteReg(0x00, 0x00);
;;;306        }
;;;307        else if (Mode == PAN216_RX)
;;;308        {
;;;309            PAN216_WriteReg(0x00, 0x01);
;;;310            PAN216_WriteReg(0x42, 0xa0);
;;;311            PAN216_WriteReg(0x00, 0x00);
;;;312        }
;;;313    
;;;314        return PAN216_OK;
;;;315    }
;;;316    
;;;317    /**
;;;318     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;319     * function
;;;320     *
;;;321     * @return PAN216_Err_t
;;;322     */
;;;323    PAN216_Err_t PAN216_TxStart(void)
;;;324    {
;;;325        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;326        P_ASSERT(PAN216_WriteReg(0x02, 0x75));
;;;327    
;;;328        return PAN216_OK;
;;;329    }
;;;330    
;;;331    /**
;;;332     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;333     function
;;;334    
;;;335     *
;;;336     * @return PAN216_Err_t
;;;337     */
;;;338    PAN216_Err_t PAN216_RxStart(void)
;;;339    {
;;;340        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;341        P_ASSERT(PAN216_WriteReg(0x02, 0x76));
;;;342    
;;;343        return PAN216_OK;
;;;344    }
;;;345    
;;;346    /**
;;;347     * @brief Sets the frequency channel of the PAN216 transceiver
;;;348     *
;;;349     * @param Channel The desired radio frequency channel, as a value from 0 to 83
;;;350     *
;;;351     * @note The actual frequency will be (2400 + Channel)MHz
;;;352     * @note The PLOS_CNT[7:4] bits of the OBSERVER_TX register will be reset
;;;353     *
;;;354     * @return uint8_t Result of the operation
;;;355     *         - PAN216_OK
;;;356     *         - PAN216_ERR
;;;357     */
;;;358    PAN216_Err_t PAN216_SetChannel(uint8_t Channel)
;;;359    {
;;;360        return PAN216_WriteReg(REG_P0_0X39, Channel);
;;;361    }
;;;362    
;;;363    /**
;;;364     * @brief Sets the address width of the PAN216 transceiver
;;;365     *
;;;366     * This function is used to set the RX/TX address field width of the PAN216 transceiver.
;;;367     * The address width is specified as a value between 3 and 5.
;;;368     *
;;;369     * @param AddrWidth The desired address width, as a value from 3 to 5
;;;370     *          - 00 2bytes
;;;371     *          - 01 3bytes
;;;372     *          - 10 4bytes
;;;373     *          - 11 5bytes
;;;374     * @return uint8_t Result of the operation
;;;375     *         - PAN216_OK
;;;376     *         - PAN216_ERR
;;;377     */
;;;378    PAN216_Err_t PAN216_SetAddrWidth(PAN216_AddrWidth_t AddrWidth)
;;;379    {
;;;380        P_ASSERT(PAN216_WriteRegBits(WMODE_CFG1, AddrWidth - 2, WMODE_CFG1_ADDR_BYTE_LENGTH));
;;;381    
;;;382        return PAN216_OK;
;;;383    }
;;;384    
;;;385    /**
;;;386     * @brief Set static RX address for a specified pipe
;;;387     *
;;;388     * @param Pipe - pipe to configure address, one of PAN216_Pipe_t values
;;;389     * @param Addr - pointer to the buffer with address
;;;390     * @param len - length of address
;;;391     * @note Pipe can be a number from 0 to 5 (RX pipes)
;;;392     * @note Buffer length must be equal to current address width of transceiver
;;;393     * @note For pipes[2..5] only the first byte of address will be written because other bytes of
;;;394     * address equals to pipe1
;;;395     * @note For pipes[2..5] only the first byte of address will be written because pipes 1-5 share the
;;;396     * four most significant address bytes
;;;397     * @return uint8_t Result of the operation
;;;398     *         - PAN216_OK
;;;399     *         - PAN216_ERR
;;;400     */
;;;401    PAN216_Err_t PAN216_SetRxAddr(PAN216_Pipe_t Pipe, uint8_t *Addr, uint8_t len)
;;;402    {
;;;403    
;;;404        switch (Pipe)
;;;405        {
;;;406        case PAN216_PIPE0:
;;;407            P_ASSERT(PAN216_WriteRegs(PIPE0_RXADDR0_CFG, Addr, len));
;;;408            break;
;;;409        case PAN216_PIPE1:
;;;410            P_ASSERT(PAN216_WriteRegs(PIPE1_RXADDR0_CFG, Addr, len));
;;;411            break;
;;;412        case PAN216_PIPE2:
;;;413            P_ASSERT(PAN216_WriteReg(PIPE2_RXADDR0_CFG, Addr[0]));
;;;414            break;
;;;415        case PAN216_PIPE3:
;;;416            P_ASSERT(PAN216_WriteReg(PIPE3_RXADDR0_CFG, Addr[0]));
;;;417            break;
;;;418        case PAN216_PIPE4:
;;;419            P_ASSERT(PAN216_WriteReg(PIPE4_RXADDR0_CFG, Addr[0]));
;;;420            break;
;;;421        case PAN216_PIPE5:
;;;422            P_ASSERT(PAN216_WriteReg(PIPE5_RXADDR0_CFG, Addr[0]));
;;;423            break;
;;;424        default:
;;;425            return PAN216_ERR;
;;;426        }
;;;427    
;;;428        return PAN216_OK;
;;;429    }
;;;430    
;;;431    /**
;;;432     * @brief Set static TX address for the transceiver
;;;433     *
;;;434     * @param Addr Pointer to the buffer with address
;;;435     * @param AddrWidth TX address field width, value from 3 to 5
;;;436     * @return uint8_t Result of the operation
;;;437     *         - PAN216_OK
;;;438     *         - PAN216_ERR
;;;439     */
;;;440    PAN216_Err_t PAN216_SetTxAddr(uint8_t *Addr, uint8_t len)
;;;441    {
;;;442        return PAN216_WriteRegs(TXADDR0_CFG, Addr, len);
;;;443    }
;;;444    
;;;445    /**
;;;446     * @brief Get the pipe number for the payload available for reading from RX FIFO
;;;447     *
;;;448     * @return uint8_t Pipe number or 0xFF if the RX FIFO is empty
;;;449     *         - 0x00: Pipe 0
;;;450     *         - 0x01: Pipe 1
;;;451     *         - 0x02: Pipe 2
;;;452     *         - 0x03: Pipe 3
;;;453     *         - 0x04: Pipe 4
;;;454     *         - 0x05: Pipe 5
;;;455     * @return uint8_t Result of the operation
;;;456     *         - PAN216_OK
;;;457     *         - PAN216_ERR
;;;458     */
;;;459    PAN216_Pipe_t PAN216_GetRxPipeNum(void)
;;;460    {
;;;461        uint8_t pipeNum = (PAN216_ReadReg(STATUS0) >> 4) & 0x07;
;;;462    
;;;463        return (PAN216_Pipe_t)pipeNum;
;;;464    }
;;;465    
;;;466    /**
;;;467     * @brief Get pending IRQ flags
;;;468     *
;;;469     * @return Current status of RX_DONE, TX_DONE, RX_TIMEOUT, and MAX_RT bits of the STATUS register
;;;470     */
;;;471    uint8_t PAN216_GetIRQFlags(void)
;;;472    {
        0x00000c76:    b510        ..      PUSH     {r4,lr}
;;;473        return PAN216_ReadReg(RFIRQFLG);
        0x00000c78:    2073        s       MOVS     r0,#0x73
        0x00000c7a:    f000f8c6    ....    BL       PAN216_ReadReg ; 0xe0a
;;;474    }
        0x00000c7e:    bd10        ..      POP      {r4,pc}
    i.PAN216_Init
    PAN216_Init
;;; ..\..\..\..\radio\pan216.c (68)
        0x00000c80:    b570        p.      PUSH     {r4-r6,lr}
        0x00000c82:    b08c        ..      SUB      sp,sp,#0x30
;;;69         PAN216_Err_t ret = PAN216_OK;
        0x00000c84:    2600        .&      MOVS     r6,#0
;;;70         const uint8_t gPAN216Page0Table[][2] = {PAN216_PAGE0TABLE};
        0x00000c86:    2224        $"      MOVS     r2,#0x24
        0x00000c88:    4936        6I      LDR      r1,[pc,#216] ; [0xd64] = 0x1f68
        0x00000c8a:    4668        hF      MOV      r0,sp
        0x00000c8c:    f7fffac1    ....    BL       __aeabi_memcpy ; 0x212
;;;71         const uint8_t gPAN216Page1Table[][2] = {PAN216_PAGE1TABLE};
        0x00000c90:    4934        4I      LDR      r1,[pc,#208] ; [0xd64] = 0x1f68
        0x00000c92:    3908        .9      SUBS     r1,r1,#8
        0x00000c94:    c903        ..      LDM      r1,{r0,r1}
;;;72     
;;;73         /* Set Page 0 */
;;;74         PAN216_WriteRegUnchecked(0x00, 0x00);
        0x00000c96:    910a        ..      STR      r1,[sp,#0x28]
        0x00000c98:    9009        ..      STR      r0,[sp,#0x24]
        0x00000c9a:    2100        .!      MOVS     r1,#0
        0x00000c9c:    4608        .F      MOV      r0,r1
        0x00000c9e:    f000fc45    ..E.    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;75     
;;;76         /* Initialize the SPI/IIC interface */
;;;77     #if (INTERFACE_MODE == USE_SPI_3LINE)
;;;78         PAN216_WriteRegUnchecked(SPI_CFG, 0x83);
;;;79         PAN216_WriteRegUnchecked(SYS_CFG, 0x02);
;;;80     #elif (INTERFACE_MODE == USE_I2C)
;;;81         /* Reset IIC in case of SDA of PAN216 is stuck at low */
;;;82         Pan216_Funs.i2c_reset();
;;;83     #endif
;;;84     #if INTERFACE_MODE == USE_SPI_4LINE
;;;85         PAN216_WriteRegUnchecked(SPI_CFG, 0x03);
        0x00000ca2:    2103        .!      MOVS     r1,#3
        0x00000ca4:    2004        .       MOVS     r0,#4
        0x00000ca6:    f000fc41    ..A.    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;86         PAN216_WriteRegUnchecked(SYS_CFG, 0x03);
        0x00000caa:    2103        .!      MOVS     r1,#3
        0x00000cac:    4608        .F      MOV      r0,r1
        0x00000cae:    f000fc3d    ..=.    BL       PAN216_WriteRegUnchecked ; 0x152c
;;;87     #endif
;;;88         /* Enter STB1 Mode */
;;;89         P_ASSERT(PAN216_WriteReg(0x02, 0x02));
        0x00000cb2:    2102        .!      MOVS     r1,#2
        0x00000cb4:    4608        .F      MOV      r0,r1
        0x00000cb6:    f000fbd9    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000cba:    2800        .(      CMP      r0,#0
        0x00000cbc:    d131        1.      BNE      0xd22 ; PAN216_Init + 162
;;;90     
;;;91         /* Turn on EN_LS, POR_NRSTL, iso_to_0*/
;;;92         P_ASSERT(PAN216_WriteReg(0x02, 0x72));
        0x00000cbe:    2172        r!      MOVS     r1,#0x72
        0x00000cc0:    2002        .       MOVS     r0,#2
        0x00000cc2:    f000fbd3    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000cc6:    2800        .(      CMP      r0,#0
        0x00000cc8:    d12b        +.      BNE      0xd22 ; PAN216_Init + 162
;;;93     
;;;94         /* Wait for LDO to be stable*/
;;;95         Pan216_Funs.delayus(200);
        0x00000cca:    4827        'H      LDR      r0,[pc,#156] ; [0xd68] = 0x2000000c
        0x00000ccc:    6901        .i      LDR      r1,[r0,#0x10]
        0x00000cce:    20c8        .       MOVS     r0,#0xc8
        0x00000cd0:    4788        .G      BLX      r1
;;;96     
;;;97     #if (XTAL_FREQ == XTAL_FREQ_16M)
;;;98         /* Set 16M crystal */
;;;99         PAN216_WriteReg(0x37, 0xE0); // This register is also configured in PAN216_SetDataRate()
;;;100        PAN216_SetPage(1);
;;;101        // PAN216_WriteReg(0x3f, 0xd4); // bit3:0 -> 4 default
;;;102        // PAN216_WriteReg(0x40, 0x28); // bit3 -> 1 default
;;;103        PAN216_WriteReg(0x41, 0xA6); // bit2 -> 1
;;;104    #else
;;;105        /* Set 32M crystal by default */
;;;106        PAN216_SetPage(1);
        0x00000cd2:    2001        .       MOVS     r0,#1
        0x00000cd4:    f000f9d4    ....    BL       PAN216_SetPage ; 0x1080
;;;107        PAN216_WriteReg(0x3f, 0xD2);
        0x00000cd8:    21d2        .!      MOVS     r1,#0xd2
        0x00000cda:    203f        ?       MOVS     r0,#0x3f
        0x00000cdc:    f000fbc6    ....    BL       PAN216_WriteReg ; 0x146c
;;;108        PAN216_WriteReg(0x40, 0x20);
        0x00000ce0:    2120         !      MOVS     r1,#0x20
        0x00000ce2:    2040        @       MOVS     r0,#0x40
        0x00000ce4:    f000fbc2    ....    BL       PAN216_WriteReg ; 0x146c
;;;109        PAN216_WriteReg(0x41, 0xA2);
        0x00000ce8:    21a2        .!      MOVS     r1,#0xa2
        0x00000cea:    2041        A       MOVS     r0,#0x41
        0x00000cec:    f000fbbe    ....    BL       PAN216_WriteReg ; 0x146c
;;;110    #endif
;;;111    
;;;112        /* Enter STB2 Mode */
;;;113        P_ASSERT(PAN216_WriteReg(0x02, 0x73));
        0x00000cf0:    2173        s!      MOVS     r1,#0x73
        0x00000cf2:    2002        .       MOVS     r0,#2
        0x00000cf4:    f000fbba    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000cf8:    2800        .(      CMP      r0,#0
        0x00000cfa:    d112        ..      BNE      0xd22 ; PAN216_Init + 162
;;;114    
;;;115        /* Wait for FSYNXO_CLKRDY, then turn off FSYNXO_STARTUP_FAST */
;;;116        while ((PAN216_ReadReg(0x6f) & BIT7) != BIT7)
        0x00000cfc:    206f        o       MOVS     r0,#0x6f
        0x00000cfe:    f000f884    ....    BL       PAN216_ReadReg ; 0xe0a
        0x00000d02:    09c0        ..      LSRS     r0,r0,#7
        0x00000d04:    d0fa        ..      BEQ      0xcfc ; PAN216_Init + 124
;;;117            ;
;;;118        PAN216_WriteReg(0x4c, 0x68);
        0x00000d06:    2168        h!      MOVS     r1,#0x68
        0x00000d08:    204c        L       MOVS     r0,#0x4c
        0x00000d0a:    f000fbaf    ....    BL       PAN216_WriteReg ; 0x146c
;;;119        
;;;120        /* Reset cons_reg_en, recover it later in PAN216_FactoryCalibration() */
;;;121        PAN216_WriteReg(0x05, 0x00);
        0x00000d0e:    2100        .!      MOVS     r1,#0
        0x00000d10:    2005        .       MOVS     r0,#5
        0x00000d12:    f000fbab    ....    BL       PAN216_WriteReg ; 0x146c
;;;122    
;;;123        /* Enter STB3 Mode */
;;;124        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
        0x00000d16:    2174        t!      MOVS     r1,#0x74
        0x00000d18:    2002        .       MOVS     r0,#2
        0x00000d1a:    f000fba7    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000d1e:    2800        .(      CMP      r0,#0
        0x00000d20:    d002        ..      BEQ      0xd28 ; PAN216_Init + 168
        0x00000d22:    2001        .       MOVS     r0,#1
        0x00000d24:    b00c        ..      ADD      sp,sp,#0x30
        0x00000d26:    bd70        p.      POP      {r4-r6,pc}
;;;125    
;;;126        /* Write preconfigured registers on Page 1 */
;;;127        for (int i = 0; i < (sizeof(gPAN216Page1Table) / sizeof(gPAN216Page1Table[0])); i++)
        0x00000d28:    2400        .$      MOVS     r4,#0
        0x00000d2a:    ad09        ..      ADD      r5,sp,#0x24
        0x00000d2c:    0060        `.      LSLS     r0,r4,#1
        0x00000d2e:    1941        A.      ADDS     r1,r0,r5
        0x00000d30:    7849        Ix      LDRB     r1,[r1,#1]
        0x00000d32:    5c28        (\      LDRB     r0,[r5,r0]
        0x00000d34:    f000fb9a    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000d38:    1c64        d.      ADDS     r4,r4,#1
        0x00000d3a:    2c03        .,      CMP      r4,#3
        0x00000d3c:    d3f6        ..      BCC      0xd2c ; PAN216_Init + 172
;;;128        {
;;;129            PAN216_WriteReg(gPAN216Page1Table[i][0], gPAN216Page1Table[i][1]);
;;;130        }
;;;131    
;;;132        PAN216_SetPage(0);
        0x00000d3e:    2000        .       MOVS     r0,#0
        0x00000d40:    f000f99e    ....    BL       PAN216_SetPage ; 0x1080
;;;133        /* Write preconfigured registers on Page 0 */
;;;134        for (int i = 0; i < (sizeof(gPAN216Page0Table) / sizeof(gPAN216Page0Table[0])); i++)
        0x00000d44:    2400        .$      MOVS     r4,#0
        0x00000d46:    466d        mF      MOV      r5,sp
        0x00000d48:    0060        `.      LSLS     r0,r4,#1
        0x00000d4a:    1941        A.      ADDS     r1,r0,r5
        0x00000d4c:    7849        Ix      LDRB     r1,[r1,#1]
        0x00000d4e:    5c28        (\      LDRB     r0,[r5,r0]
        0x00000d50:    f000fb8c    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000d54:    1c64        d.      ADDS     r4,r4,#1
        0x00000d56:    2c12        .,      CMP      r4,#0x12
        0x00000d58:    d3f6        ..      BCC      0xd48 ; PAN216_Init + 200
;;;135        {
;;;136            PAN216_WriteReg(gPAN216Page0Table[i][0], gPAN216Page0Table[i][1]);
;;;137        }
;;;138    
;;;139        (PAN216_FactoryCalibration());
        0x00000d5a:    f7ffff17    ....    BL       PAN216_FactoryCalibration ; 0xb8c
;;;140    
;;;141    #if EASY_RF
;;;142        PAN216_Calibration();
;;;143        PAN216_FinishCalibration();
;;;144        if (EASY_RF_TxPower == PAN216_TXPWR_0dBm_LOWPWR || EASY_RF_TxPower == PAN216_TXPWR_n4dBm)
;;;145        {
;;;146            PAN216_SetPage(1);
;;;147            uint8_t tmp = PAN216_ReadReg(0x48);
;;;148            PAN216_WriteReg(0x48, (tmp & 0xF0) | 0x0C);
;;;149            PAN216_SetPage(0);
;;;150        }
;;;151    #else
;;;152        /* If EASY_RF is not defined, the user should call PAN216_SetUpConfig() to set the
;;;153         * configuration. PAN216_Calibration() will be called inside PAN216_SetUpConfig() to make
;;;154         * sure PAN216 works properly. Refer to PAN216_SetDataRate() for more details.
;;;155         */
;;;156    #endif
;;;157        return ret;
        0x00000d5e:    4630        0F      MOV      r0,r6
;;;158    }
        0x00000d60:    e7e0        ..      B        0xd24 ; PAN216_Init + 164
    $d
        0x00000d62:    0000        ..      DCW    0
        0x00000d64:    00001f68    h...    DCD    8040
        0x00000d68:    2000000c    ...     DCD    536870924
    $t
    i.PAN216_PrepareTRxWithAck
    PAN216_PrepareTRxWithAck
;;;159    
;;;160    
;;;161    
;;;162    /**
;;;163     * @brief This function is used to calibrate the PAN216 transceiver after the ChipMode and DataRate
;;;164     * are set. The calibration process includes VCO, TP, BW, and DCOC calibration.
;;;165     * @note It should be called every time the transceiver is powered up from deep sleep mode. Going to
;;;166     *      Sleep Mode and waking up does not require calibration.
;;;167     */
;;;168    void PAN216_Calibration(void)
;;;169    {
;;;170        /* Set Page 1 */
;;;171        PAN216_WriteReg(0x00, 0x01);
;;;172        /* Start VCO calibration */
;;;173        PAN216_WriteReg(0x1b, BIT3);
;;;174        /* Wait for VCO calibration to complete, 30 (32M Crystal)/ 48 (16M Crystal) us minimum */
;;;175        Pan216_Funs.delayus(300);
;;;176        // while (((PAN216_ReadReg(0x70) & BIT6) != BIT6))
;;;177        //     ;
;;;178        /* Start TP calibration */
;;;179        PAN216_WriteReg(0x1b, BIT4);
;;;180        /* Wait for TP calibration to complete, 44 ms minimum */
;;;181        Pan216_Funs.delayms(55);
;;;182        /* Enter RX mode */
;;;183        PAN216_WriteReg(0x02, 0x76);
;;;184        Pan216_Funs.delayus(200);
;;;185        /* Start Offset calibration */
;;;186        PAN216_WriteReg(0x1b, BIT5);
;;;187        /* Wait for Offset calibration to complete, 370 (32M Crystal)/ 590 (16M Crystal) us minimum */
;;;188        Pan216_Funs.delayus(700);
;;;189        // while (((PAN216_ReadReg(0x7f) & BIT7) != BIT7));
;;;190        /* Start BW calibration */
;;;191        PAN216_WriteReg(0x1b, BIT6);
;;;192        /* Wait for BW calibration to complete, 340 us minimum */
;;;193        Pan216_Funs.delayus(400);
;;;194        // while (((PAN216_ReadReg(0x6d) & BIT7) != BIT7))
;;;195        //     ;
;;;196        /* Start DCOC calibration */
;;;197        PAN216_WriteReg(0x1b, BIT7);
;;;198        /* Wait for DCOC calibration to complete, 1030 us minimum */
;;;199        Pan216_Funs.delayus(1100);
;;;200        // while (((PAN216_ReadReg(0x7f) & BIT7) != BIT7))
;;;201        //  ;
;;;202    }
;;;203    
;;;204    void PAN216_FinishCalibration(void)
;;;205    {
;;;206        /* Stop DCOC calibration */
;;;207        PAN216_WriteReg(0x1b, 0x00);
;;;208    
;;;209        /* Enter STB3 mode */
;;;210        PAN216_WriteReg(0x02, 0x74);
;;;211        /* Set Page 0 */
;;;212        PAN216_WriteReg(0x00, 0x00);
;;;213    }
;;;214    
;;;215    /**
;;;216     * @brief Enter Sleep Mode from Standby Mode
;;;217     *
;;;218     * @return PAN216_Err_t
;;;219     */
;;;220    PAN216_Err_t PAN216_EnterSleep(void)
;;;221    {
;;;222        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;223    #if INTERFACE_MODE == USE_I2C
;;;224        P_ASSERT(PAN216_WriteReg(0x02, 0x71));
;;;225    #else
;;;226        P_ASSERT(PAN216_WriteReg(0x02, 0x21));
;;;227    #endif
;;;228    
;;;229        return PAN216_OK;
;;;230    }
;;;231    
;;;232    /**
;;;233     * @brief Exit Sleep Mode and enter Standby Mode
;;;234     *
;;;235     * @return PAN216_Err_t
;;;236     */
;;;237    PAN216_Err_t PAN216_ExitSleep(void)
;;;238    {
;;;239        P_ASSERT(PAN216_WriteReg(0x02, 0x22)); // stb1
;;;240        P_ASSERT(PAN216_WriteReg(0x02, 0x74)); // stb3
;;;241        Pan216_Funs.delayus(500);              // waiting for CLKRDY, 440us(32M)
;;;242    
;;;243        return PAN216_OK;
;;;244    }
;;;245    
;;;246    /**
;;;247     * @brief Exit the TX state and enter standby mode. Make sure IRQ is cleared before calling this
;;;248     * function
;;;249     *
;;;250     * @param None
;;;251     *
;;;252     * @return Result of the operation
;;;253     *         - PAN216_OK
;;;254     *         - PAN216_ERR
;;;255     */
;;;256    PAN216_Err_t PAN216_ExitTxMode(void)
;;;257    {
;;;258        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;259    
;;;260        return PAN216_OK;
;;;261    }
;;;262    
;;;263    /**
;;;264     * @brief Exit the RX mode and enter standby mode. Make sure IRQ is cleared before calling this
;;;265     * function
;;;266     *
;;;267     * @param None
;;;268     *
;;;269     * @return Result of the operation
;;;270     *         - PAN216_OK
;;;271     *         - PAN216_ERR
;;;272     */
;;;273    PAN216_Err_t PAN216_ExitRxMode(void)
;;;274    {
;;;275        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
;;;276    
;;;277        return PAN216_OK;
;;;278    }
;;;279    
;;;280    /**
;;;281     * @brief Prepares the PAN216 transceiver to enter TX or RX mode.
;;;282     *
;;;283     * This function configures the transceiver to switch between TX and RX modes. It sets the
;;;284     * appropriate registers to ensure the transceiver is ready for transmission or reception.
;;;285     * If the transceiver is already in the desired mode, this function does nothing.
;;;286     *
;;;287     * @param mode The desired mode to set, either PAN216_TX or PAN216_RX.
;;;288     *
;;;289     * @return PAN216_Err_t Result of the operation
;;;290     *         - PAN216_OK: Operation was successful
;;;291     *         - PAN216_ERR: Operation failed
;;;292     */
;;;293    PAN216_Err_t PAN216_PrepareTRxWithAck(PAN216_TRXMode_t Mode, bool EnAck)
;;;294    {
        0x00000d6c:    b510        ..      PUSH     {r4,lr}
        0x00000d6e:    2900        .)      CMP      r1,#0
;;; ..\..\..\..\radio\pan216.c (294)
        0x00000d70:    d104        ..      BNE      0xd7c ; PAN216_PrepareTRxWithAck + 16
;;;295        if (EnAck == true)
;;;296        {
;;;297            /* Uses Tx confiruration if ACK is enabled */
;;;298            Mode = PAN216_TX;
;;;299        }
;;;300    
;;;301        if (Mode == PAN216_TX)
        0x00000d72:    2800        .(      CMP      r0,#0
        0x00000d74:    d002        ..      BEQ      0xd7c ; PAN216_PrepareTRxWithAck + 16
        0x00000d76:    2801        .(      CMP      r0,#1
        0x00000d78:    d006        ..      BEQ      0xd88 ; PAN216_PrepareTRxWithAck + 28
        0x00000d7a:    e011        ..      B        0xda0 ; PAN216_PrepareTRxWithAck + 52
;;;302        {
;;;303            PAN216_WriteReg(0x00, 0x01);
        0x00000d7c:    2101        .!      MOVS     r1,#1
        0x00000d7e:    2000        .       MOVS     r0,#0
        0x00000d80:    f000fb74    ..t.    BL       PAN216_WriteReg ; 0x146c
;;;304            PAN216_WriteReg(0x42, 0xa4);
        0x00000d84:    21a4        .!      MOVS     r1,#0xa4
;;;305            PAN216_WriteReg(0x00, 0x00);
        0x00000d86:    e004        ..      B        0xd92 ; PAN216_PrepareTRxWithAck + 38
;;;306        }
;;;307        else if (Mode == PAN216_RX)
;;;308        {
;;;309            PAN216_WriteReg(0x00, 0x01);
        0x00000d88:    2101        .!      MOVS     r1,#1
        0x00000d8a:    2000        .       MOVS     r0,#0
        0x00000d8c:    f000fb6e    ..n.    BL       PAN216_WriteReg ; 0x146c
;;;310            PAN216_WriteReg(0x42, 0xa0);
        0x00000d90:    21a0        .!      MOVS     r1,#0xa0
        0x00000d92:    2042        B       MOVS     r0,#0x42
        0x00000d94:    f000fb6a    ..j.    BL       PAN216_WriteReg ; 0x146c
;;;311            PAN216_WriteReg(0x00, 0x00);
        0x00000d98:    2100        .!      MOVS     r1,#0
        0x00000d9a:    4608        .F      MOV      r0,r1
        0x00000d9c:    f000fb66    ..f.    BL       PAN216_WriteReg ; 0x146c
;;;312        }
;;;313    
;;;314        return PAN216_OK;
        0x00000da0:    2000        .       MOVS     r0,#0
;;;315    }
        0x00000da2:    bd10        ..      POP      {r4,pc}
    i.PAN216_Read
    PAN216_Read
;;; ..\..\..\..\radio\pan216_reg.c
;;;35     {
        0x00000da4:    b5f8        ..      PUSH     {r3-r7,lr}
        0x00000da6:    4c0a        .L      LDR      r4,[pc,#40] ; [0xdd0] = 0x2000000c
;;; ..\..\..\..\radio\pan216_reg.c (35)
        0x00000da8:    4605        .F      MOV      r5,r0
        0x00000daa:    68e0        .h      LDR      r0,[r4,#0xc]
        0x00000dac:    4616        .F      MOV      r6,r2
        0x00000dae:    460f        .F      MOV      r7,r1
;;;36     #if INTERFACE_MODE == USE_I2C
;;;37         Pan216_Funs.i2c_read_buf(addr, buffer, (uint16_t)len);
;;;38     #else
;;;39         Pan216_Funs.spi_cs_low();
        0x00000db0:    4780        .G      BLX      r0
;;;40         Pan216_Funs.spi_writebyte(addr << 1);
        0x00000db2:    0668        h.      LSLS     r0,r5,#25
        0x00000db4:    6821        !h      LDR      r1,[r4,#0]
        0x00000db6:    0e00        ..      LSRS     r0,r0,#24
        0x00000db8:    4788        .G      BLX      r1
;;;41         for (int i = 0; i < len; i++)
        0x00000dba:    2500        .%      MOVS     r5,#0
        0x00000dbc:    e003        ..      B        0xdc6 ; PAN216_Read + 34
        0x00000dbe:    6860        `h      LDR      r0,[r4,#4]
        0x00000dc0:    4780        .G      BLX      r0
        0x00000dc2:    5578        xU      STRB     r0,[r7,r5]
        0x00000dc4:    1c6d        m.      ADDS     r5,r5,#1
        0x00000dc6:    42b5        .B      CMP      r5,r6
        0x00000dc8:    dbf9        ..      BLT      0xdbe ; PAN216_Read + 26
;;;42         {
;;;43             buffer[i] = Pan216_Funs.spi_readbyte();
;;;44         }
;;;45         Pan216_Funs.spi_cs_high();
        0x00000dca:    68a0        .h      LDR      r0,[r4,#8]
        0x00000dcc:    4780        .G      BLX      r0
;;;46     #endif
;;;47     }
        0x00000dce:    bdf8        ..      POP      {r3-r7,pc}
    $d
        0x00000dd0:    2000000c    ...     DCD    536870924
    $t
    i.PAN216_ReadFifo
    PAN216_ReadFifo
;;;48     
;;;49     /**
;;;50      * @brief This function writes bytes to the register
;;;51      *
;;;52      * @param[in] addr Register address
;;;53      * @param[in] buffer Buffer provided for data to write to the register
;;;54      * @param[in] len Number of bytes to write
;;;55      * @return PAN216_Err_t
;;;56      */
;;;57     static void PAN216_Write(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;58     {
;;;59     #if (INTERFACE_MODE == USE_I2C)
;;;60         Pan216_Funs.i2c_write_buf(addr, buffer, len);
;;;61     #else
;;;62         Pan216_Funs.spi_cs_low();
;;;63         Pan216_Funs.spi_writebyte(((addr << 1) | 0x01));
;;;64         for (int i = 0; i < len; i++)
;;;65         {
;;;66             Pan216_Funs.spi_writebyte(buffer[i]);
;;;67         }
;;;68         Pan216_Funs.spi_cs_high();
;;;69     #endif
;;;70     }
;;;71     
;;;72     /**************************************************************************/
;;;73     /*                         Basic Register Operation                       */
;;;74     /**************************************************************************/
;;;75     
;;;76     /**
;;;77      * @brief Read one byte from the register in the current page
;;;78      * @param[in] addr Register address to read
;;;79      * @return Value read from the register
;;;80      */
;;;81     uint8_t PAN216_ReadReg(uint8_t addr)
;;;82     {
;;;83         uint8_t tmp;
;;;84     
;;;85         PAN216_Read(addr, &tmp, 1);
;;;86     
;;;87         return tmp;
;;;88     }
;;;89     
;;;90     /**
;;;91      * @brief Write to the global register in the current page and check
;;;92      * @param[in] addr Register address to write
;;;93      * @param[in] value Value to write to the register
;;;94      * @return Result
;;;95      */
;;;96     PAN216_Err_t PAN216_WriteReg(uint8_t addr, uint8_t value)
;;;97     {
;;;98         PAN216_Write(addr, &value, 1);
;;;99     
;;;100    #if SPI_CHECK_WRITE
;;;101        uint8_t tmp;
;;;102        tmp = PAN216_ReadReg(addr);
;;;103        if (tmp != value)
;;;104        {
;;;105            printf("write reg [readback:0x%02x] writeval:0x%02x error \r\n ", tmp, value);
;;;106            return PAN216_ERR;
;;;107        }
;;;108    #endif
;;;109    
;;;110        return PAN216_OK;
;;;111    }
;;;112    
;;;113    /**
;;;114     * @brief Write to the global register in the current page without check
;;;115     * @param[in] addr Register address to write
;;;116     * @param[in] value Value to write to the register
;;;117     * @return Result
;;;118     */
;;;119    PAN216_Err_t PAN216_WriteRegUnchecked(uint8_t addr, uint8_t value)
;;;120    {
;;;121        PAN216_Write(addr, &value, 1);
;;;122        return PAN216_OK;
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief Write continuous register values (buffer) in a specific address page
;;;127     * @param[in] addr Register start address
;;;128     * @param[in] buffer Values to write
;;;129     * @param[in] len Buffer length
;;;130     * @return Result
;;;131     */
;;;132    PAN216_Err_t PAN216_WriteRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;133    {
;;;134        PAN216_Write(addr, buffer, len);
;;;135        return PAN216_OK;
;;;136    }
;;;137    
;;;138    /**
;;;139     * @brief This function reads more than one byte from the register
;;;140     *
;;;141     * @param addr Register address
;;;142     * @param buffer Buffer provided for data from the register
;;;143     * @param len Number of bytes to read
;;;144     * @return PAN216_Err_t
;;;145     */
;;;146    PAN216_Err_t PAN216_ReadRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;147    {
;;;148        PAN216_Read(addr, buffer, len);
;;;149        return PAN216_OK;
;;;150    }
;;;151    
;;;152    /**
;;;153     * @brief Transfer data to the data FIFO on the chip
;;;154     * @param[in] addr Register address to write
;;;155     * @param[in] buffer Buffer provided for data to write to the register
;;;156     * @param[in] size Number of bytes to write
;;;157     * @return Result
;;;158     */
;;;159    PAN216_Err_t PAN216_WriteFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;160    {
;;;161        return PAN216_WriteRegs(addr, buffer, size);
;;;162    }
;;;163    
;;;164    /**
;;;165     * @brief Read more than one byte from the register
;;;166     * @param[in] addr Register address to read
;;;167     * @param[in] buffer Buffer provided for data from the register
;;;168     * @param[in] size Number of bytes to read
;;;169     * @return Result
;;;170     */
;;;171    PAN216_Err_t PAN216_ReadFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;172    {
        0x00000dd4:    b510        ..      PUSH     {r4,lr}
;;;173        return PAN216_ReadRegs(addr, buffer, size);
        0x00000dd6:    f000f820    .. .    BL       PAN216_ReadRegs ; 0xe1a
;;;174    }
        0x00000dda:    bd10        ..      POP      {r4,pc}
    i.PAN216_ReadPageReg
    PAN216_ReadPageReg
;;;175    
;;;176    /**
;;;177     * @brief This function writes bits to the register by mask
;;;178     *
;;;179     * @param addr Register address
;;;180     * @param val Bits value
;;;181     * @param mask Bits mask
;;;182     * @return PAN216_Err_t
;;;183     */
;;;184    PAN216_Err_t PAN216_WriteRegBits(uint8_t addr, uint8_t val, uint8_t mask)
;;;185    {
;;;186        uint8_t tmp;
;;;187        PAN216_Err_t ret;
;;;188        uint8_t shift = GET_SHIFT(mask);
;;;189    
;;;190        val <<= shift;
;;;191        if (val & (~mask))
;;;192        {
;;;193            printf("val:0x%02x mask:0x%02x error \r\n", val, mask);
;;;194            return PAN216_ERR;
;;;195        }
;;;196        val &= mask;
;;;197    
;;;198        tmp = PAN216_ReadReg(addr);
;;;199        ret = PAN216_WriteReg(addr, (tmp & (~mask)) | val);
;;;200    
;;;201        return ret;
;;;202    }
;;;203    
;;;204    /**************************************************************************/
;;;205    /*                         Page Register Operation                        */
;;;206    /**************************************************************************/
;;;207    
;;;208    /**
;;;209     * @brief Switch page
;;;210     * @param[in] page Page to switch
;;;211     * @return Result
;;;212     */
;;;213    PAN216_Err_t PAN216_SetPage(uint8_t page)
;;;214    {
;;;215        if (PAN216_OK != PAN216_WriteReg(PAGE_CFG, page))
;;;216        {
;;;217            return PAN216_ERR;
;;;218        }
;;;219    
;;;220        return PAN216_OK;
;;;221    }
;;;222    
;;;223    /**
;;;224     * @brief This function writes a value to the register in a specific page
;;;225     * @param[in] page The page of the register
;;;226     * @param[in] addr Register address
;;;227     * @param[in] value Value to write
;;;228     * @return Result
;;;229     */
;;;230    PAN216_Err_t PAN216_WritePageReg(uint8_t page, uint8_t addr, uint8_t value)
;;;231    {
;;;232        uint8_t original_page;
;;;233    
;;;234        original_page = PAN216_ReadReg(PAGE_CFG);
;;;235        if (page != original_page)
;;;236        {
;;;237            P_ASSERT(PAN216_SetPage(page));
;;;238        }
;;;239        P_ASSERT(PAN216_WriteReg(addr, value));
;;;240        if (page != original_page)
;;;241        {
;;;242            P_ASSERT(PAN216_SetPage(original_page));
;;;243        }
;;;244    
;;;245        return PAN216_OK;
;;;246    }
;;;247    
;;;248    /**
;;;249     * @brief This function writes a value to the register in a specific page without check
;;;250     *
;;;251     * @param page Register page
;;;252     * @param addr Register address
;;;253     * @param value Register value
;;;254     * @return PAN216_Err_t
;;;255     */
;;;256    PAN216_Err_t PAN216_WritePageRegUnchecked(uint8_t page, uint8_t addr, uint8_t value)
;;;257    {
;;;258        uint8_t original_page;
;;;259    
;;;260        original_page = PAN216_ReadReg(PAGE_CFG);
;;;261        if (page != original_page)
;;;262        {
;;;263            PAN216_SetPage(page);
;;;264        }
;;;265        PAN216_Write(addr, &value, 1);
;;;266        if (page != original_page)
;;;267        {
;;;268            PAN216_SetPage(original_page);
;;;269        }
;;;270    
;;;271        return PAN216_OK;
;;;272    }
;;;273    
;;;274    /**
;;;275     * @brief Read a value from the register in a specific page
;;;276     * @param[in] page The page of the register
;;;277     * @param[in] addr Register address
;;;278     * @return Success (register value) or failure
;;;279     */
;;;280    uint8_t PAN216_ReadPageReg(uint8_t page, uint8_t addr)
;;;281    {
        0x00000ddc:    b570        p.      PUSH     {r4-r6,lr}
        0x00000dde:    4605        .F      MOV      r5,r0
        0x00000de0:    460e        .F      MOV      r6,r1
;;;282        uint8_t value;
;;;283        uint8_t original_page;
;;;284    
;;;285        original_page = PAN216_ReadReg(PAGE_CFG);
        0x00000de2:    2000        .       MOVS     r0,#0
        0x00000de4:    f000f811    ....    BL       PAN216_ReadReg ; 0xe0a
        0x00000de8:    4604        .F      MOV      r4,r0
;;;286        if (page != original_page)
        0x00000dea:    42a5        .B      CMP      r5,r4
        0x00000dec:    d002        ..      BEQ      0xdf4 ; PAN216_ReadPageReg + 24
;;;287        {
;;;288            PAN216_SetPage(page);
        0x00000dee:    4628        (F      MOV      r0,r5
        0x00000df0:    f000f946    ..F.    BL       PAN216_SetPage ; 0x1080
;;;289        }
;;;290        value = PAN216_ReadReg(addr);
        0x00000df4:    4630        0F      MOV      r0,r6
        0x00000df6:    f000f808    ....    BL       PAN216_ReadReg ; 0xe0a
        0x00000dfa:    4606        .F      MOV      r6,r0
;;;291        if (page != original_page)
        0x00000dfc:    42a5        .B      CMP      r5,r4
        0x00000dfe:    d002        ..      BEQ      0xe06 ; PAN216_ReadPageReg + 42
;;;292        {
;;;293            PAN216_SetPage(original_page);
        0x00000e00:    4620         F      MOV      r0,r4
        0x00000e02:    f000f93d    ..=.    BL       PAN216_SetPage ; 0x1080
;;;294        }
;;;295    
;;;296        return value;
        0x00000e06:    4630        0F      MOV      r0,r6
;;;297    }
        0x00000e08:    bd70        p.      POP      {r4-r6,pc}
    i.PAN216_ReadReg
    PAN216_ReadReg
        0x00000e0a:    b508        ..      PUSH     {r3,lr}
;;; ..\..\..\..\radio\pan216_reg.c (85)
        0x00000e0c:    2201        ."      MOVS     r2,#1
        0x00000e0e:    4669        iF      MOV      r1,sp
        0x00000e10:    f7ffffc8    ....    BL       PAN216_Read ; 0xda4
;;;86     
;;;87         return tmp;
        0x00000e14:    4668        hF      MOV      r0,sp
        0x00000e16:    7800        .x      LDRB     r0,[r0,#0]
;;;88     }
        0x00000e18:    bd08        ..      POP      {r3,pc}
    i.PAN216_ReadRegs
    PAN216_ReadRegs
;;;89     
;;;90     /**
;;;91      * @brief Write to the global register in the current page and check
;;;92      * @param[in] addr Register address to write
;;;93      * @param[in] value Value to write to the register
;;;94      * @return Result
;;;95      */
;;;96     PAN216_Err_t PAN216_WriteReg(uint8_t addr, uint8_t value)
;;;97     {
;;;98         PAN216_Write(addr, &value, 1);
;;;99     
;;;100    #if SPI_CHECK_WRITE
;;;101        uint8_t tmp;
;;;102        tmp = PAN216_ReadReg(addr);
;;;103        if (tmp != value)
;;;104        {
;;;105            printf("write reg [readback:0x%02x] writeval:0x%02x error \r\n ", tmp, value);
;;;106            return PAN216_ERR;
;;;107        }
;;;108    #endif
;;;109    
;;;110        return PAN216_OK;
;;;111    }
;;;112    
;;;113    /**
;;;114     * @brief Write to the global register in the current page without check
;;;115     * @param[in] addr Register address to write
;;;116     * @param[in] value Value to write to the register
;;;117     * @return Result
;;;118     */
;;;119    PAN216_Err_t PAN216_WriteRegUnchecked(uint8_t addr, uint8_t value)
;;;120    {
;;;121        PAN216_Write(addr, &value, 1);
;;;122        return PAN216_OK;
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief Write continuous register values (buffer) in a specific address page
;;;127     * @param[in] addr Register start address
;;;128     * @param[in] buffer Values to write
;;;129     * @param[in] len Buffer length
;;;130     * @return Result
;;;131     */
;;;132    PAN216_Err_t PAN216_WriteRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;133    {
;;;134        PAN216_Write(addr, buffer, len);
;;;135        return PAN216_OK;
;;;136    }
;;;137    
;;;138    /**
;;;139     * @brief This function reads more than one byte from the register
;;;140     *
;;;141     * @param addr Register address
;;;142     * @param buffer Buffer provided for data from the register
;;;143     * @param len Number of bytes to read
;;;144     * @return PAN216_Err_t
;;;145     */
;;;146    PAN216_Err_t PAN216_ReadRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;147    {
        0x00000e1a:    b510        ..      PUSH     {r4,lr}
;;;148        PAN216_Read(addr, buffer, len);
        0x00000e1c:    f7ffffc2    ....    BL       PAN216_Read ; 0xda4
;;;149        return PAN216_OK;
        0x00000e20:    2000        .       MOVS     r0,#0
;;;150    }
        0x00000e22:    bd10        ..      POP      {r4,pc}
    i.PAN216_ResetRegBits
    PAN216_ResetRegBits
;;;151    
;;;152    /**
;;;153     * @brief Transfer data to the data FIFO on the chip
;;;154     * @param[in] addr Register address to write
;;;155     * @param[in] buffer Buffer provided for data to write to the register
;;;156     * @param[in] size Number of bytes to write
;;;157     * @return Result
;;;158     */
;;;159    PAN216_Err_t PAN216_WriteFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;160    {
;;;161        return PAN216_WriteRegs(addr, buffer, size);
;;;162    }
;;;163    
;;;164    /**
;;;165     * @brief Read more than one byte from the register
;;;166     * @param[in] addr Register address to read
;;;167     * @param[in] buffer Buffer provided for data from the register
;;;168     * @param[in] size Number of bytes to read
;;;169     * @return Result
;;;170     */
;;;171    PAN216_Err_t PAN216_ReadFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;172    {
;;;173        return PAN216_ReadRegs(addr, buffer, size);
;;;174    }
;;;175    
;;;176    /**
;;;177     * @brief This function writes bits to the register by mask
;;;178     *
;;;179     * @param addr Register address
;;;180     * @param val Bits value
;;;181     * @param mask Bits mask
;;;182     * @return PAN216_Err_t
;;;183     */
;;;184    PAN216_Err_t PAN216_WriteRegBits(uint8_t addr, uint8_t val, uint8_t mask)
;;;185    {
;;;186        uint8_t tmp;
;;;187        PAN216_Err_t ret;
;;;188        uint8_t shift = GET_SHIFT(mask);
;;;189    
;;;190        val <<= shift;
;;;191        if (val & (~mask))
;;;192        {
;;;193            printf("val:0x%02x mask:0x%02x error \r\n", val, mask);
;;;194            return PAN216_ERR;
;;;195        }
;;;196        val &= mask;
;;;197    
;;;198        tmp = PAN216_ReadReg(addr);
;;;199        ret = PAN216_WriteReg(addr, (tmp & (~mask)) | val);
;;;200    
;;;201        return ret;
;;;202    }
;;;203    
;;;204    /**************************************************************************/
;;;205    /*                         Page Register Operation                        */
;;;206    /**************************************************************************/
;;;207    
;;;208    /**
;;;209     * @brief Switch page
;;;210     * @param[in] page Page to switch
;;;211     * @return Result
;;;212     */
;;;213    PAN216_Err_t PAN216_SetPage(uint8_t page)
;;;214    {
;;;215        if (PAN216_OK != PAN216_WriteReg(PAGE_CFG, page))
;;;216        {
;;;217            return PAN216_ERR;
;;;218        }
;;;219    
;;;220        return PAN216_OK;
;;;221    }
;;;222    
;;;223    /**
;;;224     * @brief This function writes a value to the register in a specific page
;;;225     * @param[in] page The page of the register
;;;226     * @param[in] addr Register address
;;;227     * @param[in] value Value to write
;;;228     * @return Result
;;;229     */
;;;230    PAN216_Err_t PAN216_WritePageReg(uint8_t page, uint8_t addr, uint8_t value)
;;;231    {
;;;232        uint8_t original_page;
;;;233    
;;;234        original_page = PAN216_ReadReg(PAGE_CFG);
;;;235        if (page != original_page)
;;;236        {
;;;237            P_ASSERT(PAN216_SetPage(page));
;;;238        }
;;;239        P_ASSERT(PAN216_WriteReg(addr, value));
;;;240        if (page != original_page)
;;;241        {
;;;242            P_ASSERT(PAN216_SetPage(original_page));
;;;243        }
;;;244    
;;;245        return PAN216_OK;
;;;246    }
;;;247    
;;;248    /**
;;;249     * @brief This function writes a value to the register in a specific page without check
;;;250     *
;;;251     * @param page Register page
;;;252     * @param addr Register address
;;;253     * @param value Register value
;;;254     * @return PAN216_Err_t
;;;255     */
;;;256    PAN216_Err_t PAN216_WritePageRegUnchecked(uint8_t page, uint8_t addr, uint8_t value)
;;;257    {
;;;258        uint8_t original_page;
;;;259    
;;;260        original_page = PAN216_ReadReg(PAGE_CFG);
;;;261        if (page != original_page)
;;;262        {
;;;263            PAN216_SetPage(page);
;;;264        }
;;;265        PAN216_Write(addr, &value, 1);
;;;266        if (page != original_page)
;;;267        {
;;;268            PAN216_SetPage(original_page);
;;;269        }
;;;270    
;;;271        return PAN216_OK;
;;;272    }
;;;273    
;;;274    /**
;;;275     * @brief Read a value from the register in a specific page
;;;276     * @param[in] page The page of the register
;;;277     * @param[in] addr Register address
;;;278     * @return Success (register value) or failure
;;;279     */
;;;280    uint8_t PAN216_ReadPageReg(uint8_t page, uint8_t addr)
;;;281    {
;;;282        uint8_t value;
;;;283        uint8_t original_page;
;;;284    
;;;285        original_page = PAN216_ReadReg(PAGE_CFG);
;;;286        if (page != original_page)
;;;287        {
;;;288            PAN216_SetPage(page);
;;;289        }
;;;290        value = PAN216_ReadReg(addr);
;;;291        if (page != original_page)
;;;292        {
;;;293            PAN216_SetPage(original_page);
;;;294        }
;;;295    
;;;296        return value;
;;;297    }
;;;298    
;;;299    /**
;;;300     * @brief Write continuous register values (buffer) in a specific address page
;;;301     * @param[in] page The page of the register
;;;302     * @param[in] addr Register start address
;;;303     * @param[in] buffer Values to write
;;;304     * @param[in] len Buffer length
;;;305     * @return Result
;;;306     */
;;;307    PAN216_Err_t PAN216_WritePageRegs(uint8_t page, uint8_t addr, uint8_t *buffer, uint8_t len)
;;;308    {
;;;309        uint8_t original_page;
;;;310    
;;;311        original_page = PAN216_ReadReg(PAGE_CFG);
;;;312        if (page != original_page)
;;;313        {
;;;314            PAN216_SetPage(page);
;;;315        }
;;;316        PAN216_WriteRegs(addr, buffer, len);
;;;317        if (page != original_page)
;;;318        {
;;;319            PAN216_SetPage(original_page);
;;;320        }
;;;321    
;;;322        return PAN216_OK;
;;;323    }
;;;324    
;;;325    /**
;;;326     * @brief This function reads more than one byte from the register
;;;327     *
;;;328     * @param page Page of the register
;;;329     * @param addr Register address
;;;330     * @param buffer Buffer provided for data from the register
;;;331     * @param len Number of bytes to read
;;;332     * @return PAN216_Err_t
;;;333     */
;;;334    PAN216_Err_t PAN216_ReadPageRegs(uint8_t page, uint8_t addr, uint8_t *buffer, uint8_t len)
;;;335    {
;;;336        uint8_t original_page;
;;;337    
;;;338        original_page = PAN216_ReadReg(PAGE_CFG);
;;;339        if (page != original_page)
;;;340        {
;;;341            PAN216_SetPage(page);
;;;342        }
;;;343        PAN216_Read(addr, buffer, len);
;;;344        if (page != original_page)
;;;345        {
;;;346            PAN216_SetPage(original_page);
;;;347        }
;;;348    
;;;349        return PAN216_OK;
;;;350    }
;;;351    
;;;352    /**************************************************************************/
;;;353    /*                         Register Bit Operation                         */
;;;354    /**************************************************************************/
;;;355    /**
;;;356     * @brief Write bits to the register by mask
;;;357     * @param page Page of the register
;;;358     * @param addr Register address
;;;359     * @param mask Bits mask
;;;360     * @param value Bits value
;;;361     * @return PAN216_Err_t
;;;362     */
;;;363    PAN216_Err_t PAN216_WriteRegWithMask(uint8_t page, uint8_t addr, uint8_t mask, uint8_t value)
;;;364    {
;;;365        uint8_t tmp;
;;;366        PAN216_Err_t ret;
;;;367    
;;;368        value &= mask;
;;;369        tmp = PAN216_ReadPageReg(page, addr);
;;;370        ret = PAN216_WritePageReg(page, addr, (tmp & (~mask)) | value);
;;;371    
;;;372        return ret;
;;;373    }
;;;374    
;;;375    /**
;;;376     * @brief This function reads the register value with mask
;;;377     *
;;;378     * @param page Register page
;;;379     * @param addr Register address
;;;380     * @param mask Bits mask
;;;381     * @return uint8_t
;;;382     */
;;;383    uint8_t PAN216_ReadRegWithMask(uint8_t page, uint8_t addr, uint8_t mask)
;;;384    {
;;;385        uint8_t tmp;
;;;386    
;;;387        tmp = PAN216_ReadPageReg(page, addr);
;;;388    
;;;389        return tmp & mask;
;;;390    }
;;;391    
;;;392    /**
;;;393     * @brief Set bits to 1
;;;394     *
;;;395     * @param page Page of the register
;;;396     * @param addr Register address
;;;397     * @param mask Bits mask
;;;398     * @return PAN216_Err_t
;;;399     */
;;;400    PAN216_Err_t PAN216_SetRegBits(uint8_t page, uint8_t addr, uint8_t mask)
;;;401    {
;;;402        uint8_t tmp;
;;;403        PAN216_Err_t ret;
;;;404    
;;;405        tmp = PAN216_ReadPageReg(page, addr);
;;;406        ret = PAN216_WritePageReg(page, addr, tmp | mask);
;;;407    
;;;408        return ret;
;;;409    }
;;;410    
;;;411    /**
;;;412     * @brief Set bits to 0
;;;413     *
;;;414     * @param page Page of the register
;;;415     * @param addr Register address
;;;416     * @param mask Bits mask
;;;417     * @return PAN216_Err_t
;;;418     */
;;;419    PAN216_Err_t PAN216_ResetRegBits(uint8_t page, uint8_t addr, uint8_t mask)
;;;420    {
        0x00000e24:    b570        p.      PUSH     {r4-r6,lr}
        0x00000e26:    4614        .F      MOV      r4,r2
        0x00000e28:    460d        .F      MOV      r5,r1
        0x00000e2a:    4606        .F      MOV      r6,r0
;;;421        uint8_t tmp;
;;;422        PAN216_Err_t ret;
;;;423    
;;;424        tmp = PAN216_ReadPageReg(page, addr);
        0x00000e2c:    f7ffffd6    ....    BL       PAN216_ReadPageReg ; 0xddc
;;;425        ret = PAN216_WritePageReg(page, addr, tmp & (~mask));
        0x00000e30:    43a0        .C      BICS     r0,r0,r4
        0x00000e32:    4602        .F      MOV      r2,r0
        0x00000e34:    4629        )F      MOV      r1,r5
        0x00000e36:    4630        0F      MOV      r0,r6
        0x00000e38:    f000fac6    ....    BL       PAN216_WritePageReg ; 0x13c8
;;;426    
;;;427        return ret;
;;;428    }
        0x00000e3c:    bd70        p.      POP      {r4-r6,pc}
    i.PAN216_RxLengthLimit
    PAN216_RxLengthLimit
;;; ..\..\..\..\radio\pan216_ext.c
;;;877    {
        0x00000e3e:    b510        ..      PUSH     {r4,lr}
        0x00000e40:    2800        .(      CMP      r0,#0
        0x00000e42:    d005        ..      BEQ      0xe50 ; PAN216_RxLengthLimit + 18
;;;878        if (NewState)
;;;879        {
;;;880            return PAN216_SetRegBits(PAN216_PAGE0, PKT_EXT_CFG, PKT_EXT_CFG_W_RX_MAX_CTRL_EN);
        0x00000e44:    2280        ."      MOVS     r2,#0x80
        0x00000e46:    2119        .!      MOVS     r1,#0x19
        0x00000e48:    2000        .       MOVS     r0,#0
        0x00000e4a:    f000f922    ..".    BL       PAN216_SetRegBits ; 0x1092
        0x00000e4e:    bd10        ..      POP      {r4,pc}
;;;881        }
;;;882        else
;;;883        {
;;;884            return PAN216_ResetRegBits(PAN216_PAGE0, PKT_EXT_CFG, PKT_EXT_CFG_W_RX_MAX_CTRL_EN);
        0x00000e50:    2280        ."      MOVS     r2,#0x80
        0x00000e52:    2119        .!      MOVS     r1,#0x19
        0x00000e54:    2000        .       MOVS     r0,#0
        0x00000e56:    f7ffffe5    ....    BL       PAN216_ResetRegBits ; 0xe24
;;;885        }
;;;886    }
        0x00000e5a:    bd10        ..      POP      {r4,pc}
    i.PAN216_RxStart
    PAN216_RxStart
;;; ..\..\..\..\radio\pan216.c
;;;339    {
        0x00000e5c:    b510        ..      PUSH     {r4,lr}
;;;340        P_ASSERT(PAN216_WriteReg(0x02, 0x74));
        0x00000e5e:    2174        t!      MOVS     r1,#0x74
        0x00000e60:    2002        .       MOVS     r0,#2
        0x00000e62:    f000fb03    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000e66:    2800        .(      CMP      r0,#0
        0x00000e68:    d105        ..      BNE      0xe76 ; PAN216_RxStart + 26
;;;341        P_ASSERT(PAN216_WriteReg(0x02, 0x76));
        0x00000e6a:    2176        v!      MOVS     r1,#0x76
        0x00000e6c:    2002        .       MOVS     r0,#2
        0x00000e6e:    f000fafd    ....    BL       PAN216_WriteReg ; 0x146c
        0x00000e72:    2800        .(      CMP      r0,#0
        0x00000e74:    d000        ..      BEQ      0xe78 ; PAN216_RxStart + 28
        0x00000e76:    2001        .       MOVS     r0,#1
;;;342    
;;;343        return PAN216_OK;
;;;344    }
        0x00000e78:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetAddrWidth
    PAN216_SetAddrWidth
;;;345    
;;;346    /**
;;;347     * @brief Sets the frequency channel of the PAN216 transceiver
;;;348     *
;;;349     * @param Channel The desired radio frequency channel, as a value from 0 to 83
;;;350     *
;;;351     * @note The actual frequency will be (2400 + Channel)MHz
;;;352     * @note The PLOS_CNT[7:4] bits of the OBSERVER_TX register will be reset
;;;353     *
;;;354     * @return uint8_t Result of the operation
;;;355     *         - PAN216_OK
;;;356     *         - PAN216_ERR
;;;357     */
;;;358    PAN216_Err_t PAN216_SetChannel(uint8_t Channel)
;;;359    {
;;;360        return PAN216_WriteReg(REG_P0_0X39, Channel);
;;;361    }
;;;362    
;;;363    /**
;;;364     * @brief Sets the address width of the PAN216 transceiver
;;;365     *
;;;366     * This function is used to set the RX/TX address field width of the PAN216 transceiver.
;;;367     * The address width is specified as a value between 3 and 5.
;;;368     *
;;;369     * @param AddrWidth The desired address width, as a value from 3 to 5
;;;370     *          - 00 2bytes
;;;371     *          - 01 3bytes
;;;372     *          - 10 4bytes
;;;373     *          - 11 5bytes
;;;374     * @return uint8_t Result of the operation
;;;375     *         - PAN216_OK
;;;376     *         - PAN216_ERR
;;;377     */
;;;378    PAN216_Err_t PAN216_SetAddrWidth(PAN216_AddrWidth_t AddrWidth)
;;;379    {
        0x00000e7a:    1e80        ..      SUBS     r0,r0,#2
        0x00000e7c:    b510        ..      PUSH     {r4,lr}
;;;380        P_ASSERT(PAN216_WriteRegBits(WMODE_CFG1, AddrWidth - 2, WMODE_CFG1_ADDR_BYTE_LENGTH));
        0x00000e7e:    b2c1        ..      UXTB     r1,r0
        0x00000e80:    2203        ."      MOVS     r2,#3
        0x00000e82:    2008        .       MOVS     r0,#8
        0x00000e84:    f000fb24    ..$.    BL       PAN216_WriteRegBits ; 0x14d0
        0x00000e88:    2800        .(      CMP      r0,#0
        0x00000e8a:    d000        ..      BEQ      0xe8e ; PAN216_SetAddrWidth + 20
        0x00000e8c:    2001        .       MOVS     r0,#1
;;;381    
;;;382        return PAN216_OK;
;;;383    }
        0x00000e8e:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetAutoRetrans
    PAN216_SetAutoRetrans
;;; ..\..\..\..\radio\pan216_ext.c
;;;860    {
        0x00000e90:    b510        ..      PUSH     {r4,lr}
        0x00000e92:    460c        .F      MOV      r4,r1
        0x00000e94:    28fa        .(      CMP      r0,#0xfa
;;; ..\..\..\..\radio\pan216_ext.c (860)
        0x00000e96:    d200        ..      BCS      0xe9a ; PAN216_SetAutoRetrans + 10
;;;861        if (DelayUs < 250)
;;;862        {
;;;863            DelayUs = 250;
        0x00000e98:    20fa        .       MOVS     r0,#0xfa
;;;864        }
;;;865    
;;;866        DelayUs /= 250;
        0x00000e9a:    21fa        .!      MOVS     r1,#0xfa
        0x00000e9c:    f7fff936    ..6.    BL       __aeabi_uidiv ; 0x10c
        0x00000ea0:    1e40        @.      SUBS     r0,r0,#1
;;;867        DelayUs--;
;;;868    
;;;869        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TXAUTO_CFG, (uint8_t)DelayUs, TXAUTO_CFG_ARD));
        0x00000ea2:    b2c2        ..      UXTB     r2,r0
        0x00000ea4:    23f0        .#      MOVS     r3,#0xf0
        0x00000ea6:    2129        )!      MOVS     r1,#0x29
        0x00000ea8:    2000        .       MOVS     r0,#0
        0x00000eaa:    f000faad    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000eae:    2800        .(      CMP      r0,#0
        0x00000eb0:    d106        ..      BNE      0xec0 ; PAN216_SetAutoRetrans + 48
;;;870        P_ASSERT(
        0x00000eb2:    230f        .#      MOVS     r3,#0xf
        0x00000eb4:    4622        "F      MOV      r2,r4
        0x00000eb6:    2129        )!      MOVS     r1,#0x29
        0x00000eb8:    f000faa6    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000ebc:    2800        .(      CMP      r0,#0
        0x00000ebe:    d000        ..      BEQ      0xec2 ; PAN216_SetAutoRetrans + 50
        0x00000ec0:    2001        .       MOVS     r0,#1
;;;871            PAN216_WritePageRegBits(PAN216_PAGE0, TXAUTO_CFG, (uint8_t)MaxCnt, TXAUTO_CFG_ARC_3_0));
;;;872    
;;;873        return PAN216_OK;
;;;874    }
        0x00000ec2:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetChannel
    PAN216_SetChannel
;;; ..\..\..\..\radio\pan216.c
;;;359    {
        0x00000ec4:    b510        ..      PUSH     {r4,lr}
;;;360        return PAN216_WriteReg(REG_P0_0X39, Channel);
        0x00000ec6:    4601        .F      MOV      r1,r0
        0x00000ec8:    2039        9       MOVS     r0,#0x39
        0x00000eca:    f000facf    ....    BL       PAN216_WriteReg ; 0x146c
;;;361    }
        0x00000ece:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetChipMode
    PAN216_SetChipMode
;;; ..\..\..\..\radio\pan216_ext.c
;;;1070   {
        0x00000ed0:    b570        p.      PUSH     {r4-r6,lr}
        0x00000ed2:    460d        .F      MOV      r5,r1
        0x00000ed4:    4941        AI      LDR      r1,[pc,#260] ; [0xfdc] = 0x20000024
;;; ..\..\..\..\radio\pan216_ext.c (1070)
        0x00000ed6:    4614        .F      MOV      r4,r2
        0x00000ed8:    7008        .p      STRB     r0,[r1,#0]
        0x00000eda:    2800        .(      CMP      r0,#0
        0x00000edc:    d006        ..      BEQ      0xeec ; PAN216_SetChipMode + 28
;;;1071       _gChipMode = chipMode;
;;;1072   
;;;1073       switch (chipMode)
        0x00000ede:    2801        .(      CMP      r0,#1
        0x00000ee0:    d016        ..      BEQ      0xf10 ; PAN216_SetChipMode + 64
        0x00000ee2:    2802        .(      CMP      r0,#2
        0x00000ee4:    d02d        -.      BEQ      0xf42 ; PAN216_SetChipMode + 114
        0x00000ee6:    2803        .(      CMP      r0,#3
        0x00000ee8:    d175        u.      BNE      0xfd6 ; PAN216_SetChipMode + 262
        0x00000eea:    e050        P.      B        0xf8e ; PAN216_SetChipMode + 190
;;;1074       {
;;;1075       case PAN216_CHIPMODE_XN297:
;;;1076           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 0, WMODE_CFG0_CHIP_MODE));
        0x00000eec:    2320         #      MOVS     r3,#0x20
        0x00000eee:    2200        ."      MOVS     r2,#0
        0x00000ef0:    2107        .!      MOVS     r1,#7
        0x00000ef2:    e020         .      B        0xf36 ; PAN216_SetChipMode + 102
;;;1077           P_ASSERT(PAN216_SetEndian(PAN216_ENDIAN_BIG));
        0x00000ef4:    2001        .       MOVS     r0,#1
        0x00000ef6:    f000f8ad    ....    BL       PAN216_SetEndian ; 0x1054
        0x00000efa:    2800        .(      CMP      r0,#0
        0x00000efc:    d16b        k.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1078           P_ASSERT(PAN216_CrcSkipAddr(false));
        0x00000efe:    f7fffd4c    ..L.    BL       PAN216_CrcSkipAddr ; 0x99a
        0x00000f02:    2800        .(      CMP      r0,#0
        0x00000f04:    d167        g.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1079           P_ASSERT(PAN216_WhiteSkipAddr(false));
        0x00000f06:    e03d        =.      B        0xf84 ; PAN216_SetChipMode + 180
;;;1080           P_ASSERT(PAN216_SetWhiteInitVal(0x7F));
        0x00000f08:    207f        .       MOVS     r0,#0x7f
        0x00000f0a:    f000fa14    ....    BL       PAN216_SetWhiteInitVal ; 0x1336
        0x00000f0e:    e059        Y.      B        0xfc4 ; PAN216_SetChipMode + 244
;;;1081           break;
;;;1082   
;;;1083   case PAN216_CHIPMODE_FS01:
;;;1084           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_CHIP_MODE));
        0x00000f10:    2320         #      MOVS     r3,#0x20
        0x00000f12:    2201        ."      MOVS     r2,#1
        0x00000f14:    2107        .!      MOVS     r1,#7
        0x00000f16:    2000        .       MOVS     r0,#0
        0x00000f18:    f000fa76    ..v.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f1c:    2800        .(      CMP      r0,#0
        0x00000f1e:    d15a        Z.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1085           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 0, WMODE_CFG0_NORDIC_ENHANCE));
        0x00000f20:    2200        ."      MOVS     r2,#0
        0x00000f22:    2310        .#      MOVS     r3,#0x10
        0x00000f24:    2107        .!      MOVS     r1,#7
        0x00000f26:    4610        .F      MOV      r0,r2
        0x00000f28:    f000fa6e    ..n.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f2c:    2800        .(      CMP      r0,#0
        0x00000f2e:    d152        R.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1086           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, REG_P0_0X6F, 0, REG_P0_0X6F_I_NDC_PREAMBLE_SEL)); 
        0x00000f30:    2320         #      MOVS     r3,#0x20
        0x00000f32:    2200        ."      MOVS     r2,#0
        0x00000f34:    216f        o!      MOVS     r1,#0x6f
        0x00000f36:    2000        .       MOVS     r0,#0
        0x00000f38:    f000fa66    ..f.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f3c:    2800        .(      CMP      r0,#0
        0x00000f3e:    d14a        J.      BNE      0xfd6 ; PAN216_SetChipMode + 262
        0x00000f40:    e7d8        ..      B        0xef4 ; PAN216_SetChipMode + 36
;;;1087           P_ASSERT(PAN216_SetEndian(PAN216_ENDIAN_BIG));
;;;1088           P_ASSERT(PAN216_CrcSkipAddr(false));
;;;1089           P_ASSERT(PAN216_WhiteSkipAddr(false));
;;;1090           P_ASSERT(PAN216_SetWhiteInitVal(0x7F));
;;;1091           break;
;;;1092   
;;;1093       case PAN216_CHIPMODE_FS32:
;;;1094           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_CHIP_MODE));
        0x00000f42:    2320         #      MOVS     r3,#0x20
        0x00000f44:    2201        ."      MOVS     r2,#1
        0x00000f46:    2107        .!      MOVS     r1,#7
        0x00000f48:    2000        .       MOVS     r0,#0
        0x00000f4a:    f000fa5d    ..].    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f4e:    2800        .(      CMP      r0,#0
        0x00000f50:    d141        A.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1095           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_NORDIC_ENHANCE));
        0x00000f52:    2310        .#      MOVS     r3,#0x10
        0x00000f54:    2201        ."      MOVS     r2,#1
        0x00000f56:    2107        .!      MOVS     r1,#7
        0x00000f58:    f000fa56    ..V.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f5c:    2800        .(      CMP      r0,#0
        0x00000f5e:    d13a        :.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1096           P_ASSERT(PAN216_WritePageRegBits(
        0x00000f60:    2320         #      MOVS     r3,#0x20
        0x00000f62:    2201        ."      MOVS     r2,#1
        0x00000f64:    216f        o!      MOVS     r1,#0x6f
        0x00000f66:    f000fa4f    ..O.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f6a:    2800        .(      CMP      r0,#0
        0x00000f6c:    d133        3.      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1097               PAN216_PAGE0, REG_P0_0X6F, 1,
;;;1098               REG_P0_0X6F_I_NDC_PREAMBLE_SEL));
;;;1099           P_ASSERT(PAN216_SetEndian(endian));
        0x00000f6e:    4628        (F      MOV      r0,r5
        0x00000f70:    f000f870    ..p.    BL       PAN216_SetEndian ; 0x1054
        0x00000f74:    2800        .(      CMP      r0,#0
        0x00000f76:    d12e        ..      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1100           P_ASSERT(PAN216_CrcSkipAddr(crcSkipAddr));
        0x00000f78:    4620         F      MOV      r0,r4
        0x00000f7a:    f7fffd0e    ....    BL       PAN216_CrcSkipAddr ; 0x99a
        0x00000f7e:    2800        .(      CMP      r0,#0
        0x00000f80:    d129        ).      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1101           P_ASSERT(PAN216_WhiteSkipAddr(true));
        0x00000f82:    2001        .       MOVS     r0,#1
        0x00000f84:    f000f9f6    ....    BL       PAN216_WhiteSkipAddr ; 0x1374
        0x00000f88:    2800        .(      CMP      r0,#0
        0x00000f8a:    d124        $.      BNE      0xfd6 ; PAN216_SetChipMode + 262
        0x00000f8c:    e7bc        ..      B        0xf08 ; PAN216_SetChipMode + 56
;;;1102           P_ASSERT(PAN216_SetWhiteInitVal(0x7F));
;;;1103           break;
;;;1104       case PAN216_CHIPMODE_BLE:
;;;1105           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_CHIP_MODE));
        0x00000f8e:    2320         #      MOVS     r3,#0x20
        0x00000f90:    2201        ."      MOVS     r2,#1
        0x00000f92:    2107        .!      MOVS     r1,#7
        0x00000f94:    2000        .       MOVS     r0,#0
        0x00000f96:    f000fa37    ..7.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000f9a:    2800        .(      CMP      r0,#0
        0x00000f9c:    d11b        ..      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1106           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1,
        0x00000f9e:    2310        .#      MOVS     r3,#0x10
        0x00000fa0:    2201        ."      MOVS     r2,#1
        0x00000fa2:    2107        .!      MOVS     r1,#7
        0x00000fa4:    f000fa30    ..0.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000fa8:    2800        .(      CMP      r0,#0
        0x00000faa:    d114        ..      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1107                                            WMODE_CFG0_NORDIC_ENHANCE));
;;;1108           P_ASSERT(PAN216_SetEndian(PAN216_ENDIAN_LITTLE));
        0x00000fac:    f000f852    ..R.    BL       PAN216_SetEndian ; 0x1054
        0x00000fb0:    2800        .(      CMP      r0,#0
        0x00000fb2:    d110        ..      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1109           P_ASSERT(PAN216_CrcSkipAddr(true));
        0x00000fb4:    2001        .       MOVS     r0,#1
        0x00000fb6:    f7fffcf0    ....    BL       PAN216_CrcSkipAddr ; 0x99a
        0x00000fba:    2800        .(      CMP      r0,#0
        0x00000fbc:    d10b        ..      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1110           P_ASSERT(PAN216_WhiteSkipAddr(true));
        0x00000fbe:    2001        .       MOVS     r0,#1
        0x00000fc0:    f000f9d8    ....    BL       PAN216_WhiteSkipAddr ; 0x1374
        0x00000fc4:    2800        .(      CMP      r0,#0
        0x00000fc6:    d106        ..      BNE      0xfd6 ; PAN216_SetChipMode + 262
;;;1111   
;;;1112           break;
;;;1113       default:
;;;1114           return PAN216_ERR;
;;;1115       }
;;;1116   
;;;1117       // when recv error occurs, the chip will enter rx mode automatically
;;;1118       P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG1, 1, WMODE_CFG1_RX_GOON));
        0x00000fc8:    2380        .#      MOVS     r3,#0x80
        0x00000fca:    2201        ."      MOVS     r2,#1
        0x00000fcc:    2108        .!      MOVS     r1,#8
        0x00000fce:    f000fa1b    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000fd2:    2800        .(      CMP      r0,#0
        0x00000fd4:    d000        ..      BEQ      0xfd8 ; PAN216_SetChipMode + 264
        0x00000fd6:    2001        .       MOVS     r0,#1
;;;1119   
;;;1120       return PAN216_OK;
;;;1121   }
        0x00000fd8:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x00000fda:    0000        ..      DCW    0
        0x00000fdc:    20000024    $..     DCD    536870948
    $t
    i.PAN216_SetCrcScheme
    PAN216_SetCrcScheme
;;; ..\..\..\..\radio\pan216_ext.c (443)
        0x00000fe0:    b510        ..      PUSH     {r4,lr}
        0x00000fe2:    2803        .(      CMP      r0,#3
;;; ..\..\..\..\radio\pan216_ext.c (443)
        0x00000fe4:    d807        ..      BHI      0xff6 ; PAN216_SetCrcScheme + 22
;;;444        if (Crc > PAN216_CRC_3byte)
;;;445        {
;;;446            return PAN216_ERR;
;;;447        }
;;;448    
;;;449        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Crc, WMODE_CFG0_CRC_MODE_1_0));
        0x00000fe6:    4602        .F      MOV      r2,r0
        0x00000fe8:    23c0        .#      MOVS     r3,#0xc0
        0x00000fea:    2107        .!      MOVS     r1,#7
        0x00000fec:    2000        .       MOVS     r0,#0
        0x00000fee:    f000fa0b    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00000ff2:    2800        .(      CMP      r0,#0
        0x00000ff4:    d000        ..      BEQ      0xff8 ; PAN216_SetCrcScheme + 24
        0x00000ff6:    2001        .       MOVS     r0,#1
;;;450    
;;;451        return PAN216_OK;
;;;452    }
        0x00000ff8:    bd10        ..      POP      {r4,pc}
        0x00000ffa:    0000        ..      MOVS     r0,r0
    i.PAN216_SetDataRate
    PAN216_SetDataRate
;;;453    
;;;454    /**
;;;455     * @brief Configures the data rate of the PAN216 transceiver
;;;456     *
;;;457     * This function is used to configure the data rate of the PAN216 transceiver. The
;;;458     * data rate is specified as one of the members of PAN216_DataRate_t.
;;;459     *
;;;460     * @param DataRate The desired data rate, as one of the members of PAN216_DataRate_t
;;;461     *
;;;462     * @return uint8_t Result of the operation
;;;463     *         - PAN216_OK
;;;464     *         - PAN216_ERR
;;;465     */
;;;466    PAN216_Err_t PAN216_SetDataRate(PAN216_DataRate_t DataRate)
;;;467    {
        0x00000ffc:    b510        ..      PUSH     {r4,lr}
        0x00000ffe:    2803        .(      CMP      r0,#3
;;; ..\..\..\..\radio\pan216_ext.c (467)
        0x00001000:    d214        ..      BCS      0x102c ; PAN216_SetDataRate + 48
        0x00001002:    4913        .I      LDR      r1,[pc,#76] ; [0x1050] = 0x20000024
;;;468        uint8_t DataRateVal;
;;;469    
;;;470        if (DataRate >= PAN216_DR_Max)
;;;471        {
;;;472            return PAN216_ERR;
;;;473        }
;;;474    
;;;475        switch (DataRate)
        0x00001004:    2800        .(      CMP      r0,#0
        0x00001006:    d004        ..      BEQ      0x1012 ; PAN216_SetDataRate + 22
        0x00001008:    2801        .(      CMP      r0,#1
        0x0000100a:    d005        ..      BEQ      0x1018 ; PAN216_SetDataRate + 28
        0x0000100c:    2802        .(      CMP      r0,#2
        0x0000100e:    d10d        ..      BNE      0x102c ; PAN216_SetDataRate + 48
        0x00001010:    e00e        ..      B        0x1030 ; PAN216_SetDataRate + 52
;;;476        {
;;;477        case PAN216_DR_1Mbps:
;;;478            DataRateVal = 0x00;
        0x00001012:    2200        ."      MOVS     r2,#0
;;;479            _gDataRate = PAN216_DR_1Mbps;
        0x00001014:    4610        .F      MOV      r0,r2
;;;480            break;
        0x00001016:    e001        ..      B        0x101c ; PAN216_SetDataRate + 32
;;;481        case PAN216_DR_2Mbps:
;;;482            DataRateVal = 0x01;
        0x00001018:    2201        ."      MOVS     r2,#1
;;;483            _gDataRate = PAN216_DR_2Mbps;
        0x0000101a:    4610        .F      MOV      r0,r2
        0x0000101c:    7048        Hp      STRB     r0,[r1,#1]
        0x0000101e:    2330        0#      MOVS     r3,#0x30
        0x00001020:    2136        6!      MOVS     r1,#0x36
        0x00001022:    2000        .       MOVS     r0,#0
        0x00001024:    f000f9f0    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00001028:    2800        .(      CMP      r0,#0
        0x0000102a:    d004        ..      BEQ      0x1036 ; PAN216_SetDataRate + 58
        0x0000102c:    2001        .       MOVS     r0,#1
        0x0000102e:    bd10        ..      POP      {r4,pc}
;;;484            break;
;;;485        case PAN216_DR_250Kbps:
;;;486            DataRateVal = 0x03;
        0x00001030:    2203        ."      MOVS     r2,#3
;;;487            _gDataRate = PAN216_DR_250Kbps;
        0x00001032:    2002        .       MOVS     r0,#2
;;;488            break;
        0x00001034:    e7f2        ..      B        0x101c ; PAN216_SetDataRate + 32
;;;489        default:
;;;490            return PAN216_ERR;
;;;491        }
;;;492    
;;;493        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, REG_P0_0X36, DataRateVal, REG_P0_0X36_BW_MODE));
;;;494    
;;;495        PAN216_DRModConfig();
        0x00001036:    f7fffcbf    ....    BL       PAN216_DRModConfig ; 0x9b8
;;;496        WriteTxDemodConfig();
        0x0000103a:    f000fb89    ....    BL       WriteTxDemodConfig ; 0x1750
;;;497        WriteRxDemodConfig();
        0x0000103e:    f000fb59    ..Y.    BL       WriteRxDemodConfig ; 0x16f4
;;;498        PAN216_Calibration();
        0x00001042:    f7fffc65    ..e.    BL       PAN216_Calibration ; 0x910
;;;499    #if CALIBRATION_DEBUG_ON
;;;500        PAN216_ReadVCOCode();
;;;501        PAN216_ReadTpCode();
;;;502        ReadBWDcocCal(FILTER_OFFSET_CAL_MODE, 0);
;;;503        ReadBWDcocCal(FILTER_BW_CAL_MODE, 0);
;;;504        ReadBWDcocCal(FILTER_BW_CAL_MODE, 1);
;;;505        ReadBWDcocCal(FILTER_BW_CAL_MODE, 2);
;;;506        ReadBWDcocCal(FILTER_DCOC_CAL_MODE, 0);
;;;507    #endif
;;;508        PAN216_FinishCalibration();
        0x00001046:    f7fffe08    ....    BL       PAN216_FinishCalibration ; 0xc5a
;;;509        return PAN216_OK;
        0x0000104a:    2000        .       MOVS     r0,#0
;;;510    }
        0x0000104c:    bd10        ..      POP      {r4,pc}
    $d
        0x0000104e:    0000        ..      DCW    0
        0x00001050:    20000024    $..     DCD    536870948
    $t
    i.PAN216_SetEndian
    PAN216_SetEndian
;;;511    
;;;512    PAN216_Err_t PAN216_EnableRxPipe(PAN216_Pipe_t Pipe)
;;;513    {
;;;514        if (Pipe > PAN216_PIPE5)
;;;515        {
;;;516            return PAN216_ERR;
;;;517        }
;;;518    
;;;519        return PAN216_SetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;520    }
;;;521    
;;;522    PAN216_Err_t PAN216_DisableRxPipe(PAN216_Pipe_t Pipe)
;;;523    {
;;;524        if (Pipe > PAN216_PIPE5)
;;;525        {
;;;526            return PAN216_ERR;
;;;527        }
;;;528    
;;;529        return PAN216_ResetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;530    }
;;;531    
;;;532    /**
;;;533     * @brief Configure a specified RX pipe
;;;534     *
;;;535     * @param Pipe        Number of the RX pipe, value from 0 to 6
;;;536     * @param PayloadLen  Payload length in bytes
;;;537     *
;;;538     * @return Result of the operation
;;;539     *         - PAN216_OK
;;;540     *         - PAN216_ERR
;;;541     */
;;;542    PAN216_Err_t PAN216_SetRxPayloadLen(uint8_t PayloadLen)
;;;543    {
;;;544        return PAN216_WritePageReg(PAN216_PAGE0, RXPLLEN_CFG, PayloadLen);
;;;545    }
;;;546    
;;;547    PAN216_Err_t PAN216_SetTxPayloadLen(uint8_t PayloadLen)
;;;548    {
;;;549        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXPLLEN_CFG, PayloadLen));
;;;550        return PAN216_OK;
;;;551    }
;;;552    
;;;553    /**
;;;554     * @brief Set enhanced shockburst mode for the PAN216 transceiver
;;;555     *
;;;556     * @param Mode Enhanced shockburst mode to set, one of PAN216_Mode_t values
;;;557     *
;;;558     * @return uint8_t Result of the operation
;;;559     *         - PAN216_OK
;;;560     *         - PAN216_ERR
;;;561     */
;;;562    PAN216_Err_t PAN216_SetWorkMode(PAN216_WorkMode_t Mode)
;;;563    {
;;;564    
;;;565        switch (Mode)
;;;566        {
;;;567        case PAN216_WORKMODE_NORMAL:
;;;568            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1,
;;;569                                         WMODE_CFG1_NORMAL_M1 | WMODE_CFG1_ENHANCE));
;;;570            break;
;;;571        case PAN216_WORKMODE_ENHANCE:
;;;572            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_ENHANCE));
;;;573            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;574            break;
;;;575        default:
;;;576            return PAN216_ERR;
;;;577        }
;;;578    
;;;579        return PAN216_OK;
;;;580    }
;;;581    
;;;582    PAN216_Err_t PAN216_GetChipMode(PAN216_ChipMode_t *chipMode)
;;;583    {
;;;584        *chipMode = (PAN216_ChipMode_t)_gChipMode;
;;;585        return PAN216_OK;
;;;586    }
;;;587    
;;;588    /**
;;;589     * @brief  This function set noack for tx
;;;590     * @param  NewState: ENABLE/DISABLE
;;;591     * @return Result of the operation
;;;592     *         - PAN216_OK
;;;593     *         - PAN216_ERR
;;;594     * @note  This function is called after PAN216_SetWorkMode
;;;595     */
;;;596    PAN216_Err_t PAN216_EnableTxNoAck(uint8_t NewState)
;;;597    {
;;;598        uint8_t modeCfg1 = PAN216_ReadPageReg(PAN216_PAGE0, WMODE_CFG1);
;;;599    
;;;600        if (modeCfg1 & WMODE_CFG1_ENHANCE)
;;;601        {
;;;602            if (NewState)
;;;603            {
;;;604                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;605            }
;;;606            else
;;;607            {
;;;608                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;609            }
;;;610            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;611        }
;;;612        else
;;;613        {
;;;614            if (NewState)
;;;615            {
;;;616                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;617            }
;;;618            else
;;;619            {
;;;620                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;621            }
;;;622            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;623        }
;;;624    
;;;625        return PAN216_OK;
;;;626    }
;;;627    
;;;628    /**
;;;629     * @brief After receiving a packet, reads the TxNoack bit of a enhanced shockburst packet
;;;630     *
;;;631     * @return uint8_t  1 : rx need ack
;;;632     *                  0 : rx need no ack
;;;633     */
;;;634    uint8_t PAN216_ReadTxNoackBit(void)
;;;635    {
;;;636        return !(PAN216_ReadReg(0x7D) & BIT6);
;;;637    }
;;;638    
;;;639    PAN216_Err_t PAN216_SetAckPipe(uint8_t pipe)
;;;640    {
;;;641        if (pipe > 5)
;;;642        {
;;;643            return PAN216_ERR;
;;;644        }
;;;645    
;;;646        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, pipe, 0x07));
;;;647    
;;;648        return PAN216_OK;
;;;649    }
;;;650    
;;;651    /**
;;;652     * @brief Enable CRC calculation for address field in PAN216.
;;;653     *
;;;654     * This function allows enabling or disabling
;;;655     *  CRC calculation for the address field in PAN216.
;;;656     *
;;;657     * @note By default, address field is not included in CRC calculation.
;;;658     *
;;;659     * @param[in] NewState Boolean value indicating whether to enable or disable CRC calculation for
;;;660     * address field.
;;;661     *
;;;662     * @return Result of the operation:
;;;663     *         - PAN216_OK
;;;664     *         - PAN216_ERR
;;;665     */
;;;666    PAN216_Err_t PAN216_CrcSkipAddr(bool exclude)
;;;667    {
;;;668        if (exclude)
;;;669        {
;;;670            return PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;671        }
;;;672        else
;;;673        {
;;;674            return PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;675        }
;;;676    }
;;;677    
;;;678    /**
;;;679     * @brief whiten(scramble) configurations
;;;680     * @param addr_excluded  whiten exclude access address(already include header, payload, crc)
;;;681     * @param initital_phase initital whiten phase
;;;682     *        - channel 37: 0x53
;;;683              - channel 38: 0x33
;;;684              - channel 39: 0x73
;;;685     * @return PAN216_Err_t
;;;686     */
;;;687    PAN216_Err_t PAN216_WhiteSkipAddr(bool addr_excluded)
;;;688    {
;;;689        PAN216_Err_t ret;
;;;690    
;;;691        if (addr_excluded)
;;;692        {
;;;693            ret = PAN216_SetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;694        }
;;;695        else
;;;696        {
;;;697            ret = PAN216_ResetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;698        }
;;;699    
;;;700        return ret;
;;;701    }
;;;702    
;;;703    /**
;;;704     * @brief
;;;705     *
;;;706     * @param Endian
;;;707     * @return uint8_t
;;;708     */
;;;709    PAN216_Err_t PAN216_SetEndian(PAN216_Endian_t Endian)
;;;710    {
        0x00001054:    b510        ..      PUSH     {r4,lr}
        0x00001056:    0004        ..      MOVS     r4,r0
        0x00001058:    d00f        ..      BEQ      0x107a ; PAN216_SetEndian + 38
;;;711    
;;;712        if (Endian == PAN216_ENDIAN_LITTLE)
;;;713        {
;;;714            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 1,
;;;715                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;716        }
;;;717        else
;;;718        {
;;;719            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 0,
        0x0000105a:    2310        .#      MOVS     r3,#0x10
        0x0000105c:    2200        ."      MOVS     r2,#0
        0x0000105e:    216f        o!      MOVS     r1,#0x6f
        0x00001060:    2000        .       MOVS     r0,#0
        0x00001062:    f000f9d1    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;720                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;721        }
;;;722    
;;;723        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Endian, WMODE_CFG0_ENDIAN));
        0x00001066:    2301        .#      MOVS     r3,#1
        0x00001068:    4622        "F      MOV      r2,r4
        0x0000106a:    2107        .!      MOVS     r1,#7
        0x0000106c:    2000        .       MOVS     r0,#0
        0x0000106e:    f000f9cb    ....    BL       PAN216_WritePageRegBits ; 0x1408
        0x00001072:    2800        .(      CMP      r0,#0
        0x00001074:    d000        ..      BEQ      0x1078 ; PAN216_SetEndian + 36
        0x00001076:    2001        .       MOVS     r0,#1
;;;724    
;;;725        return PAN216_OK;
;;;726    }
        0x00001078:    bd10        ..      POP      {r4,pc}
        0x0000107a:    2310        .#      MOVS     r3,#0x10
        0x0000107c:    2201        ."      MOVS     r2,#1
        0x0000107e:    e7ee        ..      B        0x105e ; PAN216_SetEndian + 10
    i.PAN216_SetPage
    PAN216_SetPage
;;; ..\..\..\..\radio\pan216_reg.c
;;;214    {
        0x00001080:    b510        ..      PUSH     {r4,lr}
;;;215        if (PAN216_OK != PAN216_WriteReg(PAGE_CFG, page))
        0x00001082:    4601        .F      MOV      r1,r0
        0x00001084:    2000        .       MOVS     r0,#0
        0x00001086:    f000f9f1    ....    BL       PAN216_WriteReg ; 0x146c
        0x0000108a:    2800        .(      CMP      r0,#0
        0x0000108c:    d000        ..      BEQ      0x1090 ; PAN216_SetPage + 16
;;;216        {
;;;217            return PAN216_ERR;
        0x0000108e:    2001        .       MOVS     r0,#1
;;;218        }
;;;219    
;;;220        return PAN216_OK;
;;;221    }
        0x00001090:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetRegBits
    PAN216_SetRegBits
;;;222    
;;;223    /**
;;;224     * @brief This function writes a value to the register in a specific page
;;;225     * @param[in] page The page of the register
;;;226     * @param[in] addr Register address
;;;227     * @param[in] value Value to write
;;;228     * @return Result
;;;229     */
;;;230    PAN216_Err_t PAN216_WritePageReg(uint8_t page, uint8_t addr, uint8_t value)
;;;231    {
;;;232        uint8_t original_page;
;;;233    
;;;234        original_page = PAN216_ReadReg(PAGE_CFG);
;;;235        if (page != original_page)
;;;236        {
;;;237            P_ASSERT(PAN216_SetPage(page));
;;;238        }
;;;239        P_ASSERT(PAN216_WriteReg(addr, value));
;;;240        if (page != original_page)
;;;241        {
;;;242            P_ASSERT(PAN216_SetPage(original_page));
;;;243        }
;;;244    
;;;245        return PAN216_OK;
;;;246    }
;;;247    
;;;248    /**
;;;249     * @brief This function writes a value to the register in a specific page without check
;;;250     *
;;;251     * @param page Register page
;;;252     * @param addr Register address
;;;253     * @param value Register value
;;;254     * @return PAN216_Err_t
;;;255     */
;;;256    PAN216_Err_t PAN216_WritePageRegUnchecked(uint8_t page, uint8_t addr, uint8_t value)
;;;257    {
;;;258        uint8_t original_page;
;;;259    
;;;260        original_page = PAN216_ReadReg(PAGE_CFG);
;;;261        if (page != original_page)
;;;262        {
;;;263            PAN216_SetPage(page);
;;;264        }
;;;265        PAN216_Write(addr, &value, 1);
;;;266        if (page != original_page)
;;;267        {
;;;268            PAN216_SetPage(original_page);
;;;269        }
;;;270    
;;;271        return PAN216_OK;
;;;272    }
;;;273    
;;;274    /**
;;;275     * @brief Read a value from the register in a specific page
;;;276     * @param[in] page The page of the register
;;;277     * @param[in] addr Register address
;;;278     * @return Success (register value) or failure
;;;279     */
;;;280    uint8_t PAN216_ReadPageReg(uint8_t page, uint8_t addr)
;;;281    {
;;;282        uint8_t value;
;;;283        uint8_t original_page;
;;;284    
;;;285        original_page = PAN216_ReadReg(PAGE_CFG);
;;;286        if (page != original_page)
;;;287        {
;;;288            PAN216_SetPage(page);
;;;289        }
;;;290        value = PAN216_ReadReg(addr);
;;;291        if (page != original_page)
;;;292        {
;;;293            PAN216_SetPage(original_page);
;;;294        }
;;;295    
;;;296        return value;
;;;297    }
;;;298    
;;;299    /**
;;;300     * @brief Write continuous register values (buffer) in a specific address page
;;;301     * @param[in] page The page of the register
;;;302     * @param[in] addr Register start address
;;;303     * @param[in] buffer Values to write
;;;304     * @param[in] len Buffer length
;;;305     * @return Result
;;;306     */
;;;307    PAN216_Err_t PAN216_WritePageRegs(uint8_t page, uint8_t addr, uint8_t *buffer, uint8_t len)
;;;308    {
;;;309        uint8_t original_page;
;;;310    
;;;311        original_page = PAN216_ReadReg(PAGE_CFG);
;;;312        if (page != original_page)
;;;313        {
;;;314            PAN216_SetPage(page);
;;;315        }
;;;316        PAN216_WriteRegs(addr, buffer, len);
;;;317        if (page != original_page)
;;;318        {
;;;319            PAN216_SetPage(original_page);
;;;320        }
;;;321    
;;;322        return PAN216_OK;
;;;323    }
;;;324    
;;;325    /**
;;;326     * @brief This function reads more than one byte from the register
;;;327     *
;;;328     * @param page Page of the register
;;;329     * @param addr Register address
;;;330     * @param buffer Buffer provided for data from the register
;;;331     * @param len Number of bytes to read
;;;332     * @return PAN216_Err_t
;;;333     */
;;;334    PAN216_Err_t PAN216_ReadPageRegs(uint8_t page, uint8_t addr, uint8_t *buffer, uint8_t len)
;;;335    {
;;;336        uint8_t original_page;
;;;337    
;;;338        original_page = PAN216_ReadReg(PAGE_CFG);
;;;339        if (page != original_page)
;;;340        {
;;;341            PAN216_SetPage(page);
;;;342        }
;;;343        PAN216_Read(addr, buffer, len);
;;;344        if (page != original_page)
;;;345        {
;;;346            PAN216_SetPage(original_page);
;;;347        }
;;;348    
;;;349        return PAN216_OK;
;;;350    }
;;;351    
;;;352    /**************************************************************************/
;;;353    /*                         Register Bit Operation                         */
;;;354    /**************************************************************************/
;;;355    /**
;;;356     * @brief Write bits to the register by mask
;;;357     * @param page Page of the register
;;;358     * @param addr Register address
;;;359     * @param mask Bits mask
;;;360     * @param value Bits value
;;;361     * @return PAN216_Err_t
;;;362     */
;;;363    PAN216_Err_t PAN216_WriteRegWithMask(uint8_t page, uint8_t addr, uint8_t mask, uint8_t value)
;;;364    {
;;;365        uint8_t tmp;
;;;366        PAN216_Err_t ret;
;;;367    
;;;368        value &= mask;
;;;369        tmp = PAN216_ReadPageReg(page, addr);
;;;370        ret = PAN216_WritePageReg(page, addr, (tmp & (~mask)) | value);
;;;371    
;;;372        return ret;
;;;373    }
;;;374    
;;;375    /**
;;;376     * @brief This function reads the register value with mask
;;;377     *
;;;378     * @param page Register page
;;;379     * @param addr Register address
;;;380     * @param mask Bits mask
;;;381     * @return uint8_t
;;;382     */
;;;383    uint8_t PAN216_ReadRegWithMask(uint8_t page, uint8_t addr, uint8_t mask)
;;;384    {
;;;385        uint8_t tmp;
;;;386    
;;;387        tmp = PAN216_ReadPageReg(page, addr);
;;;388    
;;;389        return tmp & mask;
;;;390    }
;;;391    
;;;392    /**
;;;393     * @brief Set bits to 1
;;;394     *
;;;395     * @param page Page of the register
;;;396     * @param addr Register address
;;;397     * @param mask Bits mask
;;;398     * @return PAN216_Err_t
;;;399     */
;;;400    PAN216_Err_t PAN216_SetRegBits(uint8_t page, uint8_t addr, uint8_t mask)
;;;401    {
        0x00001092:    b570        p.      PUSH     {r4-r6,lr}
        0x00001094:    4614        .F      MOV      r4,r2
        0x00001096:    460d        .F      MOV      r5,r1
        0x00001098:    4606        .F      MOV      r6,r0
;;;402        uint8_t tmp;
;;;403        PAN216_Err_t ret;
;;;404    
;;;405        tmp = PAN216_ReadPageReg(page, addr);
        0x0000109a:    f7fffe9f    ....    BL       PAN216_ReadPageReg ; 0xddc
;;;406        ret = PAN216_WritePageReg(page, addr, tmp | mask);
        0x0000109e:    4320         C      ORRS     r0,r0,r4
        0x000010a0:    4602        .F      MOV      r2,r0
        0x000010a2:    4629        )F      MOV      r1,r5
        0x000010a4:    4630        0F      MOV      r0,r6
        0x000010a6:    f000f98f    ....    BL       PAN216_WritePageReg ; 0x13c8
;;;407    
;;;408        return ret;
;;;409    }
        0x000010aa:    bd70        p.      POP      {r4-r6,pc}
    i.PAN216_SetRxAddr
    PAN216_SetRxAddr
;;; ..\..\..\..\radio\pan216.c
;;;402    {
        0x000010ac:    b510        ..      PUSH     {r4,lr}
;;;403    
;;;404        switch (Pipe)
        0x000010ae:    0003        ..      MOVS     r3,r0
        0x000010b0:    f000fb8a    ....    BL       __ARM_common_switch8 ; 0x17c8
    $d
        0x000010b4:    0d060406    ....    DCD    218498054
        0x000010b8:    0b161310    ....    DCD    185996048
    $t
;;;405        {
;;;406        case PAN216_PIPE0:
;;;407            P_ASSERT(PAN216_WriteRegs(PIPE0_RXADDR0_CFG, Addr, len));
        0x000010bc:    200f        .       MOVS     r0,#0xf
        0x000010be:    e000        ..      B        0x10c2 ; PAN216_SetRxAddr + 22
        0x000010c0:    2020                MOVS     r0,#0x20
        0x000010c2:    f000fa3a    ..:.    BL       PAN216_WriteRegs ; 0x153a
        0x000010c6:    2800        .(      CMP      r0,#0
        0x000010c8:    d000        ..      BEQ      0x10cc ; PAN216_SetRxAddr + 32
        0x000010ca:    2001        .       MOVS     r0,#1
        0x000010cc:    bd10        ..      POP      {r4,pc}
;;;408            break;
;;;409        case PAN216_PIPE1:
;;;410            P_ASSERT(PAN216_WriteRegs(PIPE1_RXADDR0_CFG, Addr, len));
;;;411            break;
;;;412        case PAN216_PIPE2:
;;;413            P_ASSERT(PAN216_WriteReg(PIPE2_RXADDR0_CFG, Addr[0]));
        0x000010ce:    7809        .x      LDRB     r1,[r1,#0]
        0x000010d0:    2025        %       MOVS     r0,#0x25
        0x000010d2:    e007        ..      B        0x10e4 ; PAN216_SetRxAddr + 56
;;;414            break;
;;;415        case PAN216_PIPE3:
;;;416            P_ASSERT(PAN216_WriteReg(PIPE3_RXADDR0_CFG, Addr[0]));
        0x000010d4:    7809        .x      LDRB     r1,[r1,#0]
        0x000010d6:    2026        &       MOVS     r0,#0x26
        0x000010d8:    e004        ..      B        0x10e4 ; PAN216_SetRxAddr + 56
;;;417            break;
;;;418        case PAN216_PIPE4:
;;;419            P_ASSERT(PAN216_WriteReg(PIPE4_RXADDR0_CFG, Addr[0]));
        0x000010da:    7809        .x      LDRB     r1,[r1,#0]
        0x000010dc:    2027        '       MOVS     r0,#0x27
        0x000010de:    e001        ..      B        0x10e4 ; PAN216_SetRxAddr + 56
;;;420            break;
;;;421        case PAN216_PIPE5:
;;;422            P_ASSERT(PAN216_WriteReg(PIPE5_RXADDR0_CFG, Addr[0]));
        0x000010e0:    7809        .x      LDRB     r1,[r1,#0]
        0x000010e2:    2028        (       MOVS     r0,#0x28
        0x000010e4:    f000f9c2    ....    BL       PAN216_WriteReg ; 0x146c
        0x000010e8:    e7ed        ..      B        0x10c6 ; PAN216_SetRxAddr + 26
    i.PAN216_SetRxMode
    PAN216_SetRxMode
;;; ..\..\..\..\radio\pan216_ext.c
;;;316    {
        0x000010ea:    b510        ..      PUSH     {r4,lr}
        0x000010ec:    2800        .(      CMP      r0,#0
        0x000010ee:    d004        ..      BEQ      0x10fa ; PAN216_SetRxMode + 16
;;;317        switch (RxMode)
        0x000010f0:    2801        .(      CMP      r0,#1
        0x000010f2:    d005        ..      BEQ      0x1100 ; PAN216_SetRxMode + 22
        0x000010f4:    2802        .(      CMP      r0,#2
        0x000010f6:    d110        ..      BNE      0x111a ; PAN216_SetRxMode + 48
        0x000010f8:    e00c        ..      B        0x1114 ; PAN216_SetRxMode + 42
;;;318        {
;;;319        case PAN216_RX_MODE_SINGLE:
;;;320            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_RX_MODE_SINGLE,
        0x000010fa:    2360        `#      MOVS     r3,#0x60
        0x000010fc:    2200        ."      MOVS     r2,#0
        0x000010fe:    e001        ..      B        0x1104 ; PAN216_SetRxMode + 26
        0x00001100:    2360        `#      MOVS     r3,#0x60
        0x00001102:    2201        ."      MOVS     r2,#1
        0x00001104:    212a        *!      MOVS     r1,#0x2a
        0x00001106:    2000        .       MOVS     r0,#0
        0x00001108:    f000f97e    ..~.    BL       PAN216_WritePageRegBits ; 0x1408
        0x0000110c:    2800        .(      CMP      r0,#0
        0x0000110e:    d004        ..      BEQ      0x111a ; PAN216_SetRxMode + 48
;;;321                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;322            break;
;;;323        case PAN216_RX_MODE_SINGLE_WITH_TIMEOUT:
;;;324            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG,
;;;325                                             PAN216_RX_MODE_SINGLE_WITH_TIMEOUT,
;;;326                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;327            break;
;;;328        case PAN216_RX_MODE_CONTINOUS:
;;;329            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_RX_MODE_CONTINOUS,
        0x00001110:    2001        .       MOVS     r0,#1
        0x00001112:    bd10        ..      POP      {r4,pc}
        0x00001114:    2360        `#      MOVS     r3,#0x60
        0x00001116:    2202        ."      MOVS     r2,#2
        0x00001118:    e7f4        ..      B        0x1104 ; PAN216_SetRxMode + 26
;;;330                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;331            break;
;;;332        default:
;;;333            break;
;;;334        }
;;;335    
;;;336        return PAN216_OK;
        0x0000111a:    2000        .       MOVS     r0,#0
;;;337    }
        0x0000111c:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetRxPayloadLen
    PAN216_SetRxPayloadLen
;;;338    
;;;339    /**
;;;340     * @brief  Performs a soft reset of the PAN216 transceiver module.
;;;341     *
;;;342     * @param  None
;;;343     *
;;;344     * @return uint8_t Result of the operation
;;;345     *         - PAN216_OK
;;;346     *         - PAN216_ERR
;;;347     * @note This function is designed for general operations.
;;;348     */
;;;349    PAN216_Err_t PAN216_SoftReset(void)
;;;350    {
;;;351        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, STATE_CFG, 0, STATE_CFG_POR_NRSTL));
;;;352        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, SYS_CFG, 0, SYS_CFG_REG_SOFT_RSTL));
;;;353        Pan216_Funs.delayms(1);
;;;354        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, STATE_CFG, 1, STATE_CFG_POR_NRSTL));
;;;355        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, SYS_CFG, 1, SYS_CFG_REG_SOFT_RSTL));
;;;356    
;;;357        return PAN216_OK;
;;;358    }
;;;359    
;;;360    PAN216_State_t PAN216_GetState(void)
;;;361    {
;;;362        uint8_t idleFlag;
;;;363        PAN216_State_t State;
;;;364    
;;;365        idleFlag = PAN216_ReadReg(0x7D) >> 7; // bit7为1表示mac处于IDLE
;;;366        State = (PAN216_State_t)(PAN216_ReadReg(0x7F) >> 6);
;;;367    
;;;368        if (State == 0)
;;;369        {
;;;370            State = idleFlag > 0 ? PAN216_STATE_IDLE : PAN216_STATE_ARD_WAIT;
;;;371        }
;;;372    
;;;373        return State;
;;;374    }
;;;375    
;;;376    /**
;;;377     * @brief Writes the PAN216 transceiver's TX PID value of a enhanced shockburst packet
;;;378     *
;;;379     * @param Pid 0~3
;;;380     * @return PAN216_Err_t
;;;381     */
;;;382    PAN216_Err_t PAN216_WriteTxManualPid(uint8_t Pid)
;;;383    {
;;;384        PAN216_WriteRegBits(PID_CFG, Pid, PID_CFG_TX_PID_MANUAL);
;;;385    
;;;386        return PAN216_OK;
;;;387    }
;;;388    
;;;389    /**
;;;390     * @brief Writes the PAN216 transceiver's RX PID value of a enhanced shockburst packet
;;;391     *
;;;392     * @param Pid 0~3
;;;393     * @return PAN216_Err_t
;;;394     */
;;;395    PAN216_Err_t PAN216_WriteRxManualPid(uint8_t Pid)
;;;396    {
;;;397        PAN216_WriteRegBits(PID_CFG, Pid, PID_CFG_RX_PID_MANUAL);
;;;398    
;;;399        return PAN216_OK;
;;;400    }
;;;401    
;;;402    /**
;;;403     * @brief Sets the DynamicPayloadLength feature for all pipes of the PAN216 transceiver
;;;404     *
;;;405     * This function is used to enable or disable the DynamicPayloadLength feature for all
;;;406     * pipes of the PAN216 transceiver.
;;;407     *
;;;408     * @param NewState ENABLE to enable the feature, DISABLE to disable the feature
;;;409     *
;;;410     * @return uint8_t Result of the operation
;;;411     *         - PAN216_OK
;;;412     *         - PAN216_ERR
;;;413     */
;;;414    PAN216_Err_t PAN216_EnableDynamicPL(uint8_t NewState)
;;;415    {
;;;416        if (NewState)
;;;417        {
;;;418            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
;;;419        }
;;;420        else
;;;421        {
;;;422            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
;;;423        }
;;;424    
;;;425        return PAN216_OK;
;;;426    }
;;;427    
;;;428    /**
;;;429     * @brief Configures the CRC scheme of the PAN216 transceiver
;;;430     *
;;;431     * This function is used to configure the CRC scheme of the PAN216 transceiver.
;;;432     *
;;;433     * @param Crc The desired CRC scheme, as a value of type PAN216_Crc_t
;;;434     *
;;;435     * @note The transceiver will forcibly turn on the CRC if auto-acknowledgment is enabled
;;;436     *       for at least one receive (RX) pipe
;;;437     *
;;;438     * @return uint8_t Result of the operation
;;;439     *         - PAN216_OK
;;;440     *         - PAN216_ERR
;;;441     */
;;;442    PAN216_Err_t PAN216_SetCrcScheme(PAN216_Crc_t Crc)
;;;443    {
;;;444        if (Crc > PAN216_CRC_3byte)
;;;445        {
;;;446            return PAN216_ERR;
;;;447        }
;;;448    
;;;449        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Crc, WMODE_CFG0_CRC_MODE_1_0));
;;;450    
;;;451        return PAN216_OK;
;;;452    }
;;;453    
;;;454    /**
;;;455     * @brief Configures the data rate of the PAN216 transceiver
;;;456     *
;;;457     * This function is used to configure the data rate of the PAN216 transceiver. The
;;;458     * data rate is specified as one of the members of PAN216_DataRate_t.
;;;459     *
;;;460     * @param DataRate The desired data rate, as one of the members of PAN216_DataRate_t
;;;461     *
;;;462     * @return uint8_t Result of the operation
;;;463     *         - PAN216_OK
;;;464     *         - PAN216_ERR
;;;465     */
;;;466    PAN216_Err_t PAN216_SetDataRate(PAN216_DataRate_t DataRate)
;;;467    {
;;;468        uint8_t DataRateVal;
;;;469    
;;;470        if (DataRate >= PAN216_DR_Max)
;;;471        {
;;;472            return PAN216_ERR;
;;;473        }
;;;474    
;;;475        switch (DataRate)
;;;476        {
;;;477        case PAN216_DR_1Mbps:
;;;478            DataRateVal = 0x00;
;;;479            _gDataRate = PAN216_DR_1Mbps;
;;;480            break;
;;;481        case PAN216_DR_2Mbps:
;;;482            DataRateVal = 0x01;
;;;483            _gDataRate = PAN216_DR_2Mbps;
;;;484            break;
;;;485        case PAN216_DR_250Kbps:
;;;486            DataRateVal = 0x03;
;;;487            _gDataRate = PAN216_DR_250Kbps;
;;;488            break;
;;;489        default:
;;;490            return PAN216_ERR;
;;;491        }
;;;492    
;;;493        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, REG_P0_0X36, DataRateVal, REG_P0_0X36_BW_MODE));
;;;494    
;;;495        PAN216_DRModConfig();
;;;496        WriteTxDemodConfig();
;;;497        WriteRxDemodConfig();
;;;498        PAN216_Calibration();
;;;499    #if CALIBRATION_DEBUG_ON
;;;500        PAN216_ReadVCOCode();
;;;501        PAN216_ReadTpCode();
;;;502        ReadBWDcocCal(FILTER_OFFSET_CAL_MODE, 0);
;;;503        ReadBWDcocCal(FILTER_BW_CAL_MODE, 0);
;;;504        ReadBWDcocCal(FILTER_BW_CAL_MODE, 1);
;;;505        ReadBWDcocCal(FILTER_BW_CAL_MODE, 2);
;;;506        ReadBWDcocCal(FILTER_DCOC_CAL_MODE, 0);
;;;507    #endif
;;;508        PAN216_FinishCalibration();
;;;509        return PAN216_OK;
;;;510    }
;;;511    
;;;512    PAN216_Err_t PAN216_EnableRxPipe(PAN216_Pipe_t Pipe)
;;;513    {
;;;514        if (Pipe > PAN216_PIPE5)
;;;515        {
;;;516            return PAN216_ERR;
;;;517        }
;;;518    
;;;519        return PAN216_SetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;520    }
;;;521    
;;;522    PAN216_Err_t PAN216_DisableRxPipe(PAN216_Pipe_t Pipe)
;;;523    {
;;;524        if (Pipe > PAN216_PIPE5)
;;;525        {
;;;526            return PAN216_ERR;
;;;527        }
;;;528    
;;;529        return PAN216_ResetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;530    }
;;;531    
;;;532    /**
;;;533     * @brief Configure a specified RX pipe
;;;534     *
;;;535     * @param Pipe        Number of the RX pipe, value from 0 to 6
;;;536     * @param PayloadLen  Payload length in bytes
;;;537     *
;;;538     * @return Result of the operation
;;;539     *         - PAN216_OK
;;;540     *         - PAN216_ERR
;;;541     */
;;;542    PAN216_Err_t PAN216_SetRxPayloadLen(uint8_t PayloadLen)
;;;543    {
        0x0000111e:    b510        ..      PUSH     {r4,lr}
;;;544        return PAN216_WritePageReg(PAN216_PAGE0, RXPLLEN_CFG, PayloadLen);
        0x00001120:    4602        .F      MOV      r2,r0
        0x00001122:    2109        .!      MOVS     r1,#9
        0x00001124:    2000        .       MOVS     r0,#0
        0x00001126:    f000f94f    ..O.    BL       PAN216_WritePageReg ; 0x13c8
;;;545    }
        0x0000112a:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetTRxTransTime
    PAN216_SetTRxTransTime
;;;546    
;;;547    PAN216_Err_t PAN216_SetTxPayloadLen(uint8_t PayloadLen)
;;;548    {
;;;549        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXPLLEN_CFG, PayloadLen));
;;;550        return PAN216_OK;
;;;551    }
;;;552    
;;;553    /**
;;;554     * @brief Set enhanced shockburst mode for the PAN216 transceiver
;;;555     *
;;;556     * @param Mode Enhanced shockburst mode to set, one of PAN216_Mode_t values
;;;557     *
;;;558     * @return uint8_t Result of the operation
;;;559     *         - PAN216_OK
;;;560     *         - PAN216_ERR
;;;561     */
;;;562    PAN216_Err_t PAN216_SetWorkMode(PAN216_WorkMode_t Mode)
;;;563    {
;;;564    
;;;565        switch (Mode)
;;;566        {
;;;567        case PAN216_WORKMODE_NORMAL:
;;;568            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1,
;;;569                                         WMODE_CFG1_NORMAL_M1 | WMODE_CFG1_ENHANCE));
;;;570            break;
;;;571        case PAN216_WORKMODE_ENHANCE:
;;;572            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_ENHANCE));
;;;573            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;574            break;
;;;575        default:
;;;576            return PAN216_ERR;
;;;577        }
;;;578    
;;;579        return PAN216_OK;
;;;580    }
;;;581    
;;;582    PAN216_Err_t PAN216_GetChipMode(PAN216_ChipMode_t *chipMode)
;;;583    {
;;;584        *chipMode = (PAN216_ChipMode_t)_gChipMode;
;;;585        return PAN216_OK;
;;;586    }
;;;587    
;;;588    /**
;;;589     * @brief  This function set noack for tx
;;;590     * @param  NewState: ENABLE/DISABLE
;;;591     * @return Result of the operation
;;;592     *         - PAN216_OK
;;;593     *         - PAN216_ERR
;;;594     * @note  This function is called after PAN216_SetWorkMode
;;;595     */
;;;596    PAN216_Err_t PAN216_EnableTxNoAck(uint8_t NewState)
;;;597    {
;;;598        uint8_t modeCfg1 = PAN216_ReadPageReg(PAN216_PAGE0, WMODE_CFG1);
;;;599    
;;;600        if (modeCfg1 & WMODE_CFG1_ENHANCE)
;;;601        {
;;;602            if (NewState)
;;;603            {
;;;604                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;605            }
;;;606            else
;;;607            {
;;;608                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;609            }
;;;610            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;611        }
;;;612        else
;;;613        {
;;;614            if (NewState)
;;;615            {
;;;616                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;617            }
;;;618            else
;;;619            {
;;;620                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;621            }
;;;622            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;623        }
;;;624    
;;;625        return PAN216_OK;
;;;626    }
;;;627    
;;;628    /**
;;;629     * @brief After receiving a packet, reads the TxNoack bit of a enhanced shockburst packet
;;;630     *
;;;631     * @return uint8_t  1 : rx need ack
;;;632     *                  0 : rx need no ack
;;;633     */
;;;634    uint8_t PAN216_ReadTxNoackBit(void)
;;;635    {
;;;636        return !(PAN216_ReadReg(0x7D) & BIT6);
;;;637    }
;;;638    
;;;639    PAN216_Err_t PAN216_SetAckPipe(uint8_t pipe)
;;;640    {
;;;641        if (pipe > 5)
;;;642        {
;;;643            return PAN216_ERR;
;;;644        }
;;;645    
;;;646        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, pipe, 0x07));
;;;647    
;;;648        return PAN216_OK;
;;;649    }
;;;650    
;;;651    /**
;;;652     * @brief Enable CRC calculation for address field in PAN216.
;;;653     *
;;;654     * This function allows enabling or disabling
;;;655     *  CRC calculation for the address field in PAN216.
;;;656     *
;;;657     * @note By default, address field is not included in CRC calculation.
;;;658     *
;;;659     * @param[in] NewState Boolean value indicating whether to enable or disable CRC calculation for
;;;660     * address field.
;;;661     *
;;;662     * @return Result of the operation:
;;;663     *         - PAN216_OK
;;;664     *         - PAN216_ERR
;;;665     */
;;;666    PAN216_Err_t PAN216_CrcSkipAddr(bool exclude)
;;;667    {
;;;668        if (exclude)
;;;669        {
;;;670            return PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;671        }
;;;672        else
;;;673        {
;;;674            return PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;675        }
;;;676    }
;;;677    
;;;678    /**
;;;679     * @brief whiten(scramble) configurations
;;;680     * @param addr_excluded  whiten exclude access address(already include header, payload, crc)
;;;681     * @param initital_phase initital whiten phase
;;;682     *        - channel 37: 0x53
;;;683              - channel 38: 0x33
;;;684              - channel 39: 0x73
;;;685     * @return PAN216_Err_t
;;;686     */
;;;687    PAN216_Err_t PAN216_WhiteSkipAddr(bool addr_excluded)
;;;688    {
;;;689        PAN216_Err_t ret;
;;;690    
;;;691        if (addr_excluded)
;;;692        {
;;;693            ret = PAN216_SetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;694        }
;;;695        else
;;;696        {
;;;697            ret = PAN216_ResetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;698        }
;;;699    
;;;700        return ret;
;;;701    }
;;;702    
;;;703    /**
;;;704     * @brief
;;;705     *
;;;706     * @param Endian
;;;707     * @return uint8_t
;;;708     */
;;;709    PAN216_Err_t PAN216_SetEndian(PAN216_Endian_t Endian)
;;;710    {
;;;711    
;;;712        if (Endian == PAN216_ENDIAN_LITTLE)
;;;713        {
;;;714            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 1,
;;;715                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;716        }
;;;717        else
;;;718        {
;;;719            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 0,
;;;720                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;721        }
;;;722    
;;;723        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Endian, WMODE_CFG0_ENDIAN));
;;;724    
;;;725        return PAN216_OK;
;;;726    }
;;;727    
;;;728    PAN216_Err_t PAN216_EnableWhiten(bool NewState)
;;;729    {
;;;730        if (NewState)
;;;731        {
;;;732            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_SCR_ENABLE));
;;;733        }
;;;734        else
;;;735        {
;;;736            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_SCR_ENABLE));
;;;737        }
;;;738    
;;;739        return PAN216_OK;
;;;740    }
;;;741    
;;;742    /**
;;;743     * @brief  This function open the white list filtering functions
;;;744     * @param  Start : filtering the starting position
;;;745     * @param  FilterBuf : content of the filter
;;;746     * @param  FilterLen : 0 <= filter_len <= 6
;;;747     * @return Result of the operation:
;;;748     *         - PAN216_OK
;;;749     *         - PAN216_ERR
;;;750     */
;;;751    PAN216_Err_t PAN216_SetBleWhitelist(uint8_t Start, uint8_t *FilterBuf, uint8_t FilterLen)
;;;752    {
;;;753        uint8_t start_reg = WLIST0_CFG + 5;
;;;754    
;;;755        if (FilterLen > 6)
;;;756        {
;;;757            return PAN216_ERR;
;;;758        }
;;;759    
;;;760        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, BLEMATCHSTART_CFG, Start,
;;;761                                         BLEMATCHSTART_CFG_PLD_START_BYTE));
;;;762        start_reg -= (FilterLen - 1);
;;;763        P_ASSERT(PAN216_WritePageRegs(PAN216_PAGE0, start_reg, FilterBuf, FilterLen));
;;;764        return PAN216_OK;
;;;765    }
;;;766    
;;;767    /**
;;;768     * @brief  This function open the white list filtering functions
;;;769     * @param  FilterType : filtering type
;;;770     * @param  FilterLen : filter the number of bytes
;;;771     * @return Result of the operation:
;;;772     *         - PAN216_OK
;;;773     *         - PAN216_ERR
;;;774     */
;;;775    PAN216_Err_t PAN216_SetBleLenFilter(PAN216_BleLenFilter_t FilterType)
;;;776    {
;;;777        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, BLEMATCH_CFG0, FilterType,
;;;778                                         BLEMATCH_CFG0_BLELEN_MATCH_MODE));
;;;779    
;;;780        return PAN216_OK;
;;;781    }
;;;782    
;;;783    PAN216_Err_t PAN216_SetBleWLMatchMode(PAN216_BLEWLMatchMode_t MatchMode)
;;;784    {
;;;785        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, BLEMATCH_CFG0, MatchMode,
;;;786                                         BLEMATCH_CFG0_WL_MATCH_MODE));
;;;787    
;;;788        return PAN216_OK;
;;;789    }
;;;790    
;;;791    /**
;;;792     * @brief Enables or disables the manual configuration of the PAN216 TX and RX PID.
;;;793     *
;;;794     * @param NewState The new state of the manual configuration.
;;;795     *                  This parameter can be ENABLE or DISABLE.
;;;796     * @return Result of the operation.
;;;797     *         - PAN216_OK.
;;;798     *         - PAN216_ERR.
;;;799     *
;;;800     * @note This function is used to enable or disable the manual configuration of the PAN216 TX and RX
;;;801     * PIDs. By default, manual configuration is disabled.
;;;802     */
;;;803    PAN216_Err_t PAN216_EnableManualPid(uint8_t NewState)
;;;804    {
;;;805        if (NewState)
;;;806            return PAN216_WritePageRegBits(PAN216_PAGE0, PID_CFG, 1, PID_CFG_PID_MANUAL_EN);
;;;807        else
;;;808            return PAN216_WritePageRegBits(PAN216_PAGE0, PID_CFG, 0, PID_CFG_PID_MANUAL_EN);
;;;809    }
;;;810    
;;;811    /**
;;;812     * @brief This function set the timeout period for the tx node
;;;813     *         to wait for an ACK during enhanced mode.
;;;814     * @param AckTimeoutUs: 0~65535us
;;;815     * @return Result of the operation.
;;;816     *         - PAN216_OK.
;;;817     *         - PAN216_ERR.
;;;818     * @note This function must be called after RF_SetRate.
;;;819     */
;;;820    PAN216_Err_t PAN216_SetWaitAckTimeout(u16 AckTimeoutUs)
;;;821    {
;;;822        uint8_t time[2] = {
;;;823            (uint8_t)(AckTimeoutUs & 0xff),
;;;824            (uint8_t)((AckTimeoutUs >> 8) & 0xff),
;;;825        };
;;;826    
;;;827        return PAN216_WritePageRegs(PAN216_PAGE0, RXTIMEOUTL_CFG, time, 2);
;;;828    }
;;;829    
;;;830    /**
;;;831     * @brief This function set the timeout period for the tx node
;;;832     *         to wait for an ACK during enhanced mode.
;;;833     * @param TransWaitTime: 0~32767us
;;;834     * @return Result of the operation.
;;;835     *         - PAN216_OK.
;;;836     *         - PAN216_ERR.
;;;837     * @note This function must be called after RF_SetRate.
;;;838     */
;;;839    PAN216_Err_t PAN216_SetTRxTransTime(u16 TransWaitTimeUs)
;;;840    {
        0x0000112c:    b508        ..      PUSH     {r3,lr}
;;;841        uint8_t time[2] = {
        0x0000112e:    4669        iF      MOV      r1,sp
        0x00001130:    7008        .p      STRB     r0,[r1,#0]
        0x00001132:    0a00        ..      LSRS     r0,r0,#8
        0x00001134:    7048        Hp      STRB     r0,[r1,#1]
;;;842            (uint8_t)(TransWaitTimeUs & 0xff),
;;;843            (uint8_t)((TransWaitTimeUs >> 8) & 0xff),
;;;844        };
;;;845    
;;;846        return PAN216_WritePageRegs(PAN216_PAGE0, TRXTWTL_CFG, time, 2);
        0x00001136:    2302        .#      MOVS     r3,#2
        0x00001138:    466a        jF      MOV      r2,sp
        0x0000113a:    210d        .!      MOVS     r1,#0xd
        0x0000113c:    2000        .       MOVS     r0,#0
        0x0000113e:    f000f97a    ..z.    BL       PAN216_WritePageRegs ; 0x1436
;;;847    }
        0x00001142:    bd08        ..      POP      {r3,pc}
    i.PAN216_SetTxAddr
    PAN216_SetTxAddr
;;; ..\..\..\..\radio\pan216.c
;;;442        return PAN216_WriteRegs(TXADDR0_CFG, Addr, len);
        0x00001144:    460a        .F      MOV      r2,r1
;;; ..\..\..\..\radio\pan216.c (441)
        0x00001146:    b510        ..      PUSH     {r4,lr}
;;;442        return PAN216_WriteRegs(TXADDR0_CFG, Addr, len);
        0x00001148:    4601        .F      MOV      r1,r0
        0x0000114a:    2014        .       MOVS     r0,#0x14
        0x0000114c:    f000f9f5    ....    BL       PAN216_WriteRegs ; 0x153a
;;;443    }
        0x00001150:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetTxMode
    PAN216_SetTxMode
;;; ..\..\..\..\radio\pan216_ext.c
;;;284    {
        0x00001152:    b510        ..      PUSH     {r4,lr}
        0x00001154:    2800        .(      CMP      r0,#0
        0x00001156:    d002        ..      BEQ      0x115e ; PAN216_SetTxMode + 12
;;;285        switch (TxMode)
        0x00001158:    2801        .(      CMP      r0,#1
        0x0000115a:    d10b        ..      BNE      0x1174 ; PAN216_SetTxMode + 34
        0x0000115c:    e002        ..      B        0x1164 ; PAN216_SetTxMode + 18
;;;286        {
;;;287        case PAN216_TX_MODE_SINGLE:
;;;288            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_TX_MODE_SINGLE,
        0x0000115e:    2380        .#      MOVS     r3,#0x80
        0x00001160:    2200        ."      MOVS     r2,#0
        0x00001162:    e001        ..      B        0x1168 ; PAN216_SetTxMode + 22
        0x00001164:    2380        .#      MOVS     r3,#0x80
        0x00001166:    2201        ."      MOVS     r2,#1
        0x00001168:    212a        *!      MOVS     r1,#0x2a
        0x0000116a:    2000        .       MOVS     r0,#0
        0x0000116c:    f000f94c    ..L.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00001170:    2800        .(      CMP      r0,#0
        0x00001172:    d000        ..      BEQ      0x1176 ; PAN216_SetTxMode + 36
;;;289                                             TRXMODE_CFG_REG_TX_CFG_MODE));
;;;290            break;
;;;291        case PAN216_TX_MODE_CONTINOUS:
;;;292            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_TX_MODE_CONTINOUS,
;;;293                                             TRXMODE_CFG_REG_TX_CFG_MODE));
;;;294            break;
;;;295        default:
;;;296            return PAN216_ERR;
        0x00001174:    2001        .       MOVS     r0,#1
;;;297        }
;;;298    
;;;299        return PAN216_OK;
;;;300    }
        0x00001176:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetTxPayloadLen
    PAN216_SetTxPayloadLen
;;;301    
;;;302    /**
;;;303     * @brief Set the receive mode of PAN216 transceiver.It has to be initialized  as STB3 mode before
;;;304     * entering RX mode.
;;;305     *
;;;306     * @param TxMode The receive mode to be set.
;;;307     *        - PAN216_RX_MODE_SINGLE: single reception
;;;308     *        - PAN216_RX_MODE_SINGLE_WITH_TIMEOUT: single reception with timeout
;;;309     *        - PAN216_RX_MODE_CONTINOUS: continuous reception
;;;310     *
;;;311     * @return Result of the operation
;;;312     *         - PAN216_OK
;;;313     *         - PAN216_ERR
;;;314     */
;;;315    PAN216_Err_t PAN216_SetRxMode(PAN216_RxMode_t RxMode)
;;;316    {
;;;317        switch (RxMode)
;;;318        {
;;;319        case PAN216_RX_MODE_SINGLE:
;;;320            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_RX_MODE_SINGLE,
;;;321                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;322            break;
;;;323        case PAN216_RX_MODE_SINGLE_WITH_TIMEOUT:
;;;324            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG,
;;;325                                             PAN216_RX_MODE_SINGLE_WITH_TIMEOUT,
;;;326                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;327            break;
;;;328        case PAN216_RX_MODE_CONTINOUS:
;;;329            P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, PAN216_RX_MODE_CONTINOUS,
;;;330                                             TRXMODE_CFG_REG_RX_CFG_MODE));
;;;331            break;
;;;332        default:
;;;333            break;
;;;334        }
;;;335    
;;;336        return PAN216_OK;
;;;337    }
;;;338    
;;;339    /**
;;;340     * @brief  Performs a soft reset of the PAN216 transceiver module.
;;;341     *
;;;342     * @param  None
;;;343     *
;;;344     * @return uint8_t Result of the operation
;;;345     *         - PAN216_OK
;;;346     *         - PAN216_ERR
;;;347     * @note This function is designed for general operations.
;;;348     */
;;;349    PAN216_Err_t PAN216_SoftReset(void)
;;;350    {
;;;351        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, STATE_CFG, 0, STATE_CFG_POR_NRSTL));
;;;352        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, SYS_CFG, 0, SYS_CFG_REG_SOFT_RSTL));
;;;353        Pan216_Funs.delayms(1);
;;;354        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, STATE_CFG, 1, STATE_CFG_POR_NRSTL));
;;;355        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, SYS_CFG, 1, SYS_CFG_REG_SOFT_RSTL));
;;;356    
;;;357        return PAN216_OK;
;;;358    }
;;;359    
;;;360    PAN216_State_t PAN216_GetState(void)
;;;361    {
;;;362        uint8_t idleFlag;
;;;363        PAN216_State_t State;
;;;364    
;;;365        idleFlag = PAN216_ReadReg(0x7D) >> 7; // bit7为1表示mac处于IDLE
;;;366        State = (PAN216_State_t)(PAN216_ReadReg(0x7F) >> 6);
;;;367    
;;;368        if (State == 0)
;;;369        {
;;;370            State = idleFlag > 0 ? PAN216_STATE_IDLE : PAN216_STATE_ARD_WAIT;
;;;371        }
;;;372    
;;;373        return State;
;;;374    }
;;;375    
;;;376    /**
;;;377     * @brief Writes the PAN216 transceiver's TX PID value of a enhanced shockburst packet
;;;378     *
;;;379     * @param Pid 0~3
;;;380     * @return PAN216_Err_t
;;;381     */
;;;382    PAN216_Err_t PAN216_WriteTxManualPid(uint8_t Pid)
;;;383    {
;;;384        PAN216_WriteRegBits(PID_CFG, Pid, PID_CFG_TX_PID_MANUAL);
;;;385    
;;;386        return PAN216_OK;
;;;387    }
;;;388    
;;;389    /**
;;;390     * @brief Writes the PAN216 transceiver's RX PID value of a enhanced shockburst packet
;;;391     *
;;;392     * @param Pid 0~3
;;;393     * @return PAN216_Err_t
;;;394     */
;;;395    PAN216_Err_t PAN216_WriteRxManualPid(uint8_t Pid)
;;;396    {
;;;397        PAN216_WriteRegBits(PID_CFG, Pid, PID_CFG_RX_PID_MANUAL);
;;;398    
;;;399        return PAN216_OK;
;;;400    }
;;;401    
;;;402    /**
;;;403     * @brief Sets the DynamicPayloadLength feature for all pipes of the PAN216 transceiver
;;;404     *
;;;405     * This function is used to enable or disable the DynamicPayloadLength feature for all
;;;406     * pipes of the PAN216 transceiver.
;;;407     *
;;;408     * @param NewState ENABLE to enable the feature, DISABLE to disable the feature
;;;409     *
;;;410     * @return uint8_t Result of the operation
;;;411     *         - PAN216_OK
;;;412     *         - PAN216_ERR
;;;413     */
;;;414    PAN216_Err_t PAN216_EnableDynamicPL(uint8_t NewState)
;;;415    {
;;;416        if (NewState)
;;;417        {
;;;418            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
;;;419        }
;;;420        else
;;;421        {
;;;422            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_DPY_EN));
;;;423        }
;;;424    
;;;425        return PAN216_OK;
;;;426    }
;;;427    
;;;428    /**
;;;429     * @brief Configures the CRC scheme of the PAN216 transceiver
;;;430     *
;;;431     * This function is used to configure the CRC scheme of the PAN216 transceiver.
;;;432     *
;;;433     * @param Crc The desired CRC scheme, as a value of type PAN216_Crc_t
;;;434     *
;;;435     * @note The transceiver will forcibly turn on the CRC if auto-acknowledgment is enabled
;;;436     *       for at least one receive (RX) pipe
;;;437     *
;;;438     * @return uint8_t Result of the operation
;;;439     *         - PAN216_OK
;;;440     *         - PAN216_ERR
;;;441     */
;;;442    PAN216_Err_t PAN216_SetCrcScheme(PAN216_Crc_t Crc)
;;;443    {
;;;444        if (Crc > PAN216_CRC_3byte)
;;;445        {
;;;446            return PAN216_ERR;
;;;447        }
;;;448    
;;;449        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Crc, WMODE_CFG0_CRC_MODE_1_0));
;;;450    
;;;451        return PAN216_OK;
;;;452    }
;;;453    
;;;454    /**
;;;455     * @brief Configures the data rate of the PAN216 transceiver
;;;456     *
;;;457     * This function is used to configure the data rate of the PAN216 transceiver. The
;;;458     * data rate is specified as one of the members of PAN216_DataRate_t.
;;;459     *
;;;460     * @param DataRate The desired data rate, as one of the members of PAN216_DataRate_t
;;;461     *
;;;462     * @return uint8_t Result of the operation
;;;463     *         - PAN216_OK
;;;464     *         - PAN216_ERR
;;;465     */
;;;466    PAN216_Err_t PAN216_SetDataRate(PAN216_DataRate_t DataRate)
;;;467    {
;;;468        uint8_t DataRateVal;
;;;469    
;;;470        if (DataRate >= PAN216_DR_Max)
;;;471        {
;;;472            return PAN216_ERR;
;;;473        }
;;;474    
;;;475        switch (DataRate)
;;;476        {
;;;477        case PAN216_DR_1Mbps:
;;;478            DataRateVal = 0x00;
;;;479            _gDataRate = PAN216_DR_1Mbps;
;;;480            break;
;;;481        case PAN216_DR_2Mbps:
;;;482            DataRateVal = 0x01;
;;;483            _gDataRate = PAN216_DR_2Mbps;
;;;484            break;
;;;485        case PAN216_DR_250Kbps:
;;;486            DataRateVal = 0x03;
;;;487            _gDataRate = PAN216_DR_250Kbps;
;;;488            break;
;;;489        default:
;;;490            return PAN216_ERR;
;;;491        }
;;;492    
;;;493        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, REG_P0_0X36, DataRateVal, REG_P0_0X36_BW_MODE));
;;;494    
;;;495        PAN216_DRModConfig();
;;;496        WriteTxDemodConfig();
;;;497        WriteRxDemodConfig();
;;;498        PAN216_Calibration();
;;;499    #if CALIBRATION_DEBUG_ON
;;;500        PAN216_ReadVCOCode();
;;;501        PAN216_ReadTpCode();
;;;502        ReadBWDcocCal(FILTER_OFFSET_CAL_MODE, 0);
;;;503        ReadBWDcocCal(FILTER_BW_CAL_MODE, 0);
;;;504        ReadBWDcocCal(FILTER_BW_CAL_MODE, 1);
;;;505        ReadBWDcocCal(FILTER_BW_CAL_MODE, 2);
;;;506        ReadBWDcocCal(FILTER_DCOC_CAL_MODE, 0);
;;;507    #endif
;;;508        PAN216_FinishCalibration();
;;;509        return PAN216_OK;
;;;510    }
;;;511    
;;;512    PAN216_Err_t PAN216_EnableRxPipe(PAN216_Pipe_t Pipe)
;;;513    {
;;;514        if (Pipe > PAN216_PIPE5)
;;;515        {
;;;516            return PAN216_ERR;
;;;517        }
;;;518    
;;;519        return PAN216_SetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;520    }
;;;521    
;;;522    PAN216_Err_t PAN216_DisableRxPipe(PAN216_Pipe_t Pipe)
;;;523    {
;;;524        if (Pipe > PAN216_PIPE5)
;;;525        {
;;;526            return PAN216_ERR;
;;;527        }
;;;528    
;;;529        return PAN216_ResetRegBits(PAN216_PAGE0, RXPIPE_CFG, 1 << Pipe);
;;;530    }
;;;531    
;;;532    /**
;;;533     * @brief Configure a specified RX pipe
;;;534     *
;;;535     * @param Pipe        Number of the RX pipe, value from 0 to 6
;;;536     * @param PayloadLen  Payload length in bytes
;;;537     *
;;;538     * @return Result of the operation
;;;539     *         - PAN216_OK
;;;540     *         - PAN216_ERR
;;;541     */
;;;542    PAN216_Err_t PAN216_SetRxPayloadLen(uint8_t PayloadLen)
;;;543    {
;;;544        return PAN216_WritePageReg(PAN216_PAGE0, RXPLLEN_CFG, PayloadLen);
;;;545    }
;;;546    
;;;547    PAN216_Err_t PAN216_SetTxPayloadLen(uint8_t PayloadLen)
;;;548    {
        0x00001178:    b510        ..      PUSH     {r4,lr}
;;;549        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXPLLEN_CFG, PayloadLen));
        0x0000117a:    4602        .F      MOV      r2,r0
        0x0000117c:    210a        .!      MOVS     r1,#0xa
        0x0000117e:    2000        .       MOVS     r0,#0
        0x00001180:    f000f922    ..".    BL       PAN216_WritePageReg ; 0x13c8
        0x00001184:    2800        .(      CMP      r0,#0
        0x00001186:    d000        ..      BEQ      0x118a ; PAN216_SetTxPayloadLen + 18
        0x00001188:    2001        .       MOVS     r0,#1
;;;550        return PAN216_OK;
;;;551    }
        0x0000118a:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetTxPower
    PAN216_SetTxPower
;;;552    
;;;553    /**
;;;554     * @brief Set enhanced shockburst mode for the PAN216 transceiver
;;;555     *
;;;556     * @param Mode Enhanced shockburst mode to set, one of PAN216_Mode_t values
;;;557     *
;;;558     * @return uint8_t Result of the operation
;;;559     *         - PAN216_OK
;;;560     *         - PAN216_ERR
;;;561     */
;;;562    PAN216_Err_t PAN216_SetWorkMode(PAN216_WorkMode_t Mode)
;;;563    {
;;;564    
;;;565        switch (Mode)
;;;566        {
;;;567        case PAN216_WORKMODE_NORMAL:
;;;568            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1,
;;;569                                         WMODE_CFG1_NORMAL_M1 | WMODE_CFG1_ENHANCE));
;;;570            break;
;;;571        case PAN216_WORKMODE_ENHANCE:
;;;572            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_ENHANCE));
;;;573            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;574            break;
;;;575        default:
;;;576            return PAN216_ERR;
;;;577        }
;;;578    
;;;579        return PAN216_OK;
;;;580    }
;;;581    
;;;582    PAN216_Err_t PAN216_GetChipMode(PAN216_ChipMode_t *chipMode)
;;;583    {
;;;584        *chipMode = (PAN216_ChipMode_t)_gChipMode;
;;;585        return PAN216_OK;
;;;586    }
;;;587    
;;;588    /**
;;;589     * @brief  This function set noack for tx
;;;590     * @param  NewState: ENABLE/DISABLE
;;;591     * @return Result of the operation
;;;592     *         - PAN216_OK
;;;593     *         - PAN216_ERR
;;;594     * @note  This function is called after PAN216_SetWorkMode
;;;595     */
;;;596    PAN216_Err_t PAN216_EnableTxNoAck(uint8_t NewState)
;;;597    {
;;;598        uint8_t modeCfg1 = PAN216_ReadPageReg(PAN216_PAGE0, WMODE_CFG1);
;;;599    
;;;600        if (modeCfg1 & WMODE_CFG1_ENHANCE)
;;;601        {
;;;602            if (NewState)
;;;603            {
;;;604                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;605            }
;;;606            else
;;;607            {
;;;608                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;609            }
;;;610            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;611        }
;;;612        else
;;;613        {
;;;614            if (NewState)
;;;615            {
;;;616                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;617            }
;;;618            else
;;;619            {
;;;620                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;621            }
;;;622            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;623        }
;;;624    
;;;625        return PAN216_OK;
;;;626    }
;;;627    
;;;628    /**
;;;629     * @brief After receiving a packet, reads the TxNoack bit of a enhanced shockburst packet
;;;630     *
;;;631     * @return uint8_t  1 : rx need ack
;;;632     *                  0 : rx need no ack
;;;633     */
;;;634    uint8_t PAN216_ReadTxNoackBit(void)
;;;635    {
;;;636        return !(PAN216_ReadReg(0x7D) & BIT6);
;;;637    }
;;;638    
;;;639    PAN216_Err_t PAN216_SetAckPipe(uint8_t pipe)
;;;640    {
;;;641        if (pipe > 5)
;;;642        {
;;;643            return PAN216_ERR;
;;;644        }
;;;645    
;;;646        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, pipe, 0x07));
;;;647    
;;;648        return PAN216_OK;
;;;649    }
;;;650    
;;;651    /**
;;;652     * @brief Enable CRC calculation for address field in PAN216.
;;;653     *
;;;654     * This function allows enabling or disabling
;;;655     *  CRC calculation for the address field in PAN216.
;;;656     *
;;;657     * @note By default, address field is not included in CRC calculation.
;;;658     *
;;;659     * @param[in] NewState Boolean value indicating whether to enable or disable CRC calculation for
;;;660     * address field.
;;;661     *
;;;662     * @return Result of the operation:
;;;663     *         - PAN216_OK
;;;664     *         - PAN216_ERR
;;;665     */
;;;666    PAN216_Err_t PAN216_CrcSkipAddr(bool exclude)
;;;667    {
;;;668        if (exclude)
;;;669        {
;;;670            return PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;671        }
;;;672        else
;;;673        {
;;;674            return PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;675        }
;;;676    }
;;;677    
;;;678    /**
;;;679     * @brief whiten(scramble) configurations
;;;680     * @param addr_excluded  whiten exclude access address(already include header, payload, crc)
;;;681     * @param initital_phase initital whiten phase
;;;682     *        - channel 37: 0x53
;;;683              - channel 38: 0x33
;;;684              - channel 39: 0x73
;;;685     * @return PAN216_Err_t
;;;686     */
;;;687    PAN216_Err_t PAN216_WhiteSkipAddr(bool addr_excluded)
;;;688    {
;;;689        PAN216_Err_t ret;
;;;690    
;;;691        if (addr_excluded)
;;;692        {
;;;693            ret = PAN216_SetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;694        }
;;;695        else
;;;696        {
;;;697            ret = PAN216_ResetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
;;;698        }
;;;699    
;;;700        return ret;
;;;701    }
;;;702    
;;;703    /**
;;;704     * @brief
;;;705     *
;;;706     * @param Endian
;;;707     * @return uint8_t
;;;708     */
;;;709    PAN216_Err_t PAN216_SetEndian(PAN216_Endian_t Endian)
;;;710    {
;;;711    
;;;712        if (Endian == PAN216_ENDIAN_LITTLE)
;;;713        {
;;;714            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 1,
;;;715                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;716        }
;;;717        else
;;;718        {
;;;719            PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, 0,
;;;720                                    BIT4); // 默认为0，pid在中间；配置为1时，pid在最低两位
;;;721        }
;;;722    
;;;723        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, Endian, WMODE_CFG0_ENDIAN));
;;;724    
;;;725        return PAN216_OK;
;;;726    }
;;;727    
;;;728    PAN216_Err_t PAN216_EnableWhiten(bool NewState)
;;;729    {
;;;730        if (NewState)
;;;731        {
;;;732            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_SCR_ENABLE));
;;;733        }
;;;734        else
;;;735        {
;;;736            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_SCR_ENABLE));
;;;737        }
;;;738    
;;;739        return PAN216_OK;
;;;740    }
;;;741    
;;;742    /**
;;;743     * @brief  This function open the white list filtering functions
;;;744     * @param  Start : filtering the starting position
;;;745     * @param  FilterBuf : content of the filter
;;;746     * @param  FilterLen : 0 <= filter_len <= 6
;;;747     * @return Result of the operation:
;;;748     *         - PAN216_OK
;;;749     *         - PAN216_ERR
;;;750     */
;;;751    PAN216_Err_t PAN216_SetBleWhitelist(uint8_t Start, uint8_t *FilterBuf, uint8_t FilterLen)
;;;752    {
;;;753        uint8_t start_reg = WLIST0_CFG + 5;
;;;754    
;;;755        if (FilterLen > 6)
;;;756        {
;;;757            return PAN216_ERR;
;;;758        }
;;;759    
;;;760        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, BLEMATCHSTART_CFG, Start,
;;;761                                         BLEMATCHSTART_CFG_PLD_START_BYTE));
;;;762        start_reg -= (FilterLen - 1);
;;;763        P_ASSERT(PAN216_WritePageRegs(PAN216_PAGE0, start_reg, FilterBuf, FilterLen));
;;;764        return PAN216_OK;
;;;765    }
;;;766    
;;;767    /**
;;;768     * @brief  This function open the white list filtering functions
;;;769     * @param  FilterType : filtering type
;;;770     * @param  FilterLen : filter the number of bytes
;;;771     * @return Result of the operation:
;;;772     *         - PAN216_OK
;;;773     *         - PAN216_ERR
;;;774     */
;;;775    PAN216_Err_t PAN216_SetBleLenFilter(PAN216_BleLenFilter_t FilterType)
;;;776    {
;;;777        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, BLEMATCH_CFG0, FilterType,
;;;778                                         BLEMATCH_CFG0_BLELEN_MATCH_MODE));
;;;779    
;;;780        return PAN216_OK;
;;;781    }
;;;782    
;;;783    PAN216_Err_t PAN216_SetBleWLMatchMode(PAN216_BLEWLMatchMode_t MatchMode)
;;;784    {
;;;785        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, BLEMATCH_CFG0, MatchMode,
;;;786                                         BLEMATCH_CFG0_WL_MATCH_MODE));
;;;787    
;;;788        return PAN216_OK;
;;;789    }
;;;790    
;;;791    /**
;;;792     * @brief Enables or disables the manual configuration of the PAN216 TX and RX PID.
;;;793     *
;;;794     * @param NewState The new state of the manual configuration.
;;;795     *                  This parameter can be ENABLE or DISABLE.
;;;796     * @return Result of the operation.
;;;797     *         - PAN216_OK.
;;;798     *         - PAN216_ERR.
;;;799     *
;;;800     * @note This function is used to enable or disable the manual configuration of the PAN216 TX and RX
;;;801     * PIDs. By default, manual configuration is disabled.
;;;802     */
;;;803    PAN216_Err_t PAN216_EnableManualPid(uint8_t NewState)
;;;804    {
;;;805        if (NewState)
;;;806            return PAN216_WritePageRegBits(PAN216_PAGE0, PID_CFG, 1, PID_CFG_PID_MANUAL_EN);
;;;807        else
;;;808            return PAN216_WritePageRegBits(PAN216_PAGE0, PID_CFG, 0, PID_CFG_PID_MANUAL_EN);
;;;809    }
;;;810    
;;;811    /**
;;;812     * @brief This function set the timeout period for the tx node
;;;813     *         to wait for an ACK during enhanced mode.
;;;814     * @param AckTimeoutUs: 0~65535us
;;;815     * @return Result of the operation.
;;;816     *         - PAN216_OK.
;;;817     *         - PAN216_ERR.
;;;818     * @note This function must be called after RF_SetRate.
;;;819     */
;;;820    PAN216_Err_t PAN216_SetWaitAckTimeout(u16 AckTimeoutUs)
;;;821    {
;;;822        uint8_t time[2] = {
;;;823            (uint8_t)(AckTimeoutUs & 0xff),
;;;824            (uint8_t)((AckTimeoutUs >> 8) & 0xff),
;;;825        };
;;;826    
;;;827        return PAN216_WritePageRegs(PAN216_PAGE0, RXTIMEOUTL_CFG, time, 2);
;;;828    }
;;;829    
;;;830    /**
;;;831     * @brief This function set the timeout period for the tx node
;;;832     *         to wait for an ACK during enhanced mode.
;;;833     * @param TransWaitTime: 0~32767us
;;;834     * @return Result of the operation.
;;;835     *         - PAN216_OK.
;;;836     *         - PAN216_ERR.
;;;837     * @note This function must be called after RF_SetRate.
;;;838     */
;;;839    PAN216_Err_t PAN216_SetTRxTransTime(u16 TransWaitTimeUs)
;;;840    {
;;;841        uint8_t time[2] = {
;;;842            (uint8_t)(TransWaitTimeUs & 0xff),
;;;843            (uint8_t)((TransWaitTimeUs >> 8) & 0xff),
;;;844        };
;;;845    
;;;846        return PAN216_WritePageRegs(PAN216_PAGE0, TRXTWTL_CFG, time, 2);
;;;847    }
;;;848    
;;;849    /**
;;;850     * @brief Set automatic retransmission parameters.
;;;851     *
;;;852     * @param DelayUs Auto retransmit delay, value from 250 to 4000, unit is us.
;;;853     * @param MaxCnt Count of auto retransmits, value from 0 to 15.
;;;854     *         Zero value means that the automatic retransmission is disabled.
;;;855     * @return Result of the operation.
;;;856     *         - PAN216_OK.
;;;857     *         - PAN216_ERR.
;;;858     */
;;;859    PAN216_Err_t PAN216_SetAutoRetrans(u16 DelayUs, uint8_t MaxCnt)
;;;860    {
;;;861        if (DelayUs < 250)
;;;862        {
;;;863            DelayUs = 250;
;;;864        }
;;;865    
;;;866        DelayUs /= 250;
;;;867        DelayUs--;
;;;868    
;;;869        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TXAUTO_CFG, (uint8_t)DelayUs, TXAUTO_CFG_ARD));
;;;870        P_ASSERT(
;;;871            PAN216_WritePageRegBits(PAN216_PAGE0, TXAUTO_CFG, (uint8_t)MaxCnt, TXAUTO_CFG_ARC_3_0));
;;;872    
;;;873        return PAN216_OK;
;;;874    }
;;;875    
;;;876    PAN216_Err_t PAN216_RxLengthLimit(bool NewState)
;;;877    {
;;;878        if (NewState)
;;;879        {
;;;880            return PAN216_SetRegBits(PAN216_PAGE0, PKT_EXT_CFG, PKT_EXT_CFG_W_RX_MAX_CTRL_EN);
;;;881        }
;;;882        else
;;;883        {
;;;884            return PAN216_ResetRegBits(PAN216_PAGE0, PKT_EXT_CFG, PKT_EXT_CFG_W_RX_MAX_CTRL_EN);
;;;885        }
;;;886    }
;;;887    
;;;888    #define POWER_TABLE_SIZE 6
;;;889    
;;;890    uint8_t sop8_power_table_reg[POWER_TABLE_SIZE][3] = {
;;;891        //{PAN216_PAGE1, 0x48, 0x0f}, //
;;;892        {PAN216_PAGE1, 0x3C, 0x07}, //
;;;893        {PAN216_PAGE0, 0x43, 0x30}, //
;;;894        {PAN216_PAGE0, 0x44, 0xf0}, //
;;;895        {PAN216_PAGE0, 0x44, 0x0f}, //
;;;896        {PAN216_PAGE1, 0x46, BIT0}, //
;;;897        {PAN216_PAGE1, 0x46, 0x0c}, //
;;;898    };
;;;899    
;;;900    const struct
;;;901    {
;;;902        PAN216_TxPower_t power_level;
;;;903        int val[POWER_TABLE_SIZE];
;;;904    } sop8_power_table[] = {
;;;905        {PAN216_TXPWR_9_5dBm,       {0x07, 0x03, 0x08, 0x0c, 0x00, 0x00}},
;;;906        {PAN216_TXPWR_9dBm,         {0x07, 0x03, 0x08, 0x08, 0x00, 0x00}},
;;;907        {PAN216_TXPWR_8dBm,         {0x07, 0x03, 0x08, 0x06, 0x00, 0x00}},
;;;908        {PAN216_TXPWR_7dBm,         {0x07, 0x03, 0x08, 0x03, 0x00, 0x00}},
;;;909        {PAN216_TXPWR_6dBm,         {0x07, 0x03, 0x08, 0x04, 0x00, 0x01}},
;;;910        {PAN216_TXPWR_5dBm,         {0x07, 0x03, 0x08, 0x02, 0x00, 0x01}},
;;;911        {PAN216_TXPWR_4dBm,         {0x07, 0x03, 0x08, 0x00, 0x00, 0x01}},
;;;912        {PAN216_TXPWR_3dBm,         {0x07, 0x03, 0x08, 0x00, 0x00, 0x02}},
;;;913        {PAN216_TXPWR_2dBm,         {0x03, 0x03, 0x08, 0x02, 0x00, 0x03}},
;;;914        {PAN216_TXPWR_1dBm,         {0x03, 0x03, 0x08, 0x00, 0x00, 0x03}},
;;;915        {PAN216_TXPWR_0dBm,         {0x03, 0x03, 0x08, 0x04, 0x01, 0x03}},
;;;916        {PAN216_TXPWR_0dBm_LOWPWR,  {0x07, 0x01, 0x08, 0x0F, 0x00, 0x00}},
;;;917        {PAN216_TXPWR_n1dBm,        {0x04, 0x03, 0x08, 0x00, 0x01, 0x03}},
;;;918        {PAN216_TXPWR_n2dBm,        {0x07, 0x01, 0x0F, 0x0F, 0x00, 0x01}},
;;;919        {PAN216_TXPWR_n4dBm,        {0x07, 0x01, 0x0F, 0x0F, 0x01, 0x03}},
;;;920        {PAN216_TXPWR_n5dBm,        {0x07, 0x01, 0x0F, 0x0F, 0x01, 0x03}},
;;;921        {PAN216_TXPWR_n7dBm,        {0x03, 0x01, 0x08, 0x08, 0x01, 0x03}},
;;;922        {PAN216_TXPWR_n8dBm,        {0x03, 0x01, 0x08, 0x04, 0x01, 0x01}},
;;;923        {PAN216_TXPWR_n10dBm,       {0x03, 0x01, 0x08, 0x00, 0x01, 0x00}},
;;;924        {PAN216_TXPWR_n11dBm,       {0x03, 0x01, 0x06, 0x00, 0x01, 0x00}},
;;;925        {PAN216_TXPWR_n12dBm,       {0x03, 0x01, 0x05, 0x00, 0x01, 0x00}},
;;;926        {PAN216_TXPWR_n14dBm,       {0x03, 0x01, 0x04, 0x00, 0x01, 0x00}},
;;;927        {PAN216_TXPWR_n16dBm,       {0x03, 0x01, 0x03, 0x00, 0x01, 0x00}},
;;;928        {PAN216_TXPWR_n19dBm,       {0x03, 0x01, 0x02, 0x00, 0x01, 0x00}},
;;;929        {PAN216_TXPWR_n23dBm,       {0x03, 0x01, 0x01, 0x00, 0x01, 0x00}},
;;;930        {PAN216_TXPWR_n25dBm,       {0x02, 0x01, 0x01, 0x00, 0x01, 0x00}},
;;;931        {PAN216_TXPWR_n28dBm,       {0x01, 0x01, 0x01, 0x08, 0x01, 0x00}},
;;;932        {PAN216_TXPWR_n33dBm,       {0x03, 0x01, 0x00, 0x00, 0x01, 0x00}},
;;;933        {PAN216_TXPWR_n37dBm,       {0x00, 0x01, 0x00, 0x00, 0x00, 0x00}},
;;;934        {PAN216_TXPWR_n40dBm,       {0x00, 0x01, 0x00, 0x00, 0x01, 0x00}},
;;;935    
;;;936    };
;;;937    
;;;938    /**
;;;939     * @brief Configures the RF output power in TX mode of the PAN216 transceiver
;;;940     *
;;;941     * This function is used to set the RF output power of the PAN216 transceiver in TX mode.
;;;942     *
;;;943     * @param TxPower The desired RF output power, as one of the members of PAN216_TxPower_t
;;;944     *
;;;945     * @return uint8_t Result of the operation
;;;946     *         - PAN216_OK
;;;947     *         - PAN216_ERR
;;;948     */
;;;949    PAN216_Err_t PAN216_SetTxPower(PAN216_TxPower_t TxPower)
;;;950    {
        0x0000118c:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0000118e:    4605        .F      MOV      r5,r0
;;;951        PAN216_Err_t ret = PAN216_OK;
        0x00001190:    2000        .       MOVS     r0,#0
;;;952        uint8_t i;
;;;953    
;;;954        for (i = 0; i < sizeof(sop8_power_table) / sizeof(sop8_power_table[0]); i++)
;;;955        {
;;;956            if (sop8_power_table[i].power_level == TxPower)
        0x00001192:    4915        .I      LDR      r1,[pc,#84] ; [0x11e8] = 0x20a4
        0x00001194:    9000        ..      STR      r0,[sp,#0]
        0x00001196:    221c        ."      MOVS     r2,#0x1c
        0x00001198:    4342        BC      MULS     r2,r0,r2
        0x0000119a:    568b        .V      LDRSB    r3,[r1,r2]
        0x0000119c:    42ab        .B      CMP      r3,r5
        0x0000119e:    d112        ..      BNE      0x11c6 ; PAN216_SetTxPower + 58
;;;957            {
;;;958                for (uint8_t j = 0; j < POWER_TABLE_SIZE; j++)
        0x000011a0:    2400        .$      MOVS     r4,#0
        0x000011a2:    4e12        .N      LDR      r6,[pc,#72] ; [0x11ec] = 0x20000027
        0x000011a4:    1857        W.      ADDS     r7,r2,r1
        0x000011a6:    00a0        ..      LSLS     r0,r4,#2
        0x000011a8:    1838        8.      ADDS     r0,r7,r0
        0x000011aa:    7902        .y      LDRB     r2,[r0,#4]
        0x000011ac:    0060        `.      LSLS     r0,r4,#1
        0x000011ae:    1820         .      ADDS     r0,r4,r0
        0x000011b0:    1981        ..      ADDS     r1,r0,r6
        0x000011b2:    788b        .x      LDRB     r3,[r1,#2]
        0x000011b4:    7849        Ix      LDRB     r1,[r1,#1]
        0x000011b6:    5c30        0\      LDRB     r0,[r6,r0]
        0x000011b8:    f000f926    ..&.    BL       PAN216_WritePageRegBits ; 0x1408
        0x000011bc:    1c64        d.      ADDS     r4,r4,#1
        0x000011be:    b2e4        ..      UXTB     r4,r4
        0x000011c0:    2c06        .,      CMP      r4,#6
        0x000011c2:    d3f0        ..      BCC      0x11a6 ; PAN216_SetTxPower + 26
        0x000011c4:    e003        ..      B        0x11ce ; PAN216_SetTxPower + 66
        0x000011c6:    1c40        @.      ADDS     r0,r0,#1
        0x000011c8:    b2c0        ..      UXTB     r0,r0
        0x000011ca:    281e        .(      CMP      r0,#0x1e
        0x000011cc:    d3e3        ..      BCC      0x1196 ; PAN216_SetTxPower + 10
;;;959                {
;;;960                    PAN216_WritePageRegBits(sop8_power_table_reg[j][0], sop8_power_table_reg[j][1],
;;;961                                            sop8_power_table[i].val[j], sop8_power_table_reg[j][2]);
;;;962                }
;;;963                break;
;;;964            }
;;;965        }
;;;966    
;;;967        if (TxPower == PAN216_TXPWR_0dBm_LOWPWR || TxPower == PAN216_TXPWR_n4dBm)
        0x000011ce:    2d63        c-      CMP      r5,#0x63
        0x000011d0:    d001        ..      BEQ      0x11d6 ; PAN216_SetTxPower + 74
        0x000011d2:    1d2d        -.      ADDS     r5,r5,#4
        0x000011d4:    d105        ..      BNE      0x11e2 ; PAN216_SetTxPower + 86
;;;968        {
;;;969            PAN216_WritePageRegBits(PAN216_PAGE1, 0x48, 0x0C, BITMASK_3_0);
        0x000011d6:    230f        .#      MOVS     r3,#0xf
        0x000011d8:    220c        ."      MOVS     r2,#0xc
        0x000011da:    2148        H!      MOVS     r1,#0x48
        0x000011dc:    2001        .       MOVS     r0,#1
        0x000011de:    f000f913    ....    BL       PAN216_WritePageRegBits ; 0x1408
;;;970        }
;;;971    
;;;972        return ret;
        0x000011e2:    9800        ..      LDR      r0,[sp,#0]
;;;973    }
        0x000011e4:    bdf8        ..      POP      {r3-r7,pc}
    $d
        0x000011e6:    0000        ..      DCW    0
        0x000011e8:    000020a4    . ..    DCD    8356
        0x000011ec:    20000027    '..     DCD    536870951
    $t
    i.PAN216_SetUpConfig
    PAN216_SetUpConfig
;;;974    
;;;975    /**
;;;976     * @brief Set Nordic packet header format
;;;977     * @param HeaderEn Enable/disable header (1/0)
;;;978     * @param HeaderLen Header length in bytes (valid only if HeaderEn=1)
;;;979     * @note Only valid in Nordic normal mode
;;;980     * @return PAN216_Err_t Operation result
;;;981     */
;;;982    PAN216_Err_t PAN216_SetNordicPktHeader(uint8_t HeaderEn, uint8_t HeaderLen)
;;;983    {
;;;984        P_ASSERT(
;;;985            PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, !!HeaderEn, PKT_EXT_CFG_HDR_LEN_EXIST));
;;;986    
;;;987        P_ASSERT(
;;;988            PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, HeaderLen, PKT_EXT_CFG_HDR_LEN_NUMB));
;;;989    
;;;990        return PAN216_OK;
;;;991    }
;;;992    
;;;993    PAN216_Err_t PAN216_WriteNordicPktHeader(uint8_t Header0, uint8_t Header1,
;;;994                                             uint8_t Length) // 写nordic包头内容
;;;995    {
;;;996        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXHDR0_CFG, Header0));
;;;997        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXHDR1_CFG, Header1));
;;;998        P_ASSERT(PAN216_WritePageReg(PAN216_PAGE0, TXPLLEN_CFG, Length));
;;;999    
;;;1000       return PAN216_OK;
;;;1001   }
;;;1002   
;;;1003   PAN216_Err_t PAN216_SetS2S8Mode(PAN216_S2S8Mode_t mode)
;;;1004   {
;;;1005       if (mode == PAN216_PRIMODE_DIS)
;;;1006       {
;;;1007           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, 1, TRXMODE_CFG_W_PRE_SYNC_EN));
;;;1008           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 0, PKT_EXT_CFG_PRI_CI_MODE));
;;;1009           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 0, PKT_EXT_CFG_PRI_TX_FEC));
;;;1010           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 0, PKT_EXT_CFG_PRI_RX_FEC));
;;;1011           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE1, 0x0B, 0, BIT5));
;;;1012           _gS2S8Mode = PAN216_PRIMODE_DIS;
;;;1013       }
;;;1014       else if (mode == PAN216_PRIMODE_S2)
;;;1015       {
;;;1016           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, 0, TRXMODE_CFG_W_PRE_SYNC_EN));
;;;1017           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 1, PKT_EXT_CFG_PRI_CI_MODE));
;;;1018           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 1, PKT_EXT_CFG_PRI_TX_FEC));
;;;1019           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 1, PKT_EXT_CFG_PRI_RX_FEC));
;;;1020           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE1, 0x0B, 1, BIT5));
;;;1021           _gS2S8Mode = PAN216_PRIMODE_S2;
;;;1022       }
;;;1023       else if (mode == PAN216_PRIMODE_S8)
;;;1024       {
;;;1025           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, TRXMODE_CFG, 0, TRXMODE_CFG_W_PRE_SYNC_EN));
;;;1026           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 0, PKT_EXT_CFG_PRI_CI_MODE));
;;;1027           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 1, PKT_EXT_CFG_PRI_TX_FEC));
;;;1028           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, PKT_EXT_CFG, 1, PKT_EXT_CFG_PRI_RX_FEC));
;;;1029           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE1, 0x0B, 1, BIT5));
;;;1030           _gS2S8Mode = PAN216_PRIMODE_S8;
;;;1031       }
;;;1032   
;;;1033       return PAN216_OK;
;;;1034   }
;;;1035   
;;;1036   /**
;;;1037    * @brief Set the PAN216 IRQ pin mux
;;;1038    *
;;;1039    * @param Mux
;;;1040    * @return PAN216_Err_t
;;;1041    */
;;;1042   PAN216_Err_t PAN216_setIRQPinMux(PAN216_IRQPinMux_t Mux)
;;;1043   {
;;;1044       if (PAN216_IRQ_PINMUX_PACTRL == Mux)
;;;1045       {
;;;1046           P_ASSERT(PAN216_WriteRegBits(0x6C, 1, BIT6));
;;;1047       }
;;;1048       else
;;;1049       {
;;;1050           P_ASSERT(PAN216_WriteRegBits(0x6C, 0, BIT6));
;;;1051           P_ASSERT(PAN216_WriteRegBits(0x45, 3, 0x0C)); // SEL 16M OCLK
;;;1052       }
;;;1053   
;;;1054       P_ASSERT(PAN216_WriteRegBits(0x45, Mux, 0x03));
;;;1055   
;;;1056       return PAN216_OK;
;;;1057   }
;;;1058   
;;;1059   /**
;;;1060    * @brief Set the Chip frame format type mode and endian type of PAN216 transceiver
;;;1061    *
;;;1062    * @param chipMode supported chip format frame type
;;;1063    *          - PAN216_CHIPMODE_XN297
;;;1064    *          - ...
;;;1065    *          - PAN216_CHIPMODE_BLE
;;;1066    * @return PAN216_Err_t
;;;1067    */
;;;1068   PAN216_Err_t PAN216_SetChipMode(PAN216_ChipMode_t chipMode, PAN216_Endian_t endian,
;;;1069                                   bool crcSkipAddr)
;;;1070   {
;;;1071       _gChipMode = chipMode;
;;;1072   
;;;1073       switch (chipMode)
;;;1074       {
;;;1075       case PAN216_CHIPMODE_XN297:
;;;1076           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 0, WMODE_CFG0_CHIP_MODE));
;;;1077           P_ASSERT(PAN216_SetEndian(PAN216_ENDIAN_BIG));
;;;1078           P_ASSERT(PAN216_CrcSkipAddr(false));
;;;1079           P_ASSERT(PAN216_WhiteSkipAddr(false));
;;;1080           P_ASSERT(PAN216_SetWhiteInitVal(0x7F));
;;;1081           break;
;;;1082   
;;;1083   case PAN216_CHIPMODE_FS01:
;;;1084           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_CHIP_MODE));
;;;1085           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 0, WMODE_CFG0_NORDIC_ENHANCE));
;;;1086           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, REG_P0_0X6F, 0, REG_P0_0X6F_I_NDC_PREAMBLE_SEL)); 
;;;1087           P_ASSERT(PAN216_SetEndian(PAN216_ENDIAN_BIG));
;;;1088           P_ASSERT(PAN216_CrcSkipAddr(false));
;;;1089           P_ASSERT(PAN216_WhiteSkipAddr(false));
;;;1090           P_ASSERT(PAN216_SetWhiteInitVal(0x7F));
;;;1091           break;
;;;1092   
;;;1093       case PAN216_CHIPMODE_FS32:
;;;1094           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_CHIP_MODE));
;;;1095           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_NORDIC_ENHANCE));
;;;1096           P_ASSERT(PAN216_WritePageRegBits(
;;;1097               PAN216_PAGE0, REG_P0_0X6F, 1,
;;;1098               REG_P0_0X6F_I_NDC_PREAMBLE_SEL));
;;;1099           P_ASSERT(PAN216_SetEndian(endian));
;;;1100           P_ASSERT(PAN216_CrcSkipAddr(crcSkipAddr));
;;;1101           P_ASSERT(PAN216_WhiteSkipAddr(true));
;;;1102           P_ASSERT(PAN216_SetWhiteInitVal(0x7F));
;;;1103           break;
;;;1104       case PAN216_CHIPMODE_BLE:
;;;1105           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1, WMODE_CFG0_CHIP_MODE));
;;;1106           P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG0, 1,
;;;1107                                            WMODE_CFG0_NORDIC_ENHANCE));
;;;1108           P_ASSERT(PAN216_SetEndian(PAN216_ENDIAN_LITTLE));
;;;1109           P_ASSERT(PAN216_CrcSkipAddr(true));
;;;1110           P_ASSERT(PAN216_WhiteSkipAddr(true));
;;;1111   
;;;1112           break;
;;;1113       default:
;;;1114           return PAN216_ERR;
;;;1115       }
;;;1116   
;;;1117       // when recv error occurs, the chip will enter rx mode automatically
;;;1118       P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, WMODE_CFG1, 1, WMODE_CFG1_RX_GOON));
;;;1119   
;;;1120       return PAN216_OK;
;;;1121   }
;;;1122   
;;;1123   PAN216_Err_t PAN216_SetUpConfig(RFConfig_t *pCfg)
;;;1124   {
        0x000011f0:    b5f8        ..      PUSH     {r3-r7,lr}
        0x000011f2:    4605        .F      MOV      r5,r0
        0x000011f4:    3520         5      ADDS     r5,r5,#0x20
;;; ..\..\..\..\radio\pan216_ext.c (1124)
        0x000011f6:    4604        .F      MOV      r4,r0
;;;1125       P_ASSERT(
        0x000011f8:    7daa        .}      LDRB     r2,[r5,#0x16]
        0x000011fa:    7de9        .}      LDRB     r1,[r5,#0x17]
        0x000011fc:    7900        .y      LDRB     r0,[r0,#4]
        0x000011fe:    f7fffe67    ..g.    BL       PAN216_SetChipMode ; 0xed0
        0x00001202:    2800        .(      CMP      r0,#0
        0x00001204:    d172        r.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1126           PAN216_SetChipMode((PAN216_ChipMode_t)pCfg->ChipMode, pCfg->Endian, pCfg->crcSkipAddr));
;;;1127       P_ASSERT(PAN216_SetChannel(pCfg->Channel));
        0x00001206:    7820         x      LDRB     r0,[r4,#0]
        0x00001208:    f7fffe5c    ..\.    BL       PAN216_SetChannel ; 0xec4
        0x0000120c:    2800        .(      CMP      r0,#0
        0x0000120e:    d16d        m.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1128       P_ASSERT(PAN216_SetDataRate((PAN216_DataRate_t)pCfg->DataRate));
        0x00001210:    78a0        .x      LDRB     r0,[r4,#2]
        0x00001212:    f7fffef3    ....    BL       PAN216_SetDataRate ; 0xffc
        0x00001216:    2800        .(      CMP      r0,#0
        0x00001218:    d168        h.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1129       P_ASSERT(PAN216_SetCrcScheme((PAN216_Crc_t)pCfg->Crc));
        0x0000121a:    78e0        .x      LDRB     r0,[r4,#3]
        0x0000121c:    f7fffee0    ....    BL       PAN216_SetCrcScheme ; 0xfe0
        0x00001220:    2800        .(      CMP      r0,#0
        0x00001222:    d163        c.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1130       P_ASSERT(PAN216_SetTxPayloadLen(pCfg->TxLen));
        0x00001224:    7c68        h|      LDRB     r0,[r5,#0x11]
        0x00001226:    f7ffffa7    ....    BL       PAN216_SetTxPayloadLen ; 0x1178
        0x0000122a:    2800        .(      CMP      r0,#0
        0x0000122c:    d15e        ^.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1131       P_ASSERT(PAN216_SetRxPayloadLen(pCfg->RxLen));
        0x0000122e:    7ca8        .|      LDRB     r0,[r5,#0x12]
        0x00001230:    f7ffff75    ..u.    BL       PAN216_SetRxPayloadLen ; 0x111e
        0x00001234:    2800        .(      CMP      r0,#0
        0x00001236:    d159        Y.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1132       P_ASSERT(PAN216_SetAddrWidth((PAN216_AddrWidth_t)pCfg->TxAddrWidth));
        0x00001238:    79a0        .y      LDRB     r0,[r4,#6]
        0x0000123a:    f7fffe1e    ....    BL       PAN216_SetAddrWidth ; 0xe7a
        0x0000123e:    2800        .(      CMP      r0,#0
        0x00001240:    d154        T.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1133       P_ASSERT(PAN216_SetTxAddr(pCfg->TxAddr, pCfg->TxAddrWidth));
        0x00001242:    79a1        .y      LDRB     r1,[r4,#6]
        0x00001244:    1de0        ..      ADDS     r0,r4,#7
        0x00001246:    f7ffff7d    ..}.    BL       PAN216_SetTxAddr ; 0x1144
        0x0000124a:    2800        .(      CMP      r0,#0
        0x0000124c:    d14e        N.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1134   
;;;1135       for (int i = 0; i < PIPE_MAX_NUM; i++)
        0x0000124e:    2600        .&      MOVS     r6,#0
;;;1136       {
;;;1137           if (pCfg->RxAddr[i].EnPipe)
        0x00001250:    2006        .       MOVS     r0,#6
        0x00001252:    4370        pC      MULS     r0,r6,r0
        0x00001254:    1907        ..      ADDS     r7,r0,r4
        0x00001256:    7b78        x{      LDRB     r0,[r7,#0xd]
        0x00001258:    2800        .(      CMP      r0,#0
        0x0000125a:    d00d        ..      BEQ      0x1278 ; PAN216_SetUpConfig + 136
;;;1138           {
;;;1139               P_ASSERT(PAN216_EnableRxPipe((PAN216_Pipe_t)i));
        0x0000125c:    b2f0        ..      UXTB     r0,r6
        0x0000125e:    f7fffc44    ..D.    BL       PAN216_EnableRxPipe ; 0xaea
        0x00001262:    2800        .(      CMP      r0,#0
        0x00001264:    d142        B.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1140               P_ASSERT(PAN216_SetRxAddr((PAN216_Pipe_t)i, pCfg->RxAddr[i].Addr, pCfg->RxAddrWidth));
        0x00001266:    4639        9F      MOV      r1,r7
        0x00001268:    7b22        "{      LDRB     r2,[r4,#0xc]
        0x0000126a:    310e        .1      ADDS     r1,r1,#0xe
        0x0000126c:    b2f0        ..      UXTB     r0,r6
        0x0000126e:    f7ffff1d    ....    BL       PAN216_SetRxAddr ; 0x10ac
;;;1141           }
;;;1142           else
;;;1143           {
;;;1144               P_ASSERT(PAN216_DisableRxPipe((PAN216_Pipe_t)i));
        0x00001272:    2800        .(      CMP      r0,#0
        0x00001274:    d13a        :.      BNE      0x12ec ; PAN216_SetUpConfig + 252
        0x00001276:    e003        ..      B        0x1280 ; PAN216_SetUpConfig + 144
        0x00001278:    b2f0        ..      UXTB     r0,r6
        0x0000127a:    f7fffc05    ....    BL       PAN216_DisableRxPipe ; 0xa88
        0x0000127e:    e7f8        ..      B        0x1272 ; PAN216_SetUpConfig + 130
        0x00001280:    1c76        v.      ADDS     r6,r6,#1
        0x00001282:    2e06        ..      CMP      r6,#6
        0x00001284:    dbe4        ..      BLT      0x1250 ; PAN216_SetUpConfig + 96
;;;1145           }
;;;1146       }
;;;1147   
;;;1148       P_ASSERT(PAN216_EnableWhiten(pCfg->EnWhite));
        0x00001286:    7ce8        .|      LDRB     r0,[r5,#0x13]
        0x00001288:    f7fffc6e    ..n.    BL       PAN216_EnableWhiten ; 0xb68
        0x0000128c:    2800        .(      CMP      r0,#0
        0x0000128e:    d12d        -.      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1149       if (pCfg->EnTxNoAck == 0)
        0x00001290:    7d68        h}      LDRB     r0,[r5,#0x15]
        0x00001292:    2800        .(      CMP      r0,#0
        0x00001294:    d008        ..      BEQ      0x12a8 ; PAN216_SetUpConfig + 184
        0x00001296:    8f60        `.      LDRH     r0,[r4,#0x3a]
        0x00001298:    f000f841    ..A.    BL       PAN216_SetWaitAckTimeout ; 0x131e
        0x0000129c:    2001        .       MOVS     r0,#1
        0x0000129e:    f7fffc12    ....    BL       PAN216_EnableFifo128bytes ; 0xac6
        0x000012a2:    2800        .(      CMP      r0,#0
        0x000012a4:    d122        ".      BNE      0x12ec ; PAN216_SetUpConfig + 252
        0x000012a6:    e00b        ..      B        0x12c0 ; PAN216_SetUpConfig + 208
;;;1150       {
;;;1151           PAN216_SetTRxTransTime(pCfg->TRxDelayTimeUs);
        0x000012a8:    8f20         .      LDRH     r0,[r4,#0x38]
        0x000012aa:    f7ffff3f    ..?.    BL       PAN216_SetTRxTransTime ; 0x112c
;;;1152           PAN216_SetAutoRetrans(pCfg->AutoDelayUs, pCfg->AutoMaxCnt);
        0x000012ae:    7fa9        ..      LDRB     r1,[r5,#0x1e]
        0x000012b0:    8fa0        ..      LDRH     r0,[r4,#0x3c]
        0x000012b2:    f7fffded    ....    BL       PAN216_SetAutoRetrans ; 0xe90
;;;1153           PAN216_SetWaitAckTimeout(pCfg->RxTimeoutUs);
        0x000012b6:    8f60        `.      LDRH     r0,[r4,#0x3a]
        0x000012b8:    f000f831    ..1.    BL       PAN216_SetWaitAckTimeout ; 0x131e
;;;1154           P_ASSERT(PAN216_EnableFifo128bytes(false));
        0x000012bc:    2000        .       MOVS     r0,#0
        0x000012be:    e7ee        ..      B        0x129e ; PAN216_SetUpConfig + 174
;;;1155       }
;;;1156       else
;;;1157       {
;;;1158           PAN216_SetWaitAckTimeout(pCfg->RxTimeoutUs); // us
;;;1159           P_ASSERT(PAN216_EnableFifo128bytes(true));
;;;1160       }
;;;1161       /* Enhanced parameters */
;;;1162       P_ASSERT(PAN216_SetWorkMode(pCfg->WorkMode));
        0x000012c0:    7960        `y      LDRB     r0,[r4,#5]
        0x000012c2:    f000f83f    ..?.    BL       PAN216_SetWorkMode ; 0x1344
        0x000012c6:    2800        .(      CMP      r0,#0
        0x000012c8:    d110        ..      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1163       P_ASSERT(PAN216_EnableDynamicPL(pCfg->EnDPL));
        0x000012ca:    7d28        (}      LDRB     r0,[r5,#0x14]
        0x000012cc:    f7fffbe9    ....    BL       PAN216_EnableDynamicPL ; 0xaa2
        0x000012d0:    2800        .(      CMP      r0,#0
        0x000012d2:    d10b        ..      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1164       P_ASSERT(PAN216_EnableTxNoAck(pCfg->EnTxNoAck));
        0x000012d4:    7d68        h}      LDRB     r0,[r5,#0x15]
        0x000012d6:    f7fffc15    ....    BL       PAN216_EnableTxNoAck ; 0xb04
        0x000012da:    2800        .(      CMP      r0,#0
        0x000012dc:    d106        ..      BNE      0x12ec ; PAN216_SetUpConfig + 252
;;;1165       P_ASSERT(PAN216_RxLengthLimit(pCfg->EnRxPlLenLimit));
        0x000012de:    4625        %F      MOV      r5,r4
        0x000012e0:    3540        @5      ADDS     r5,r5,#0x40
        0x000012e2:    7828        (x      LDRB     r0,[r5,#0]
        0x000012e4:    f7fffdab    ....    BL       PAN216_RxLengthLimit ; 0xe3e
        0x000012e8:    2800        .(      CMP      r0,#0
        0x000012ea:    d001        ..      BEQ      0x12f0 ; PAN216_SetUpConfig + 256
        0x000012ec:    2001        .       MOVS     r0,#1
        0x000012ee:    bdf8        ..      POP      {r3-r7,pc}
;;;1166   
;;;1167       PAN216_SetTxPower((PAN216_TxPower_t)pCfg->TxPower);
        0x000012f0:    2001        .       MOVS     r0,#1
        0x000012f2:    5620         V      LDRSB    r0,[r4,r0]
        0x000012f4:    f7ffff4a    ..J.    BL       PAN216_SetTxPower ; 0x118c
;;;1168   
;;;1169       if (pCfg->WorkMode == PAN216_WORKMODE_ENHANCE)
        0x000012f8:    7960        `y      LDRB     r0,[r4,#5]
        0x000012fa:    2801        .(      CMP      r0,#1
        0x000012fc:    d002        ..      BEQ      0x1304 ; PAN216_SetUpConfig + 276
        0x000012fe:    2800        .(      CMP      r0,#0
        0x00001300:    d005        ..      BEQ      0x130e ; PAN216_SetUpConfig + 286
        0x00001302:    e00a        ..      B        0x131a ; PAN216_SetUpConfig + 298
;;;1170       {
;;;1171           PAN216_SetTxMode(PAN216_TX_MODE_SINGLE);
        0x00001304:    2000        .       MOVS     r0,#0
        0x00001306:    f7ffff24    ..$.    BL       PAN216_SetTxMode ; 0x1152
;;;1172           PAN216_SetRxMode(PAN216_RX_MODE_SINGLE);
        0x0000130a:    2000        .       MOVS     r0,#0
        0x0000130c:    e003        ..      B        0x1316 ; PAN216_SetUpConfig + 294
;;;1173       }
;;;1174       else if (pCfg->WorkMode == PAN216_WORKMODE_NORMAL)
;;;1175       {
;;;1176           PAN216_SetTxMode(pCfg->TxMode);
        0x0000130e:    7868        hx      LDRB     r0,[r5,#1]
        0x00001310:    f7ffff1f    ....    BL       PAN216_SetTxMode ; 0x1152
;;;1177           PAN216_SetRxMode(pCfg->RxMode);
        0x00001314:    78a8        .x      LDRB     r0,[r5,#2]
        0x00001316:    f7fffee8    ....    BL       PAN216_SetRxMode ; 0x10ea
;;;1178       }
;;;1179   
;;;1180       return PAN216_OK;
        0x0000131a:    2000        .       MOVS     r0,#0
;;;1181   }
        0x0000131c:    bdf8        ..      POP      {r3-r7,pc}
    i.PAN216_SetWaitAckTimeout
    PAN216_SetWaitAckTimeout
        0x0000131e:    b508        ..      PUSH     {r3,lr}
;;; ..\..\..\..\radio\pan216_ext.c (822)
        0x00001320:    4669        iF      MOV      r1,sp
        0x00001322:    7008        .p      STRB     r0,[r1,#0]
        0x00001324:    0a00        ..      LSRS     r0,r0,#8
        0x00001326:    7048        Hp      STRB     r0,[r1,#1]
;;;823            (uint8_t)(AckTimeoutUs & 0xff),
;;;824            (uint8_t)((AckTimeoutUs >> 8) & 0xff),
;;;825        };
;;;826    
;;;827        return PAN216_WritePageRegs(PAN216_PAGE0, RXTIMEOUTL_CFG, time, 2);
        0x00001328:    2302        .#      MOVS     r3,#2
        0x0000132a:    466a        jF      MOV      r2,sp
        0x0000132c:    212b        +!      MOVS     r1,#0x2b
        0x0000132e:    2000        .       MOVS     r0,#0
        0x00001330:    f000f881    ....    BL       PAN216_WritePageRegs ; 0x1436
;;;828    }
        0x00001334:    bd08        ..      POP      {r3,pc}
    i.PAN216_SetWhiteInitVal
    PAN216_SetWhiteInitVal
;;; ..\..\..\..\radio\pan216.c
;;;614    {
        0x00001336:    b510        ..      PUSH     {r4,lr}
;;;615        return PAN216_WriteRegBits(SCR_CFG, val, SCR_CFG_SCR_INI);
        0x00001338:    4601        .F      MOV      r1,r0
        0x0000133a:    227f        ."      MOVS     r2,#0x7f
        0x0000133c:    201a        .       MOVS     r0,#0x1a
        0x0000133e:    f000f8c7    ....    BL       PAN216_WriteRegBits ; 0x14d0
;;;616    }
        0x00001342:    bd10        ..      POP      {r4,pc}
    i.PAN216_SetWorkMode
    PAN216_SetWorkMode
;;; ..\..\..\..\radio\pan216_ext.c
;;;563    {
        0x00001344:    b510        ..      PUSH     {r4,lr}
        0x00001346:    2800        .(      CMP      r0,#0
;;; ..\..\..\..\radio\pan216_ext.c (563)
        0x00001348:    d002        ..      BEQ      0x1350 ; PAN216_SetWorkMode + 12
;;;564    
;;;565        switch (Mode)
        0x0000134a:    2801        .(      CMP      r0,#1
        0x0000134c:    d110        ..      BNE      0x1370 ; PAN216_SetWorkMode + 44
        0x0000134e:    e001        ..      B        0x1354 ; PAN216_SetWorkMode + 16
;;;566        {
;;;567        case PAN216_WORKMODE_NORMAL:
;;;568            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1,
        0x00001350:    220c        ."      MOVS     r2,#0xc
        0x00001352:    e007        ..      B        0x1364 ; PAN216_SetWorkMode + 32
        0x00001354:    2208        ."      MOVS     r2,#8
        0x00001356:    4611        .F      MOV      r1,r2
        0x00001358:    2000        .       MOVS     r0,#0
        0x0000135a:    f7fffe9a    ....    BL       PAN216_SetRegBits ; 0x1092
        0x0000135e:    2800        .(      CMP      r0,#0
        0x00001360:    d106        ..      BNE      0x1370 ; PAN216_SetWorkMode + 44
        0x00001362:    2204        ."      MOVS     r2,#4
        0x00001364:    2108        .!      MOVS     r1,#8
        0x00001366:    2000        .       MOVS     r0,#0
        0x00001368:    f7fffd5c    ..\.    BL       PAN216_ResetRegBits ; 0xe24
        0x0000136c:    2800        .(      CMP      r0,#0
        0x0000136e:    d000        ..      BEQ      0x1372 ; PAN216_SetWorkMode + 46
;;;569                                         WMODE_CFG1_NORMAL_M1 | WMODE_CFG1_ENHANCE));
;;;570            break;
;;;571        case PAN216_WORKMODE_ENHANCE:
;;;572            P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_ENHANCE));
;;;573            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;574            break;
;;;575        default:
;;;576            return PAN216_ERR;
        0x00001370:    2001        .       MOVS     r0,#1
;;;577        }
;;;578    
;;;579        return PAN216_OK;
;;;580    }
        0x00001372:    bd10        ..      POP      {r4,pc}
    i.PAN216_WhiteSkipAddr
    PAN216_WhiteSkipAddr
;;;581    
;;;582    PAN216_Err_t PAN216_GetChipMode(PAN216_ChipMode_t *chipMode)
;;;583    {
;;;584        *chipMode = (PAN216_ChipMode_t)_gChipMode;
;;;585        return PAN216_OK;
;;;586    }
;;;587    
;;;588    /**
;;;589     * @brief  This function set noack for tx
;;;590     * @param  NewState: ENABLE/DISABLE
;;;591     * @return Result of the operation
;;;592     *         - PAN216_OK
;;;593     *         - PAN216_ERR
;;;594     * @note  This function is called after PAN216_SetWorkMode
;;;595     */
;;;596    PAN216_Err_t PAN216_EnableTxNoAck(uint8_t NewState)
;;;597    {
;;;598        uint8_t modeCfg1 = PAN216_ReadPageReg(PAN216_PAGE0, WMODE_CFG1);
;;;599    
;;;600        if (modeCfg1 & WMODE_CFG1_ENHANCE)
;;;601        {
;;;602            if (NewState)
;;;603            {
;;;604                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;605            }
;;;606            else
;;;607            {
;;;608                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;609            }
;;;610            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;611        }
;;;612        else
;;;613        {
;;;614            if (NewState)
;;;615            {
;;;616                P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;617            }
;;;618            else
;;;619            {
;;;620                P_ASSERT(PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG1, WMODE_CFG1_NORMAL_M1));
;;;621            }
;;;622            P_ASSERT(PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_TX_NOACK_EN));
;;;623        }
;;;624    
;;;625        return PAN216_OK;
;;;626    }
;;;627    
;;;628    /**
;;;629     * @brief After receiving a packet, reads the TxNoack bit of a enhanced shockburst packet
;;;630     *
;;;631     * @return uint8_t  1 : rx need ack
;;;632     *                  0 : rx need no ack
;;;633     */
;;;634    uint8_t PAN216_ReadTxNoackBit(void)
;;;635    {
;;;636        return !(PAN216_ReadReg(0x7D) & BIT6);
;;;637    }
;;;638    
;;;639    PAN216_Err_t PAN216_SetAckPipe(uint8_t pipe)
;;;640    {
;;;641        if (pipe > 5)
;;;642        {
;;;643            return PAN216_ERR;
;;;644        }
;;;645    
;;;646        P_ASSERT(PAN216_WritePageRegBits(PAN216_PAGE0, 0x6F, pipe, 0x07));
;;;647    
;;;648        return PAN216_OK;
;;;649    }
;;;650    
;;;651    /**
;;;652     * @brief Enable CRC calculation for address field in PAN216.
;;;653     *
;;;654     * This function allows enabling or disabling
;;;655     *  CRC calculation for the address field in PAN216.
;;;656     *
;;;657     * @note By default, address field is not included in CRC calculation.
;;;658     *
;;;659     * @param[in] NewState Boolean value indicating whether to enable or disable CRC calculation for
;;;660     * address field.
;;;661     *
;;;662     * @return Result of the operation:
;;;663     *         - PAN216_OK
;;;664     *         - PAN216_ERR
;;;665     */
;;;666    PAN216_Err_t PAN216_CrcSkipAddr(bool exclude)
;;;667    {
;;;668        if (exclude)
;;;669        {
;;;670            return PAN216_SetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;671        }
;;;672        else
;;;673        {
;;;674            return PAN216_ResetRegBits(PAN216_PAGE0, WMODE_CFG0, WMODE_CFG0_ACCADDR_CRC_DIS);
;;;675        }
;;;676    }
;;;677    
;;;678    /**
;;;679     * @brief whiten(scramble) configurations
;;;680     * @param addr_excluded  whiten exclude access address(already include header, payload, crc)
;;;681     * @param initital_phase initital whiten phase
;;;682     *        - channel 37: 0x53
;;;683              - channel 38: 0x33
;;;684              - channel 39: 0x73
;;;685     * @return PAN216_Err_t
;;;686     */
;;;687    PAN216_Err_t PAN216_WhiteSkipAddr(bool addr_excluded)
;;;688    {
        0x00001374:    b510        ..      PUSH     {r4,lr}
        0x00001376:    2800        .(      CMP      r0,#0
;;; ..\..\..\..\radio\pan216_ext.c (688)
        0x00001378:    d005        ..      BEQ      0x1386 ; PAN216_WhiteSkipAddr + 18
;;;689        PAN216_Err_t ret;
;;;690    
;;;691        if (addr_excluded)
;;;692        {
;;;693            ret = PAN216_SetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
        0x0000137a:    2280        ."      MOVS     r2,#0x80
        0x0000137c:    211a        .!      MOVS     r1,#0x1a
        0x0000137e:    2000        .       MOVS     r0,#0
        0x00001380:    f7fffe87    ....    BL       PAN216_SetRegBits ; 0x1092
        0x00001384:    bd10        ..      POP      {r4,pc}
;;;694        }
;;;695        else
;;;696        {
;;;697            ret = PAN216_ResetRegBits(PAN216_PAGE0, SCR_CFG, SCR_CFG_ACCADDR_SCR_DIS);
        0x00001386:    2280        ."      MOVS     r2,#0x80
        0x00001388:    211a        .!      MOVS     r1,#0x1a
        0x0000138a:    2000        .       MOVS     r0,#0
        0x0000138c:    f7fffd4a    ..J.    BL       PAN216_ResetRegBits ; 0xe24
;;;698        }
;;;699    
;;;700        return ret;
;;;701    }
        0x00001390:    bd10        ..      POP      {r4,pc}
        0x00001392:    0000        ..      MOVS     r0,r0
    i.PAN216_Write
    PAN216_Write
;;; ..\..\..\..\radio\pan216_reg.c
;;;58     {
        0x00001394:    b5f8        ..      PUSH     {r3-r7,lr}
        0x00001396:    4c0b        .L      LDR      r4,[pc,#44] ; [0x13c4] = 0x2000000c
;;; ..\..\..\..\radio\pan216_reg.c (58)
        0x00001398:    4605        .F      MOV      r5,r0
        0x0000139a:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0000139c:    4616        .F      MOV      r6,r2
        0x0000139e:    460f        .F      MOV      r7,r1
;;;59     #if (INTERFACE_MODE == USE_I2C)
;;;60         Pan216_Funs.i2c_write_buf(addr, buffer, len);
;;;61     #else
;;;62         Pan216_Funs.spi_cs_low();
        0x000013a0:    4780        .G      BLX      r0
;;;63         Pan216_Funs.spi_writebyte(((addr << 1) | 0x01));
        0x000013a2:    0068        h.      LSLS     r0,r5,#1
        0x000013a4:    1c40        @.      ADDS     r0,r0,#1
        0x000013a6:    6821        !h      LDR      r1,[r4,#0]
        0x000013a8:    b2c0        ..      UXTB     r0,r0
        0x000013aa:    4788        .G      BLX      r1
;;;64         for (int i = 0; i < len; i++)
        0x000013ac:    2500        .%      MOVS     r5,#0
        0x000013ae:    e003        ..      B        0x13b8 ; PAN216_Write + 36
        0x000013b0:    6821        !h      LDR      r1,[r4,#0]
        0x000013b2:    5d78        x]      LDRB     r0,[r7,r5]
        0x000013b4:    4788        .G      BLX      r1
        0x000013b6:    1c6d        m.      ADDS     r5,r5,#1
        0x000013b8:    42b5        .B      CMP      r5,r6
        0x000013ba:    dbf9        ..      BLT      0x13b0 ; PAN216_Write + 28
;;;65         {
;;;66             Pan216_Funs.spi_writebyte(buffer[i]);
;;;67         }
;;;68         Pan216_Funs.spi_cs_high();
        0x000013bc:    68a0        .h      LDR      r0,[r4,#8]
        0x000013be:    4780        .G      BLX      r0
;;;69     #endif
;;;70     }
        0x000013c0:    bdf8        ..      POP      {r3-r7,pc}
    $d
        0x000013c2:    0000        ..      DCW    0
        0x000013c4:    2000000c    ...     DCD    536870924
    $t
    i.PAN216_WritePageReg
    PAN216_WritePageReg
;;;71     
;;;72     /**************************************************************************/
;;;73     /*                         Basic Register Operation                       */
;;;74     /**************************************************************************/
;;;75     
;;;76     /**
;;;77      * @brief Read one byte from the register in the current page
;;;78      * @param[in] addr Register address to read
;;;79      * @return Value read from the register
;;;80      */
;;;81     uint8_t PAN216_ReadReg(uint8_t addr)
;;;82     {
;;;83         uint8_t tmp;
;;;84     
;;;85         PAN216_Read(addr, &tmp, 1);
;;;86     
;;;87         return tmp;
;;;88     }
;;;89     
;;;90     /**
;;;91      * @brief Write to the global register in the current page and check
;;;92      * @param[in] addr Register address to write
;;;93      * @param[in] value Value to write to the register
;;;94      * @return Result
;;;95      */
;;;96     PAN216_Err_t PAN216_WriteReg(uint8_t addr, uint8_t value)
;;;97     {
;;;98         PAN216_Write(addr, &value, 1);
;;;99     
;;;100    #if SPI_CHECK_WRITE
;;;101        uint8_t tmp;
;;;102        tmp = PAN216_ReadReg(addr);
;;;103        if (tmp != value)
;;;104        {
;;;105            printf("write reg [readback:0x%02x] writeval:0x%02x error \r\n ", tmp, value);
;;;106            return PAN216_ERR;
;;;107        }
;;;108    #endif
;;;109    
;;;110        return PAN216_OK;
;;;111    }
;;;112    
;;;113    /**
;;;114     * @brief Write to the global register in the current page without check
;;;115     * @param[in] addr Register address to write
;;;116     * @param[in] value Value to write to the register
;;;117     * @return Result
;;;118     */
;;;119    PAN216_Err_t PAN216_WriteRegUnchecked(uint8_t addr, uint8_t value)
;;;120    {
;;;121        PAN216_Write(addr, &value, 1);
;;;122        return PAN216_OK;
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief Write continuous register values (buffer) in a specific address page
;;;127     * @param[in] addr Register start address
;;;128     * @param[in] buffer Values to write
;;;129     * @param[in] len Buffer length
;;;130     * @return Result
;;;131     */
;;;132    PAN216_Err_t PAN216_WriteRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;133    {
;;;134        PAN216_Write(addr, buffer, len);
;;;135        return PAN216_OK;
;;;136    }
;;;137    
;;;138    /**
;;;139     * @brief This function reads more than one byte from the register
;;;140     *
;;;141     * @param addr Register address
;;;142     * @param buffer Buffer provided for data from the register
;;;143     * @param len Number of bytes to read
;;;144     * @return PAN216_Err_t
;;;145     */
;;;146    PAN216_Err_t PAN216_ReadRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;147    {
;;;148        PAN216_Read(addr, buffer, len);
;;;149        return PAN216_OK;
;;;150    }
;;;151    
;;;152    /**
;;;153     * @brief Transfer data to the data FIFO on the chip
;;;154     * @param[in] addr Register address to write
;;;155     * @param[in] buffer Buffer provided for data to write to the register
;;;156     * @param[in] size Number of bytes to write
;;;157     * @return Result
;;;158     */
;;;159    PAN216_Err_t PAN216_WriteFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;160    {
;;;161        return PAN216_WriteRegs(addr, buffer, size);
;;;162    }
;;;163    
;;;164    /**
;;;165     * @brief Read more than one byte from the register
;;;166     * @param[in] addr Register address to read
;;;167     * @param[in] buffer Buffer provided for data from the register
;;;168     * @param[in] size Number of bytes to read
;;;169     * @return Result
;;;170     */
;;;171    PAN216_Err_t PAN216_ReadFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;172    {
;;;173        return PAN216_ReadRegs(addr, buffer, size);
;;;174    }
;;;175    
;;;176    /**
;;;177     * @brief This function writes bits to the register by mask
;;;178     *
;;;179     * @param addr Register address
;;;180     * @param val Bits value
;;;181     * @param mask Bits mask
;;;182     * @return PAN216_Err_t
;;;183     */
;;;184    PAN216_Err_t PAN216_WriteRegBits(uint8_t addr, uint8_t val, uint8_t mask)
;;;185    {
;;;186        uint8_t tmp;
;;;187        PAN216_Err_t ret;
;;;188        uint8_t shift = GET_SHIFT(mask);
;;;189    
;;;190        val <<= shift;
;;;191        if (val & (~mask))
;;;192        {
;;;193            printf("val:0x%02x mask:0x%02x error \r\n", val, mask);
;;;194            return PAN216_ERR;
;;;195        }
;;;196        val &= mask;
;;;197    
;;;198        tmp = PAN216_ReadReg(addr);
;;;199        ret = PAN216_WriteReg(addr, (tmp & (~mask)) | val);
;;;200    
;;;201        return ret;
;;;202    }
;;;203    
;;;204    /**************************************************************************/
;;;205    /*                         Page Register Operation                        */
;;;206    /**************************************************************************/
;;;207    
;;;208    /**
;;;209     * @brief Switch page
;;;210     * @param[in] page Page to switch
;;;211     * @return Result
;;;212     */
;;;213    PAN216_Err_t PAN216_SetPage(uint8_t page)
;;;214    {
;;;215        if (PAN216_OK != PAN216_WriteReg(PAGE_CFG, page))
;;;216        {
;;;217            return PAN216_ERR;
;;;218        }
;;;219    
;;;220        return PAN216_OK;
;;;221    }
;;;222    
;;;223    /**
;;;224     * @brief This function writes a value to the register in a specific page
;;;225     * @param[in] page The page of the register
;;;226     * @param[in] addr Register address
;;;227     * @param[in] value Value to write
;;;228     * @return Result
;;;229     */
;;;230    PAN216_Err_t PAN216_WritePageReg(uint8_t page, uint8_t addr, uint8_t value)
;;;231    {
        0x000013c8:    b5f8        ..      PUSH     {r3-r7,lr}
        0x000013ca:    4605        .F      MOV      r5,r0
        0x000013cc:    4616        .F      MOV      r6,r2
        0x000013ce:    460f        .F      MOV      r7,r1
;;;232        uint8_t original_page;
;;;233    
;;;234        original_page = PAN216_ReadReg(PAGE_CFG);
        0x000013d0:    2000        .       MOVS     r0,#0
        0x000013d2:    f7fffd1a    ....    BL       PAN216_ReadReg ; 0xe0a
        0x000013d6:    4604        .F      MOV      r4,r0
;;;235        if (page != original_page)
        0x000013d8:    42a5        .B      CMP      r5,r4
        0x000013da:    d004        ..      BEQ      0x13e6 ; PAN216_WritePageReg + 30
;;;236        {
;;;237            P_ASSERT(PAN216_SetPage(page));
        0x000013dc:    4628        (F      MOV      r0,r5
        0x000013de:    f7fffe4f    ..O.    BL       PAN216_SetPage ; 0x1080
        0x000013e2:    2800        .(      CMP      r0,#0
        0x000013e4:    d10c        ..      BNE      0x1400 ; PAN216_WritePageReg + 56
;;;238        }
;;;239        P_ASSERT(PAN216_WriteReg(addr, value));
        0x000013e6:    4631        1F      MOV      r1,r6
        0x000013e8:    4638        8F      MOV      r0,r7
        0x000013ea:    f000f83f    ..?.    BL       PAN216_WriteReg ; 0x146c
        0x000013ee:    2800        .(      CMP      r0,#0
        0x000013f0:    d106        ..      BNE      0x1400 ; PAN216_WritePageReg + 56
;;;240        if (page != original_page)
        0x000013f2:    42a5        .B      CMP      r5,r4
        0x000013f4:    d006        ..      BEQ      0x1404 ; PAN216_WritePageReg + 60
;;;241        {
;;;242            P_ASSERT(PAN216_SetPage(original_page));
        0x000013f6:    4620         F      MOV      r0,r4
        0x000013f8:    f7fffe42    ..B.    BL       PAN216_SetPage ; 0x1080
        0x000013fc:    2800        .(      CMP      r0,#0
        0x000013fe:    d001        ..      BEQ      0x1404 ; PAN216_WritePageReg + 60
        0x00001400:    2001        .       MOVS     r0,#1
        0x00001402:    bdf8        ..      POP      {r3-r7,pc}
;;;243        }
;;;244    
;;;245        return PAN216_OK;
        0x00001404:    2000        .       MOVS     r0,#0
;;;246    }
        0x00001406:    bdf8        ..      POP      {r3-r7,pc}
    i.PAN216_WritePageRegBits
    PAN216_WritePageRegBits
;;;247    
;;;248    /**
;;;249     * @brief This function writes a value to the register in a specific page without check
;;;250     *
;;;251     * @param page Register page
;;;252     * @param addr Register address
;;;253     * @param value Register value
;;;254     * @return PAN216_Err_t
;;;255     */
;;;256    PAN216_Err_t PAN216_WritePageRegUnchecked(uint8_t page, uint8_t addr, uint8_t value)
;;;257    {
;;;258        uint8_t original_page;
;;;259    
;;;260        original_page = PAN216_ReadReg(PAGE_CFG);
;;;261        if (page != original_page)
;;;262        {
;;;263            PAN216_SetPage(page);
;;;264        }
;;;265        PAN216_Write(addr, &value, 1);
;;;266        if (page != original_page)
;;;267        {
;;;268            PAN216_SetPage(original_page);
;;;269        }
;;;270    
;;;271        return PAN216_OK;
;;;272    }
;;;273    
;;;274    /**
;;;275     * @brief Read a value from the register in a specific page
;;;276     * @param[in] page The page of the register
;;;277     * @param[in] addr Register address
;;;278     * @return Success (register value) or failure
;;;279     */
;;;280    uint8_t PAN216_ReadPageReg(uint8_t page, uint8_t addr)
;;;281    {
;;;282        uint8_t value;
;;;283        uint8_t original_page;
;;;284    
;;;285        original_page = PAN216_ReadReg(PAGE_CFG);
;;;286        if (page != original_page)
;;;287        {
;;;288            PAN216_SetPage(page);
;;;289        }
;;;290        value = PAN216_ReadReg(addr);
;;;291        if (page != original_page)
;;;292        {
;;;293            PAN216_SetPage(original_page);
;;;294        }
;;;295    
;;;296        return value;
;;;297    }
;;;298    
;;;299    /**
;;;300     * @brief Write continuous register values (buffer) in a specific address page
;;;301     * @param[in] page The page of the register
;;;302     * @param[in] addr Register start address
;;;303     * @param[in] buffer Values to write
;;;304     * @param[in] len Buffer length
;;;305     * @return Result
;;;306     */
;;;307    PAN216_Err_t PAN216_WritePageRegs(uint8_t page, uint8_t addr, uint8_t *buffer, uint8_t len)
;;;308    {
;;;309        uint8_t original_page;
;;;310    
;;;311        original_page = PAN216_ReadReg(PAGE_CFG);
;;;312        if (page != original_page)
;;;313        {
;;;314            PAN216_SetPage(page);
;;;315        }
;;;316        PAN216_WriteRegs(addr, buffer, len);
;;;317        if (page != original_page)
;;;318        {
;;;319            PAN216_SetPage(original_page);
;;;320        }
;;;321    
;;;322        return PAN216_OK;
;;;323    }
;;;324    
;;;325    /**
;;;326     * @brief This function reads more than one byte from the register
;;;327     *
;;;328     * @param page Page of the register
;;;329     * @param addr Register address
;;;330     * @param buffer Buffer provided for data from the register
;;;331     * @param len Number of bytes to read
;;;332     * @return PAN216_Err_t
;;;333     */
;;;334    PAN216_Err_t PAN216_ReadPageRegs(uint8_t page, uint8_t addr, uint8_t *buffer, uint8_t len)
;;;335    {
;;;336        uint8_t original_page;
;;;337    
;;;338        original_page = PAN216_ReadReg(PAGE_CFG);
;;;339        if (page != original_page)
;;;340        {
;;;341            PAN216_SetPage(page);
;;;342        }
;;;343        PAN216_Read(addr, buffer, len);
;;;344        if (page != original_page)
;;;345        {
;;;346            PAN216_SetPage(original_page);
;;;347        }
;;;348    
;;;349        return PAN216_OK;
;;;350    }
;;;351    
;;;352    /**************************************************************************/
;;;353    /*                         Register Bit Operation                         */
;;;354    /**************************************************************************/
;;;355    /**
;;;356     * @brief Write bits to the register by mask
;;;357     * @param page Page of the register
;;;358     * @param addr Register address
;;;359     * @param mask Bits mask
;;;360     * @param value Bits value
;;;361     * @return PAN216_Err_t
;;;362     */
;;;363    PAN216_Err_t PAN216_WriteRegWithMask(uint8_t page, uint8_t addr, uint8_t mask, uint8_t value)
;;;364    {
;;;365        uint8_t tmp;
;;;366        PAN216_Err_t ret;
;;;367    
;;;368        value &= mask;
;;;369        tmp = PAN216_ReadPageReg(page, addr);
;;;370        ret = PAN216_WritePageReg(page, addr, (tmp & (~mask)) | value);
;;;371    
;;;372        return ret;
;;;373    }
;;;374    
;;;375    /**
;;;376     * @brief This function reads the register value with mask
;;;377     *
;;;378     * @param page Register page
;;;379     * @param addr Register address
;;;380     * @param mask Bits mask
;;;381     * @return uint8_t
;;;382     */
;;;383    uint8_t PAN216_ReadRegWithMask(uint8_t page, uint8_t addr, uint8_t mask)
;;;384    {
;;;385        uint8_t tmp;
;;;386    
;;;387        tmp = PAN216_ReadPageReg(page, addr);
;;;388    
;;;389        return tmp & mask;
;;;390    }
;;;391    
;;;392    /**
;;;393     * @brief Set bits to 1
;;;394     *
;;;395     * @param page Page of the register
;;;396     * @param addr Register address
;;;397     * @param mask Bits mask
;;;398     * @return PAN216_Err_t
;;;399     */
;;;400    PAN216_Err_t PAN216_SetRegBits(uint8_t page, uint8_t addr, uint8_t mask)
;;;401    {
;;;402        uint8_t tmp;
;;;403        PAN216_Err_t ret;
;;;404    
;;;405        tmp = PAN216_ReadPageReg(page, addr);
;;;406        ret = PAN216_WritePageReg(page, addr, tmp | mask);
;;;407    
;;;408        return ret;
;;;409    }
;;;410    
;;;411    /**
;;;412     * @brief Set bits to 0
;;;413     *
;;;414     * @param page Page of the register
;;;415     * @param addr Register address
;;;416     * @param mask Bits mask
;;;417     * @return PAN216_Err_t
;;;418     */
;;;419    PAN216_Err_t PAN216_ResetRegBits(uint8_t page, uint8_t addr, uint8_t mask)
;;;420    {
;;;421        uint8_t tmp;
;;;422        PAN216_Err_t ret;
;;;423    
;;;424        tmp = PAN216_ReadPageReg(page, addr);
;;;425        ret = PAN216_WritePageReg(page, addr, tmp & (~mask));
;;;426    
;;;427        return ret;
;;;428    }
;;;429    
;;;430    /**
;;;431     * @brief Write bits to the register by mask
;;;432     * @param page Page of the register
;;;433     * @param addr Register address
;;;434     * @param mask Bits mask
;;;435     * @param value Bits value
;;;436     * @return PAN216_Err_t
;;;437     */
;;;438    PAN216_Err_t PAN216_WritePageRegBits(uint8_t page, uint8_t addr, uint8_t val, uint8_t mask)
;;;439    {
        0x00001408:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0000140a:    4607        .F      MOV      r7,r0
        0x0000140c:    4614        .F      MOV      r4,r2
        0x0000140e:    460e        .F      MOV      r6,r1
        0x00001410:    461d        .F      MOV      r5,r3
;;;440        uint8_t tmp;
;;;441        PAN216_Err_t ret;
;;;442    
;;;443        uint8_t shift = GET_SHIFT(mask);
        0x00001412:    4618        .F      MOV      r0,r3
        0x00001414:    f000f9e5    ....    BL       __ctz ; 0x17e2
;;;444    
;;;445        val <<= shift;
        0x00001418:    4084        .@      LSLS     r4,r4,r0
        0x0000141a:    b2e4        ..      UXTB     r4,r4
;;;446        val &= mask;
        0x0000141c:    402c        ,@      ANDS     r4,r4,r5
;;;447    
;;;448        tmp = PAN216_ReadPageReg(page, addr);
        0x0000141e:    4631        1F      MOV      r1,r6
        0x00001420:    4638        8F      MOV      r0,r7
        0x00001422:    f7fffcdb    ....    BL       PAN216_ReadPageReg ; 0xddc
;;;449        ret = PAN216_WritePageReg(page, addr, (tmp & (~mask)) | val);
        0x00001426:    43a8        .C      BICS     r0,r0,r5
        0x00001428:    4320         C      ORRS     r0,r0,r4
        0x0000142a:    4602        .F      MOV      r2,r0
        0x0000142c:    4631        1F      MOV      r1,r6
        0x0000142e:    4638        8F      MOV      r0,r7
        0x00001430:    f7ffffca    ....    BL       PAN216_WritePageReg ; 0x13c8
;;;450    
;;;451        return ret;
;;;452    }
        0x00001434:    bdf8        ..      POP      {r3-r7,pc}
    i.PAN216_WritePageRegs
    PAN216_WritePageRegs
        0x00001436:    b5ff        ..      PUSH     {r0-r7,lr}
        0x00001438:    4605        .F      MOV      r5,r0
        0x0000143a:    b081        ..      SUB      sp,sp,#4
        0x0000143c:    461e        .F      MOV      r6,r3
        0x0000143e:    4617        .F      MOV      r7,r2
;;; ..\..\..\..\radio\pan216_reg.c (311)
        0x00001440:    2000        .       MOVS     r0,#0
        0x00001442:    f7fffce2    ....    BL       PAN216_ReadReg ; 0xe0a
        0x00001446:    4604        .F      MOV      r4,r0
;;;312        if (page != original_page)
        0x00001448:    42a5        .B      CMP      r5,r4
        0x0000144a:    d002        ..      BEQ      0x1452 ; PAN216_WritePageRegs + 28
;;;313        {
;;;314            PAN216_SetPage(page);
        0x0000144c:    4628        (F      MOV      r0,r5
        0x0000144e:    f7fffe17    ....    BL       PAN216_SetPage ; 0x1080
;;;315        }
;;;316        PAN216_WriteRegs(addr, buffer, len);
        0x00001452:    4632        2F      MOV      r2,r6
        0x00001454:    4639        9F      MOV      r1,r7
        0x00001456:    9802        ..      LDR      r0,[sp,#8]
        0x00001458:    f000f86f    ..o.    BL       PAN216_WriteRegs ; 0x153a
;;;317        if (page != original_page)
        0x0000145c:    42a5        .B      CMP      r5,r4
        0x0000145e:    d002        ..      BEQ      0x1466 ; PAN216_WritePageRegs + 48
;;;318        {
;;;319            PAN216_SetPage(original_page);
        0x00001460:    4620         F      MOV      r0,r4
        0x00001462:    f7fffe0d    ....    BL       PAN216_SetPage ; 0x1080
;;;320        }
;;;321    
;;;322        return PAN216_OK;
        0x00001466:    2000        .       MOVS     r0,#0
;;;323    }
        0x00001468:    b005        ..      ADD      sp,sp,#0x14
        0x0000146a:    bdf0        ..      POP      {r4-r7,pc}
    i.PAN216_WriteReg
    PAN216_WriteReg
;;; ..\..\..\..\radio\pan216_reg.c (97)
        0x0000146c:    b513        ..      PUSH     {r0,r1,r4,lr}
        0x0000146e:    4604        .F      MOV      r4,r0
;;;98         PAN216_Write(addr, &value, 1);
        0x00001470:    2201        ."      MOVS     r2,#1
        0x00001472:    a901        ..      ADD      r1,sp,#4
        0x00001474:    f7ffff8e    ....    BL       PAN216_Write ; 0x1394
;;;99     
;;;100    #if SPI_CHECK_WRITE
;;;101        uint8_t tmp;
;;;102        tmp = PAN216_ReadReg(addr);
        0x00001478:    4620         F      MOV      r0,r4
        0x0000147a:    f7fffcc6    ....    BL       PAN216_ReadReg ; 0xe0a
        0x0000147e:    4601        .F      MOV      r1,r0
;;;103        if (tmp != value)
        0x00001480:    4668        hF      MOV      r0,sp
        0x00001482:    7902        .y      LDRB     r2,[r0,#4]
        0x00001484:    4291        .B      CMP      r1,r2
        0x00001486:    d004        ..      BEQ      0x1492 ; PAN216_WriteReg + 38
;;;104        {
;;;105            printf("write reg [readback:0x%02x] writeval:0x%02x error \r\n ", tmp, value);
        0x00001488:    a003        ..      ADR      r0,{pc}+0x10 ; 0x1498
        0x0000148a:    f000f98d    ....    BL       __0printf$8 ; 0x17a8
;;;106            return PAN216_ERR;
        0x0000148e:    2001        .       MOVS     r0,#1
        0x00001490:    bd1c        ..      POP      {r2-r4,pc}
;;;107        }
;;;108    #endif
;;;109    
;;;110        return PAN216_OK;
        0x00001492:    2000        .       MOVS     r0,#0
;;;111    }
        0x00001494:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x00001496:    0000        ..      DCW    0
        0x00001498:    74697277    writ    DCD    1953067639
        0x0000149c:    65722065    e re    DCD    1701978213
        0x000014a0:    725b2067    g [r    DCD    1918574695
        0x000014a4:    62646165    eadb    DCD    1650745701
        0x000014a8:    3a6b6361    ack:    DCD    980116321
        0x000014ac:    30257830    0x%0    DCD    807761968
        0x000014b0:    205d7832    2x]     DCD    542996530
        0x000014b4:    74697277    writ    DCD    1953067639
        0x000014b8:    6c617665    eval    DCD    1818326629
        0x000014bc:    2578303a    :0x%    DCD    628633658
        0x000014c0:    20783230    02x     DCD    544748080
        0x000014c4:    6f727265    erro    DCD    1869771365
        0x000014c8:    0a0d2072    r ..    DCD    168632434
        0x000014cc:    00000020     ...    DCD    32
    $t
    i.PAN216_WriteRegBits
    PAN216_WriteRegBits
;;;112    
;;;113    /**
;;;114     * @brief Write to the global register in the current page without check
;;;115     * @param[in] addr Register address to write
;;;116     * @param[in] value Value to write to the register
;;;117     * @return Result
;;;118     */
;;;119    PAN216_Err_t PAN216_WriteRegUnchecked(uint8_t addr, uint8_t value)
;;;120    {
;;;121        PAN216_Write(addr, &value, 1);
;;;122        return PAN216_OK;
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief Write continuous register values (buffer) in a specific address page
;;;127     * @param[in] addr Register start address
;;;128     * @param[in] buffer Values to write
;;;129     * @param[in] len Buffer length
;;;130     * @return Result
;;;131     */
;;;132    PAN216_Err_t PAN216_WriteRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;133    {
;;;134        PAN216_Write(addr, buffer, len);
;;;135        return PAN216_OK;
;;;136    }
;;;137    
;;;138    /**
;;;139     * @brief This function reads more than one byte from the register
;;;140     *
;;;141     * @param addr Register address
;;;142     * @param buffer Buffer provided for data from the register
;;;143     * @param len Number of bytes to read
;;;144     * @return PAN216_Err_t
;;;145     */
;;;146    PAN216_Err_t PAN216_ReadRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;147    {
;;;148        PAN216_Read(addr, buffer, len);
;;;149        return PAN216_OK;
;;;150    }
;;;151    
;;;152    /**
;;;153     * @brief Transfer data to the data FIFO on the chip
;;;154     * @param[in] addr Register address to write
;;;155     * @param[in] buffer Buffer provided for data to write to the register
;;;156     * @param[in] size Number of bytes to write
;;;157     * @return Result
;;;158     */
;;;159    PAN216_Err_t PAN216_WriteFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;160    {
;;;161        return PAN216_WriteRegs(addr, buffer, size);
;;;162    }
;;;163    
;;;164    /**
;;;165     * @brief Read more than one byte from the register
;;;166     * @param[in] addr Register address to read
;;;167     * @param[in] buffer Buffer provided for data from the register
;;;168     * @param[in] size Number of bytes to read
;;;169     * @return Result
;;;170     */
;;;171    PAN216_Err_t PAN216_ReadFifo(uint8_t addr, uint8_t *buffer, uint8_t size)
;;;172    {
;;;173        return PAN216_ReadRegs(addr, buffer, size);
;;;174    }
;;;175    
;;;176    /**
;;;177     * @brief This function writes bits to the register by mask
;;;178     *
;;;179     * @param addr Register address
;;;180     * @param val Bits value
;;;181     * @param mask Bits mask
;;;182     * @return PAN216_Err_t
;;;183     */
;;;184    PAN216_Err_t PAN216_WriteRegBits(uint8_t addr, uint8_t val, uint8_t mask)
;;;185    {
        0x000014d0:    b570        p.      PUSH     {r4-r6,lr}
        0x000014d2:    4605        .F      MOV      r5,r0
        0x000014d4:    460e        .F      MOV      r6,r1
        0x000014d6:    4614        .F      MOV      r4,r2
;;;186        uint8_t tmp;
;;;187        PAN216_Err_t ret;
;;;188        uint8_t shift = GET_SHIFT(mask);
        0x000014d8:    4610        .F      MOV      r0,r2
        0x000014da:    f000f982    ....    BL       __ctz ; 0x17e2
;;;189    
;;;190        val <<= shift;
        0x000014de:    4086        .@      LSLS     r6,r6,r0
        0x000014e0:    b2f1        ..      UXTB     r1,r6
        0x000014e2:    4608        .F      MOV      r0,r1
;;;191        if (val & (~mask))
        0x000014e4:    43a0        .C      BICS     r0,r0,r4
        0x000014e6:    d005        ..      BEQ      0x14f4 ; PAN216_WriteRegBits + 36
;;;192        {
;;;193            printf("val:0x%02x mask:0x%02x error \r\n", val, mask);
        0x000014e8:    4622        "F      MOV      r2,r4
        0x000014ea:    a008        ..      ADR      r0,{pc}+0x22 ; 0x150c
        0x000014ec:    f000f95c    ..\.    BL       __0printf$8 ; 0x17a8
;;;194            return PAN216_ERR;
        0x000014f0:    2001        .       MOVS     r0,#1
        0x000014f2:    bd70        p.      POP      {r4-r6,pc}
;;;195        }
;;;196        val &= mask;
        0x000014f4:    4021        !@      ANDS     r1,r1,r4
        0x000014f6:    460e        .F      MOV      r6,r1
;;;197    
;;;198        tmp = PAN216_ReadReg(addr);
        0x000014f8:    4628        (F      MOV      r0,r5
        0x000014fa:    f7fffc86    ....    BL       PAN216_ReadReg ; 0xe0a
;;;199        ret = PAN216_WriteReg(addr, (tmp & (~mask)) | val);
        0x000014fe:    43a0        .C      BICS     r0,r0,r4
        0x00001500:    4330        0C      ORRS     r0,r0,r6
        0x00001502:    4601        .F      MOV      r1,r0
        0x00001504:    4628        (F      MOV      r0,r5
        0x00001506:    f7ffffb1    ....    BL       PAN216_WriteReg ; 0x146c
;;;200    
;;;201        return ret;
;;;202    }
        0x0000150a:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0000150c:    3a6c6176    val:    DCD    980181366
        0x00001510:    30257830    0x%0    DCD    807761968
        0x00001514:    6d207832    2x m    DCD    1830844466
        0x00001518:    3a6b7361    ask:    DCD    980120417
        0x0000151c:    30257830    0x%0    DCD    807761968
        0x00001520:    65207832    2x e    DCD    1696626738
        0x00001524:    726f7272    rror    DCD    1919906418
        0x00001528:    000a0d20     ...    DCD    658720
    $t
    i.PAN216_WriteRegUnchecked
    PAN216_WriteRegUnchecked
;;; ..\..\..\..\radio\pan216_reg.c (120)
        0x0000152c:    b513        ..      PUSH     {r0,r1,r4,lr}
;;;121        PAN216_Write(addr, &value, 1);
        0x0000152e:    2201        ."      MOVS     r2,#1
        0x00001530:    a901        ..      ADD      r1,sp,#4
        0x00001532:    f7ffff2f    ../.    BL       PAN216_Write ; 0x1394
;;;122        return PAN216_OK;
        0x00001536:    2000        .       MOVS     r0,#0
;;;123    }
        0x00001538:    bd1c        ..      POP      {r2-r4,pc}
    i.PAN216_WriteRegs
    PAN216_WriteRegs
;;;124    
;;;125    /**
;;;126     * @brief Write continuous register values (buffer) in a specific address page
;;;127     * @param[in] addr Register start address
;;;128     * @param[in] buffer Values to write
;;;129     * @param[in] len Buffer length
;;;130     * @return Result
;;;131     */
;;;132    PAN216_Err_t PAN216_WriteRegs(uint8_t addr, uint8_t *buffer, uint8_t len)
;;;133    {
        0x0000153a:    b510        ..      PUSH     {r4,lr}
;;;134        PAN216_Write(addr, buffer, len);
        0x0000153c:    f7ffff2a    ..*.    BL       PAN216_Write ; 0x1394
;;;135        return PAN216_OK;
        0x00001540:    2000        .       MOVS     r0,#0
;;;136    }
        0x00001542:    bd10        ..      POP      {r4,pc}
    i.RF_BusInit
    RF_BusInit
;;; ..\..\..\..\radio\pan216_port.c
;;;50     {
        0x00001544:    b510        ..      PUSH     {r4,lr}
;;;51     #if INTERFACE_MODE == USE_SPI_3LINE
;;;52         ITF_3SPIINIT();
;;;53     #elif INTERFACE_MODE == USE_I2C
;;;54         ITF_IICINIT();
;;;55     #endif
;;;56     #if INTERFACE_MODE == USE_SPI_4LINE
;;;57         ITF_4SPIINIT();
        0x00001546:    f7fefea9    ....    BL       BSP_4LineSPIInit ; 0x29c
;;;58     #endif
;;;59     }
        0x0000154a:    bd10        ..      POP      {r4,pc}
    i.SYS_ConfigMFP
    SYS_ConfigMFP
;;; ..\..\..\..\pan108\bsp.c
;;;225    {
        0x0000154c:    b510        ..      PUSH     {r4,lr}
;;;226        uint8_t port = PinID / 0x10;
        0x0000154e:    0902        ..      LSRS     r2,r0,#4
;;;227        uint8_t bit = PinID % 0x10;
        0x00001550:    0700        ..      LSLS     r0,r0,#28
        0x00001552:    0f00        ..      LSRS     r0,r0,#28
        0x00001554:    0093        ..      LSLS     r3,r2,#2
;;;228    
;;;229        (&SYS->P0_MFP)[port] = ((&SYS->P0_MFP)[port] & ~(SYS_MFP_P00_Msk << bit)) | PinFunction;
        0x00001556:    4a04        .J      LDR      r2,[pc,#16] ; [0x1568] = 0x40030000
        0x00001558:    189a        ..      ADDS     r2,r3,r2
        0x0000155a:    6813        .h      LDR      r3,[r2,#0]
        0x0000155c:    4c03        .L      LDR      r4,[pc,#12] ; [0x156c] = 0x10101
        0x0000155e:    4084        .@      LSLS     r4,r4,r0
        0x00001560:    43a3        .C      BICS     r3,r3,r4
        0x00001562:    430b        .C      ORRS     r3,r3,r1
        0x00001564:    6013        .`      STR      r3,[r2,#0]
;;;230    }
        0x00001566:    bd10        ..      POP      {r4,pc}
    $d
        0x00001568:    40030000    ...@    DCD    1073938432
        0x0000156c:    00010101    ....    DCD    65793
    $t
    i.SendChar
    SendChar
;;; .\..\..\..\..\pan108\device\Source\pan_retarget.c
;;;107    {
        0x00001570:    b500        ..      PUSH     {lr}
;;;108       SendChar_ToUART(ch);
        0x00001572:    f000f801    ....    BL       SendChar_ToUART ; 0x1578
;;;109    }
        0x00001576:    bd00        ..      POP      {pc}
    i.SendChar_ToUART
    SendChar_ToUART
;;; ..\..\..\..\pan108\peripheral\inc\pan_uart.h
;;;531        return (UARTx->USR & UART_USR_TFNF_Msk) ? false : true;
        0x00001578:    4903        .I      LDR      r1,[pc,#12] ; [0x1588] = 0x40013000
        0x0000157a:    6fca        .o      LDR      r2,[r1,#0x7c]
        0x0000157c:    0792        ..      LSLS     r2,r2,#30
        0x0000157e:    17d2        ..      ASRS     r2,r2,#31
        0x00001580:    1c52        R.      ADDS     r2,r2,#1
;;; .\..\..\..\..\pan108\device\Source\pan_retarget.c
;;;96         while(UART_IsTxFifoFull(DEBUG_PORT));
        0x00001582:    d1fa        ..      BNE      0x157a ; SendChar_ToUART + 2
;;;97         DEBUG_PORT->RBR_THR_DLL = ch;
        0x00001584:    6008        .`      STR      r0,[r1,#0]
;;;98     }
        0x00001586:    4770        pG      BX       lr
    $d
        0x00001588:    40013000    .0.@    DCD    1073819648
    $t
    i.SystemCoreClockUpdate
    SystemCoreClockUpdate
;;; .\..\..\..\..\pan108\device\Source\system_PANSeries.c
;;;150    {
        0x0000158c:    b510        ..      PUSH     {r4,lr}
        0x0000158e:    480c        .H      LDR      r0,[pc,#48] ; [0x15c0] = 0x40040000
        0x00001590:    6a01        .j      LDR      r1,[r0,#0x20]
        0x00001592:    0409        ..      LSLS     r1,r1,#16
        0x00001594:    0f09        ..      LSRS     r1,r1,#28
;;; .\..\..\..\..\pan108\device\Source\system_PANSeries.c (150)
        0x00001596:    d00a        ..      BEQ      0x15ae ; SystemCoreClockUpdate + 34
        0x00001598:    1c49        I.      ADDS     r1,r1,#1
;;;151        uint32_t div = 0;
;;;152        uint32_t freq_out = 0;
;;;153        div = (CLK->CLK_TOP_CTRL & CLK_TOPCTL_AHB_DIV_Msk) >> CLK_TOPCTL_AHB_DIV_Pos;
;;;154        if(div == 0)
;;;155            div = 1;
;;;156        else
;;;157            div += 1;
;;;158    
;;;159        if(CLK->CLK_TOP_CTRL & CLK_SYS_SRCSEL_DPLL){
        0x0000159a:    6a02        .j      LDR      r2,[r0,#0x20]
        0x0000159c:    4c09        .L      LDR      r4,[pc,#36] ; [0x15c4] = 0x20000000
        0x0000159e:    0592        ..      LSLS     r2,r2,#22
        0x000015a0:    d50c        ..      BPL      0x15bc ; SystemCoreClockUpdate + 48
;;;160            freq_out = (CLK->DPLL_CTRL & CLK_DPLLCTL_FREQ_OUT_Msk);
        0x000015a2:    6b40        @k      LDR      r0,[r0,#0x34]
        0x000015a4:    07c0        ..      LSLS     r0,r0,#31
        0x000015a6:    0fc0        ..      LSRS     r0,r0,#31
;;;161            if(freq_out == CLK_DPLL_OUT_64M){
        0x000015a8:    d003        ..      BEQ      0x15b2 ; SystemCoreClockUpdate + 38
;;;162                SystemCoreClock = FREQ_64MHZ  / div;
        0x000015aa:    4807        .H      LDR      r0,[pc,#28] ; [0x15c8] = 0x3d09000
        0x000015ac:    e002        ..      B        0x15b4 ; SystemCoreClockUpdate + 40
        0x000015ae:    2101        .!      MOVS     r1,#1
        0x000015b0:    e7f3        ..      B        0x159a ; SystemCoreClockUpdate + 14
;;;163            }
;;;164            else{
;;;165                SystemCoreClock = FREQ_48MHZ / div;
        0x000015b2:    4806        .H      LDR      r0,[pc,#24] ; [0x15cc] = 0x2dc6c00
;;;166            }
;;;167        }
;;;168        else{
;;;169            SystemCoreClock = FREQ_32MHZ / div;
        0x000015b4:    f7fefdaa    ....    BL       __aeabi_uidiv ; 0x10c
        0x000015b8:    6020         `      STR      r0,[r4,#0]
        0x000015ba:    bd10        ..      POP      {r4,pc}
        0x000015bc:    4804        .H      LDR      r0,[pc,#16] ; [0x15d0] = 0x1e84800
        0x000015be:    e7f9        ..      B        0x15b4 ; SystemCoreClockUpdate + 40
    $d
        0x000015c0:    40040000    ...@    DCD    1074003968
        0x000015c4:    20000000    ...     DCD    536870912
        0x000015c8:    03d09000    ....    DCD    64000000
        0x000015cc:    02dc6c00    .l..    DCD    48000000
        0x000015d0:    01e84800    .H..    DCD    32000000
    $t
    i.SystemInit
    SystemInit
;;; .\..\..\..\..\pan108\device\Source\system_PANSeries.c (33)
        0x000015d4:    b5f8        ..      PUSH     {r3-r7,lr}
;;;34         // (Workaround) Maximum HLDO (DVDD) electrical level to enhance system stability
;;;35         // ANA->LP_HP_LDO = (ANA->LP_HP_LDO & ~0x2) | (0xf << 3);
;;;36     
;;;37         // Use external DVDD capacitor
;;;38         ANA->LP_HP_LDO |= BIT9;
        0x000015d6:    481e        .H      LDR      r0,[pc,#120] ; [0x1650] = 0x40070000
        0x000015d8:    6a01        .j      LDR      r1,[r0,#0x20]
        0x000015da:    1542        B.      ASRS     r2,r0,#21
        0x000015dc:    4311        .C      ORRS     r1,r1,r2
        0x000015de:    6201        .b      STR      r1,[r0,#0x20]
;;;39     
;;;40         // Flash io pullup enable
;;;41         ANA->ANA_MISC1 |= (0x3b << 14);
        0x000015e0:    481b        .H      LDR      r0,[pc,#108] ; [0x1650] = 0x40070000
        0x000015e2:    3040        @0      ADDS     r0,r0,#0x40
        0x000015e4:    6941        Ai      LDR      r1,[r0,#0x14]
        0x000015e6:    223b        ;"      MOVS     r2,#0x3b
        0x000015e8:    0392        ..      LSLS     r2,r2,#14
        0x000015ea:    4311        .C      ORRS     r1,r1,r2
        0x000015ec:    6141        Aa      STR      r1,[r0,#0x14]
;;;42     
;;;43         // Clear Retention Ctrl Flag (BIT31 of GPIO_DBCTL) in GPIO module to make sure
;;;44         // IOMUX is valid to use when soc wakes up from standby mode 1.
;;;45         GPIO_DB->DBCTL &= ~BIT31;
        0x000015ee:    4819        .H      LDR      r0,[pc,#100] ; [0x1654] = 0x40020180
        0x000015f0:    6801        .h      LDR      r1,[r0,#0]
        0x000015f2:    0049        I.      LSLS     r1,r1,#1
        0x000015f4:    0849        I.      LSRS     r1,r1,#1
        0x000015f6:    6001        .`      STR      r1,[r0,#0]
;;;46     
;;;47         // fix bug 227: j-link debug failed when XTL selected
;;;48         if ((CLK->XTL_CTRL & (1 << 24)))
        0x000015f8:    4c17        .L      LDR      r4,[pc,#92] ; [0x1658] = 0x40040000
        0x000015fa:    6ae0        .j      LDR      r0,[r4,#0x2c]
        0x000015fc:    2604        .&      MOVS     r6,#4
        0x000015fe:    01c0        ..      LSLS     r0,r0,#7
        0x00001600:    2800        .(      CMP      r0,#0
        0x00001602:    da02        ..      BGE      0x160a ; SystemInit + 54
;;;49         {
;;;50             // XTL_EN
;;;51             CLK->CLK_TOP_CTRL |= CLK_TOPCTL_XTL_EN_Msk;
        0x00001604:    6a20         j      LDR      r0,[r4,#0x20]
        0x00001606:    4330        0C      ORRS     r0,r0,r6
        0x00001608:    6220         b      STR      r0,[r4,#0x20]
;;;52         }
;;;53     
;;;54         // Set rx_neg to 1, which can support Flash Clock up to 80MHz
;;;55         // (We may need to do some tuning if Flash Clock is greater than 80MHz)
;;;56         FLCTL->X_FL_X_MODE |= (1 << 20);    //rx_neg
        0x0000160a:    4d14        .M      LDR      r5,[pc,#80] ; [0x165c] = 0x40050000
        0x0000160c:    68e8        .h      LDR      r0,[r5,#0xc]
        0x0000160e:    2101        .!      MOVS     r1,#1
        0x00001610:    0509        ..      LSLS     r1,r1,#20
        0x00001612:    4308        .C      ORRS     r0,r0,r1
        0x00001614:    60e8        .`      STR      r0,[r5,#0xc]
;;;57         // Switch flash to 4-Line mode
;;;58         FMC_SetFlashMode(FLCTL, PanFlashLineMode, PanFlashEnhanceEnable);
        0x00001616:    2200        ."      MOVS     r2,#0
        0x00001618:    2102        .!      MOVS     r1,#2
        0x0000161a:    4628        (F      MOV      r0,r5
        0x0000161c:    f7fff866    ..f.    BL       FMC_SetFlashMode ; 0x6ec
;;; ..\..\..\..\pan108\device\Include\pan_clk.h
;;;393        uint32_t reg = CLK->AHB_CLK_CTRL & (~CLK_AHBCLK_SPI_FLASH_DIV_Msk);
        0x00001620:    6ba0        .k      LDR      r0,[r4,#0x38]
        0x00001622:    210f        .!      MOVS     r1,#0xf
        0x00001624:    0409        ..      LSLS     r1,r1,#16
        0x00001626:    4388        .C      BICS     r0,r0,r1
;;;394        CLK->AHB_CLK_CTRL = reg | ((div << CLK_AHBCLK_SPI_FLASH_DIV_Pos) & CLK_AHBCLK_SPI_FLASH_DIV_Msk);
        0x00001628:    2700        .'      MOVS     r7,#0
        0x0000162a:    63a0        .c      STR      r0,[r4,#0x38]
;;; .\..\..\..\..\pan108\device\Source\system_PANSeries.c
;;;63         InitIcache(FLCTL, PanFlashLineMode);
        0x0000162c:    2102        .!      MOVS     r1,#2
        0x0000162e:    4628        (F      MOV      r0,r5
        0x00001630:    f7fff952    ..R.    BL       InitIcache ; 0x8d8
;;;64     
;;;65     #if defined(CONFIG_MCUBOOT)
;;;66     
;;;67         uint32_t *ptr_dcdc_flag = (uint32_t *)0x2000fffc;
;;;68     
;;;69         if(*ptr_dcdc_flag == 0x12345678){
;;;70             ANA->RSV1 |= BIT17; // To avoid potential buck enabling fail right after POR
;;;71             /* Configure DCDC params in normal mode */
;;;72             uint32_t tmp_reg_dcdc = ANA->LP_BUCK;
;;;73     
;;;74             tmp_reg_dcdc &= ~0X1;
;;;75             tmp_reg_dcdc = (tmp_reg_dcdc & ~(0X7<<5)) | (0X5<<5);
;;;76             ANA->LP_BUCK = tmp_reg_dcdc;
;;;77         } else {
;;;78             /* do nothing default ldo mode */
;;;79         }
;;;80     #endif
;;;81     
;;;82     #if CONFIG_PM
;;;83         /*
;;;84          * Enable standby IRQ as early as we can in order to execute corresponding
;;;85          * isr earlier to resume system from waking up from hw standby mode.
;;;86          * NOTE:
;;;87          *   1. We enable standby IRQ after cache init, thus we can execute
;;;88          *      standby ISR faster.
;;;89          *   2. We enable standby IRQ before the auto 3v-register-sync feature enabled,
;;;90          *      thus we can load the backup-to-ram aon register values back to related
;;;91          *      registers, so these values can be correctly load to 3v area after the
;;;92          *      auto 3v-reg-sync mechanism enabled.
;;;93          */
;;;94     	// NVIC_EnableIRQ(STANDBY_IRQn);
;;;95         /* Insure we are going to enter standby isr before the Auto-3v-sync feature enabled */
;;;96         // SYS_delay_10nop(1);
;;;97     #endif
;;;98     
;;;99     #ifndef SYNC_3V_REG_MANUALLY
;;;100        /* Here we enable the auto 3v-register-sync mechanism to simplify
;;;101         * operations for registers which have copies in the 3v always-on
;;;102         * area so that content in these registers could retain even in
;;;103         * low power mode.
;;;104         * NOTE: The auto 3v-reg-sync mechanism works for all related
;;;105         *       registers except Px_DINOFF regs for P46/P47/P56 in GPIO
;;;106         *       module.
;;;107         */
;;;108        CLK_Set3vSyncAuto();
        0x00001634:    f7feffe0    ....    BL       CLK_Set3vSyncAuto ; 0x5f8
;;;109    #endif
;;;110    
;;;111        // Enable DCDC in normal mode when CONFIG_SOC_DCDC_PAN1080 enabled
;;;112    #if (CONFIG_SOC_DCDC_PAN1080)
;;;113        ANA->RSV1 |= BIT17; // To avoid potential buck enabling fail right after POR
;;;114        /* Configure DCDC params in normal mode */
;;;115        uint32_t tmp_reg = ANA->LP_BUCK;
;;;116        tmp_reg &= ~0X1;
;;;117        tmp_reg = (tmp_reg & ~(0X7<<5)) | (0X5<<5);
;;;118        ANA->LP_BUCK = tmp_reg;
;;;119    #endif
;;;120    
;;;121        // Enable DCDC in lowpower mode only if:
;;;122        //  - CONFIG_SOC_DCDC_PAN1080 enabled
;;;123        //  - and CONFIG_PM enabled
;;;124    #if (CONFIG_SOC_DCDC_PAN1080 && CONFIG_PM)
;;;125    	/* Configure DCDC params in lowpower mode */
;;;126    	uint32_t tmp_reg1 = ANA->LP_FL_CTRL;
;;;127    	tmp_reg1 &= ~(0x6 << 12);
;;;128    	ANA->LP_FL_CTRL = tmp_reg1;
;;;129    #endif
;;;130    
;;;131        /*
;;;132         * Set this bit to make sure we can later switch pinmux of P43 to the function
;;;133         * PAN1080_PIN_FUNC_P43_UART0_TX to use for UART0 Tx.
;;;134         */
;;;135        SYS->CTRL0 |= BIT2;
        0x00001638:    4809        .H      LDR      r0,[pc,#36] ; [0x1660] = 0x40030040
        0x0000163a:    6881        .h      LDR      r1,[r0,#8]
        0x0000163c:    4331        1C      ORRS     r1,r1,r6
        0x0000163e:    6081        .`      STR      r1,[r0,#8]
;;;136    
;;;137        /*
;;;138         * Disable eFuse VDD for power saving purpose
;;;139         */
;;;140        EFUSE->EF_VDD = 0;
        0x00001640:    4808        .H      LDR      r0,[pc,#32] ; [0x1664] = 0x40080000
        0x00001642:    6107        .a      STR      r7,[r0,#0x10]
;;;141    
;;;142        /*
;;;143         * Increase dpll ivcobias to make dpll locking more easily
;;;144         */
;;;145        CLK->DPLL_CTRL |= (0x3u << 8);
        0x00001644:    6b60        `k      LDR      r0,[r4,#0x34]
        0x00001646:    2103        .!      MOVS     r1,#3
        0x00001648:    0209        ..      LSLS     r1,r1,#8
        0x0000164a:    4308        .C      ORRS     r0,r0,r1
        0x0000164c:    6360        `c      STR      r0,[r4,#0x34]
;;;146    }
        0x0000164e:    bdf8        ..      POP      {r3-r7,pc}
    $d
        0x00001650:    40070000    ...@    DCD    1074200576
        0x00001654:    40020180    ...@    DCD    1073873280
        0x00001658:    40040000    ...@    DCD    1074003968
        0x0000165c:    40050000    ...@    DCD    1074069504
        0x00001660:    40030040    @..@    DCD    1073938496
        0x00001664:    40080000    ...@    DCD    1074266112
    $t
    i.TMR0_IRQHandler
    TMR0_IRQHandler
;;; ..\..\..\..\pan108\peripheral\inc\pan_timer.h
;;;340        return(timer->INTSTS & TIMER_INTSTS_TIF_Msk ? 1 : 0);
        0x00001668:    4805        .H      LDR      r0,[pc,#20] ; [0x1680] = 0x40008000
        0x0000166a:    6881        .h      LDR      r1,[r0,#8]
        0x0000166c:    07c9        ..      LSLS     r1,r1,#31
        0x0000166e:    0fc9        ..      LSRS     r1,r1,#31
;;; ..\..\..\..\pan108\bsp.c
;;;84     {
        0x00001670:    d005        ..      BEQ      0x167e ; TMR0_IRQHandler + 22
;;; ..\..\..\..\pan108\peripheral\inc\pan_timer.h
;;;350        timer->INTSTS = TIMER_INTSTS_TIF_Msk;
        0x00001672:    2101        .!      MOVS     r1,#1
        0x00001674:    6081        .`      STR      r1,[r0,#8]
;;; ..\..\..\..\pan108\bsp.c
;;;89             g_SystemTick++;
        0x00001676:    4803        .H      LDR      r0,[pc,#12] ; [0x1684] = 0x20000004
        0x00001678:    6841        Ah      LDR      r1,[r0,#4]
        0x0000167a:    1c49        I.      ADDS     r1,r1,#1
        0x0000167c:    6041        A`      STR      r1,[r0,#4]
;;;90             
;;;91     //        if(g_SystemTick >= 1000)
;;;92     //        {
;;;93     //            g_SystemTick = 0;
;;;94     //            SYS_TEST("1 second.\n");
;;;95     //        }
;;;96         }
;;;97     }
        0x0000167e:    4770        pG      BX       lr
    $d
        0x00001680:    40008000    ...@    DCD    1073774592
        0x00001684:    20000004    ...     DCD    536870916
    $t
    i.UART_Init
    UART_Init
;;; .\..\..\..\..\pan108\peripheral\src\pan_uart.c
;;;26     {
        0x00001688:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0000168a:    460d        .F      MOV      r5,r1
        0x0000168c:    4604        .F      MOV      r4,r0
;;;27         uint32_t tmpreg = 0x00;
;;;28         uint32_t integerdivider = 0x00;
;;;29         uint32_t fractionaldivider = 0x00;
;;;30         uint64_t apbclock = 0x00;
;;;31         /*---------------------------- UART BRR Configuration -----------------------*/
;;;32         /* Configure the UART Baud Rate */
;;;33         apbclock = CLK_GetPeripheralFreq((void*)UARTx);
        0x0000168e:    f7feff09    ....    BL       CLK_GetPeripheralFreq ; 0x4a4
        0x00001692:    68e2        .h      LDR      r2,[r4,#0xc]
        0x00001694:    2100        .!      MOVS     r1,#0
;;;34     
;;;35         /*unlock to enable write & read divisor register*/
;;;36         UARTx->LCR |= UART_LCR_DLAB_Msk;
        0x00001696:    2780        .'      MOVS     r7,#0x80
        0x00001698:    433a        :C      ORRS     r2,r2,r7
        0x0000169a:    60e2        .`      STR      r2,[r4,#0xc]
;;;37         /* Determine the integer part baud_rate_divisor =  PCLK*100 / (16*required_baud_rate)*/
;;;38         integerdivider = ((25 * apbclock) / (4 * (UART_InitStruct->UART_BaudRate)));
        0x0000169c:    682a        *h      LDR      r2,[r5,#0]
        0x0000169e:    460b        .F      MOV      r3,r1
        0x000016a0:    0096        ..      LSLS     r6,r2,#2
        0x000016a2:    2219        ."      MOVS     r2,#0x19
        0x000016a4:    f7fefd78    ..x.    BL       __aeabi_lmul ; 0x198
        0x000016a8:    4632        2F      MOV      r2,r6
        0x000016aa:    2300        .#      MOVS     r3,#0
        0x000016ac:    f7fefd44    ..D.    BL       __aeabi_uldivmod ; 0x138
        0x000016b0:    4606        .F      MOV      r6,r0
;;;39     
;;;40         //Too high baudrate (too small divider) would cause DLL/DLH be all 0 which means UART disabled,
;;;41         //thus return false if this happens.
;;;42         if (integerdivider < 100)
        0x000016b2:    2864        d(      CMP      r0,#0x64
        0x000016b4:    d201        ..      BCS      0x16ba ; UART_Init + 50
;;;43             return false;
        0x000016b6:    2000        .       MOVS     r0,#0
        0x000016b8:    bdf8        ..      POP      {r3-r7,pc}
;;;44     
;;;45         tmpreg = (integerdivider / 100);
        0x000016ba:    2164        d!      MOVS     r1,#0x64
        0x000016bc:    f7fefd26    ..&.    BL       __aeabi_uidiv ; 0x10c
;;;46         UARTx->RBR_THR_DLL = tmpreg & 0xFF;
        0x000016c0:    b2c1        ..      UXTB     r1,r0
        0x000016c2:    6021        !`      STR      r1,[r4,#0]
;;;47         UARTx->IER_DLH = (tmpreg & 0xFF00 ) >> 8;
        0x000016c4:    0401        ..      LSLS     r1,r0,#16
        0x000016c6:    0e09        ..      LSRS     r1,r1,#24
        0x000016c8:    6061        a`      STR      r1,[r4,#4]
;;;48     
;;;49         /* Determine the fractional part */
;;;50         fractionaldivider = integerdivider - (100 * tmpreg);
        0x000016ca:    2164        d!      MOVS     r1,#0x64
        0x000016cc:    4348        HC      MULS     r0,r1,r0
        0x000016ce:    1a30        0.      SUBS     r0,r6,r0
;;;51     
;;;52         /* Implement the fractional part in the register */
;;;53         UARTx->DLF = ((((fractionaldivider * 16) + 50) / 100)) ;
        0x000016d0:    0100        ..      LSLS     r0,r0,#4
        0x000016d2:    3032        20      ADDS     r0,r0,#0x32
        0x000016d4:    f7fefd1a    ....    BL       __aeabi_uidiv ; 0x10c
        0x000016d8:    21c0        .!      MOVS     r1,#0xc0
        0x000016da:    5108        .Q      STR      r0,[r1,r4]
;;;54         UARTx->LCR &=  ~UART_LCR_DLAB_Msk;
        0x000016dc:    68e0        .h      LDR      r0,[r4,#0xc]
        0x000016de:    43b8        .C      BICS     r0,r0,r7
        0x000016e0:    60e0        .`      STR      r0,[r4,#0xc]
;;;55     
;;;56         /*---------------------------- UART Line Configuration -----------------------*/
;;;57         tmpreg = UARTx->LCR;
        0x000016e2:    68e0        .h      LDR      r0,[r4,#0xc]
;;;58         tmpreg &= ~(UART_LCR_SP_Msk | UART_LCR_EPS_Msk | UART_LCR_PEN_Msk | UART_LCR_STOP_Msk | UART_LCR_DLS_Msk);
        0x000016e4:    0981        ..      LSRS     r1,r0,#6
        0x000016e6:    7928        (y      LDRB     r0,[r5,#4]
        0x000016e8:    0189        ..      LSLS     r1,r1,#6
;;;59         tmpreg |= (UART_InitStruct->UART_LineCtrl);
        0x000016ea:    4308        .C      ORRS     r0,r0,r1
;;;60         UARTx->LCR = tmpreg;
        0x000016ec:    60e0        .`      STR      r0,[r4,#0xc]
;;;61     
;;;62         return true;
        0x000016ee:    2001        .       MOVS     r0,#1
;;;63     }
        0x000016f0:    bdf8        ..      POP      {r3-r7,pc}
        0x000016f2:    0000        ..      MOVS     r0,r0
    i.WriteRxDemodConfig
    WriteRxDemodConfig
;;; ..\..\..\..\radio\pan216_ext.c
;;;207    {
        0x000016f4:    b570        p.      PUSH     {r4-r6,lr}
        0x000016f6:    4914        .I      LDR      r1,[pc,#80] ; [0x1748] = 0x20000024
        0x000016f8:    4a14        .J      LDR      r2,[pc,#80] ; [0x174c] = 0x2064
        0x000016fa:    780b        .x      LDRB     r3,[r1,#0]
;;;208        for (int i = 0; i < sizeof(RxDemodIndex) / sizeof(RxDemodIndex[0]); i++)
        0x000016fc:    2000        .       MOVS     r0,#0
;;;209        {
;;;210            if (_gChipMode == RxDemodIndex[i].ChipMode && _gDataRate == RxDemodIndex[i].DataRate &&
        0x000016fe:    0084        ..      LSLS     r4,r0,#2
        0x00001700:    5d15        .]      LDRB     r5,[r2,r4]
        0x00001702:    429d        .B      CMP      r5,r3
        0x00001704:    d11b        ..      BNE      0x173e ; WriteRxDemodConfig + 74
        0x00001706:    18a5        ..      ADDS     r5,r4,r2
        0x00001708:    786c        lx      LDRB     r4,[r5,#1]
        0x0000170a:    784e        Nx      LDRB     r6,[r1,#1]
        0x0000170c:    42b4        .B      CMP      r4,r6
        0x0000170e:    d116        ..      BNE      0x173e ; WriteRxDemodConfig + 74
;;;211                _gS2S8Mode == RxDemodIndex[i].S2S8Mode)
        0x00001710:    78ac        .x      LDRB     r4,[r5,#2]
        0x00001712:    788e        .x      LDRB     r6,[r1,#2]
        0x00001714:    42b4        .B      CMP      r4,r6
        0x00001716:    d112        ..      BNE      0x173e ; WriteRxDemodConfig + 74
        0x00001718:    4e0c        .N      LDR      r6,[pc,#48] ; [0x174c] = 0x2064
;;;212            {
;;;213                for (int j = 0; j < 16; j++)
        0x0000171a:    2400        .$      MOVS     r4,#0
        0x0000171c:    3e90        .>      SUBS     r6,r6,#0x90
        0x0000171e:    78e8        .x      LDRB     r0,[r5,#3]
        0x00001720:    1982        ..      ADDS     r2,r0,r6
        0x00001722:    00e0        ..      LSLS     r0,r4,#3
        0x00001724:    1820         .      ADDS     r0,r4,r0
        0x00001726:    1c81        ..      ADDS     r1,r0,#2
        0x00001728:    5c52        R\      LDRB     r2,[r2,r1]
        0x0000172a:    1981        ..      ADDS     r1,r0,r6
        0x0000172c:    7a0b        .z      LDRB     r3,[r1,#8]
        0x0000172e:    7849        Ix      LDRB     r1,[r1,#1]
        0x00001730:    5c30        0\      LDRB     r0,[r6,r0]
        0x00001732:    f7fffe69    ..i.    BL       PAN216_WritePageRegBits ; 0x1408
        0x00001736:    1c64        d.      ADDS     r4,r4,#1
        0x00001738:    2c10        .,      CMP      r4,#0x10
        0x0000173a:    dbf0        ..      BLT      0x171e ; WriteRxDemodConfig + 42
;;;214                {
;;;215                    PAN216_WritePageRegBits(RxDemodTable[j].page, RxDemodTable[j].addr,
;;;216                                            RxDemodTable[j].cfg[RxDemodIndex[i].index],
;;;217                                            RxDemodTable[j].mask);
;;;218                }
;;;219                return;
;;;220            }
;;;221        }
;;;222    }
        0x0000173c:    bd70        p.      POP      {r4-r6,pc}
        0x0000173e:    1c40        @.      ADDS     r0,r0,#1
        0x00001740:    2810        .(      CMP      r0,#0x10
        0x00001742:    d3dc        ..      BCC      0x16fe ; WriteRxDemodConfig + 10
        0x00001744:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x00001746:    0000        ..      DCW    0
        0x00001748:    20000024    $..     DCD    536870948
        0x0000174c:    00002064    d ..    DCD    8292
    $t
    i.WriteTxDemodConfig
    WriteTxDemodConfig
;;; ..\..\..\..\radio\pan216_ext.c (141)
        0x00001750:    b570        p.      PUSH     {r4-r6,lr}
        0x00001752:    4c13        .L      LDR      r4,[pc,#76] ; [0x17a0] = 0x20000024
        0x00001754:    4913        .I      LDR      r1,[pc,#76] ; [0x17a4] = 0x1fb0
        0x00001756:    7823        #x      LDRB     r3,[r4,#0]
;;;142        for (int i = 0; i < sizeof(TxDemodIndex) / sizeof(TxDemodIndex[0]); i++)
        0x00001758:    2000        .       MOVS     r0,#0
;;;143        {
;;;144            if (_gChipMode == TxDemodIndex[i].ChipMode && _gDataRate == TxDemodIndex[i].DataRate)
        0x0000175a:    0042        B.      LSLS     r2,r0,#1
        0x0000175c:    1882        ..      ADDS     r2,r0,r2
        0x0000175e:    5c8d        .\      LDRB     r5,[r1,r2]
        0x00001760:    429d        .B      CMP      r5,r3
        0x00001762:    d118        ..      BNE      0x1796 ; WriteTxDemodConfig + 70
        0x00001764:    1852        R.      ADDS     r2,r2,r1
        0x00001766:    7852        Rx      LDRB     r2,[r2,#1]
        0x00001768:    7865        ex      LDRB     r5,[r4,#1]
        0x0000176a:    42aa        .B      CMP      r2,r5
        0x0000176c:    d113        ..      BNE      0x1796 ; WriteTxDemodConfig + 70
;;;145            {
;;;146                uint8_t index = TxDemodIndex[i].index;
        0x0000176e:    0042        B.      LSLS     r2,r0,#1
        0x00001770:    1880        ..      ADDS     r0,r0,r2
        0x00001772:    1840        @.      ADDS     r0,r0,r1
        0x00001774:    490b        .I      LDR      r1,[pc,#44] ; [0x17a4] = 0x1fb0
        0x00001776:    7880        .x      LDRB     r0,[r0,#2]
;;;147                PAN216_WritePageRegBits(TxDemodTable[0].page, TxDemodTable[0].addr,
        0x00001778:    3924        $9      SUBS     r1,r1,#0x24
        0x0000177a:    180c        ..      ADDS     r4,r1,r0
        0x0000177c:    78e2        .x      LDRB     r2,[r4,#3]
        0x0000177e:    231f        .#      MOVS     r3,#0x1f
        0x00001780:    2132        2!      MOVS     r1,#0x32
        0x00001782:    2001        .       MOVS     r0,#1
        0x00001784:    f7fffe40    ..@.    BL       PAN216_WritePageRegBits ; 0x1408
;;;148                                        TxDemodTable[0].config[index], TxDemodTable[0].mask);
;;;149                PAN216_WritePageRegBits(TxDemodTable[1].page, TxDemodTable[1].addr,
        0x00001788:    7d62        b}      LDRB     r2,[r4,#0x15]
        0x0000178a:    233f        ?#      MOVS     r3,#0x3f
        0x0000178c:    2133        3!      MOVS     r1,#0x33
        0x0000178e:    2001        .       MOVS     r0,#1
        0x00001790:    f7fffe3a    ..:.    BL       PAN216_WritePageRegBits ; 0x1408
;;;150                                        TxDemodTable[1].config[index], TxDemodTable[1].mask);
;;;151                return;
;;;152            }
;;;153        }
;;;154    }
        0x00001794:    bd70        p.      POP      {r4-r6,pc}
        0x00001796:    1c40        @.      ADDS     r0,r0,#1
        0x00001798:    280c        .(      CMP      r0,#0xc
        0x0000179a:    d3de        ..      BCC      0x175a ; WriteTxDemodConfig + 10
        0x0000179c:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0000179e:    0000        ..      DCW    0
        0x000017a0:    20000024    $..     DCD    536870948
        0x000017a4:    00001fb0    ....    DCD    8112
    $t
    i.__0printf$8
    __0printf$8
    __1printf$8
    __2printf
        0x000017a8:    b40f        ..      PUSH     {r0-r3}
        0x000017aa:    b510        ..      PUSH     {r4,lr}
        0x000017ac:    a903        ..      ADD      r1,sp,#0xc
        0x000017ae:    4b04        .K      LDR      r3,[pc,#16] ; [0x17c0] = 0x1c91
        0x000017b0:    4a04        .J      LDR      r2,[pc,#16] ; [0x17c4] = 0x20000084
        0x000017b2:    9802        ..      LDR      r0,[sp,#8]
        0x000017b4:    f000f832    ..2.    BL       _printf_core ; 0x181c
        0x000017b8:    bc10        ..      POP      {r4}
        0x000017ba:    bc08        ..      POP      {r3}
        0x000017bc:    b004        ..      ADD      sp,sp,#0x10
        0x000017be:    4718        .G      BX       r3
    $d
        0x000017c0:    00001c91    ....    DCD    7313
        0x000017c4:    20000084    ...     DCD    536871044
    $t
    i.__ARM_common_switch8
    __ARM_common_switch8
        0x000017c8:    b430        0.      PUSH     {r4,r5}
        0x000017ca:    4674        tF      MOV      r4,lr
        0x000017cc:    1e64        d.      SUBS     r4,r4,#1
        0x000017ce:    7825        %x      LDRB     r5,[r4,#0]
        0x000017d0:    1c64        d.      ADDS     r4,r4,#1
        0x000017d2:    42ab        .B      CMP      r3,r5
        0x000017d4:    d200        ..      BCS      0x17d8 ; __ARM_common_switch8 + 16
        0x000017d6:    461d        .F      MOV      r5,r3
        0x000017d8:    5d63        c]      LDRB     r3,[r4,r5]
        0x000017da:    005b        [.      LSLS     r3,r3,#1
        0x000017dc:    18e3        ..      ADDS     r3,r4,r3
        0x000017de:    bc30        0.      POP      {r4,r5}
        0x000017e0:    4718        .G      BX       r3
    i.__ctz
    __ctz
;;; ..\..\..\..\radio\pan216_reg.c
;;;11         for (int i = 0; i < 8; i++)
        0x000017e2:    2100        .!      MOVS     r1,#0
        0x000017e4:    2301        .#      MOVS     r3,#1
        0x000017e6:    461a        .F      MOV      r2,r3
        0x000017e8:    408a        .@      LSLS     r2,r2,r1
        0x000017ea:    4202        .B      TST      r2,r0
        0x000017ec:    d001        ..      BEQ      0x17f2 ; __ctz + 16
        0x000017ee:    b2c8        ..      UXTB     r0,r1
        0x000017f0:    4770        pG      BX       lr
        0x000017f2:    1c49        I.      ADDS     r1,r1,#1
        0x000017f4:    2908        .)      CMP      r1,#8
        0x000017f6:    dbf6        ..      BLT      0x17e6 ; __ctz + 4
;;;12         {
;;;13             if (val & (1 << i))
;;;14             {
;;;15                 return i;
;;;16             }
;;;17         }
;;;18     
;;;19         return 8;
        0x000017f8:    2008        .       MOVS     r0,#8
;;;20     }
        0x000017fa:    4770        pG      BX       lr
    i.__scatterload_copy
    __scatterload_copy
        0x000017fc:    e002        ..      B        0x1804 ; __scatterload_copy + 8
        0x000017fe:    c808        ..      LDM      r0!,{r3}
        0x00001800:    1f12        ..      SUBS     r2,r2,#4
        0x00001802:    c108        ..      STM      r1!,{r3}
        0x00001804:    2a00        .*      CMP      r2,#0
        0x00001806:    d1fa        ..      BNE      0x17fe ; __scatterload_copy + 2
        0x00001808:    4770        pG      BX       lr
    i.__scatterload_null
    __scatterload_null
        0x0000180a:    4770        pG      BX       lr
    i.__scatterload_zeroinit
    __scatterload_zeroinit
        0x0000180c:    2000        .       MOVS     r0,#0
        0x0000180e:    e001        ..      B        0x1814 ; __scatterload_zeroinit + 8
        0x00001810:    c101        ..      STM      r1!,{r0}
        0x00001812:    1f12        ..      SUBS     r2,r2,#4
        0x00001814:    2a00        .*      CMP      r2,#0
        0x00001816:    d1fb        ..      BNE      0x1810 ; __scatterload_zeroinit + 4
        0x00001818:    4770        pG      BX       lr
        0x0000181a:    0000        ..      MOVS     r0,r0
    i._printf_core
    _printf_core
        0x0000181c:    b5ff        ..      PUSH     {r0-r7,lr}
        0x0000181e:    b091        ..      SUB      sp,sp,#0x44
        0x00001820:    460f        .F      MOV      r7,r1
        0x00001822:    4605        .F      MOV      r5,r0
        0x00001824:    2600        .&      MOVS     r6,#0
        0x00001826:    e006        ..      B        0x1836 ; _printf_core + 26
        0x00001828:    2825        %(      CMP      r0,#0x25
        0x0000182a:    d00a        ..      BEQ      0x1842 ; _printf_core + 38
        0x0000182c:    9a14        ..      LDR      r2,[sp,#0x50]
        0x0000182e:    9913        ..      LDR      r1,[sp,#0x4c]
        0x00001830:    4790        .G      BLX      r2
        0x00001832:    1c6d        m.      ADDS     r5,r5,#1
        0x00001834:    1c76        v.      ADDS     r6,r6,#1
        0x00001836:    7828        (x      LDRB     r0,[r5,#0]
        0x00001838:    2800        .(      CMP      r0,#0
        0x0000183a:    d1f5        ..      BNE      0x1828 ; _printf_core + 12
        0x0000183c:    4630        0F      MOV      r0,r6
        0x0000183e:    b015        ..      ADD      sp,sp,#0x54
        0x00001840:    bdf0        ..      POP      {r4-r7,pc}
        0x00001842:    2400        .$      MOVS     r4,#0
        0x00001844:    9400        ..      STR      r4,[sp,#0]
        0x00001846:    2101        .!      MOVS     r1,#1
        0x00001848:    4af3        .J      LDR      r2,[pc,#972] ; [0x1c18] = 0x12809
        0x0000184a:    9402        ..      STR      r4,[sp,#8]
        0x0000184c:    e000        ..      B        0x1850 ; _printf_core + 52
        0x0000184e:    4304        .C      ORRS     r4,r4,r0
        0x00001850:    1c6d        m.      ADDS     r5,r5,#1
        0x00001852:    782b        +x      LDRB     r3,[r5,#0]
        0x00001854:    4608        .F      MOV      r0,r1
        0x00001856:    3b20         ;      SUBS     r3,r3,#0x20
        0x00001858:    4098        .@      LSLS     r0,r0,r3
        0x0000185a:    4210        .B      TST      r0,r2
        0x0000185c:    d1f7        ..      BNE      0x184e ; _printf_core + 50
        0x0000185e:    7828        (x      LDRB     r0,[r5,#0]
        0x00001860:    282a        *(      CMP      r0,#0x2a
        0x00001862:    d00e        ..      BEQ      0x1882 ; _printf_core + 102
        0x00001864:    2102        .!      MOVS     r1,#2
        0x00001866:    7828        (x      LDRB     r0,[r5,#0]
        0x00001868:    4602        .F      MOV      r2,r0
        0x0000186a:    3a30        0:      SUBS     r2,r2,#0x30
        0x0000186c:    2a09        .*      CMP      r2,#9
        0x0000186e:    d815        ..      BHI      0x189c ; _printf_core + 128
        0x00001870:    9a00        ..      LDR      r2,[sp,#0]
        0x00001872:    230a        .#      MOVS     r3,#0xa
        0x00001874:    435a        ZC      MULS     r2,r3,r2
        0x00001876:    3a30        0:      SUBS     r2,r2,#0x30
        0x00001878:    1880        ..      ADDS     r0,r0,r2
        0x0000187a:    430c        .C      ORRS     r4,r4,r1
        0x0000187c:    1c6d        m.      ADDS     r5,r5,#1
        0x0000187e:    9000        ..      STR      r0,[sp,#0]
        0x00001880:    e7f1        ..      B        0x1866 ; _printf_core + 74
        0x00001882:    cf01        ..      LDM      r7!,{r0}
        0x00001884:    9000        ..      STR      r0,[sp,#0]
        0x00001886:    2800        .(      CMP      r0,#0
        0x00001888:    da05        ..      BGE      0x1896 ; _printf_core + 122
        0x0000188a:    2001        .       MOVS     r0,#1
        0x0000188c:    0340        @.      LSLS     r0,r0,#13
        0x0000188e:    4304        .C      ORRS     r4,r4,r0
        0x00001890:    9800        ..      LDR      r0,[sp,#0]
        0x00001892:    4240        @B      RSBS     r0,r0,#0
        0x00001894:    9000        ..      STR      r0,[sp,#0]
        0x00001896:    2002        .       MOVS     r0,#2
        0x00001898:    4304        .C      ORRS     r4,r4,r0
        0x0000189a:    1c6d        m.      ADDS     r5,r5,#1
        0x0000189c:    7828        (x      LDRB     r0,[r5,#0]
        0x0000189e:    282e        .(      CMP      r0,#0x2e
        0x000018a0:    d115        ..      BNE      0x18ce ; _printf_core + 178
        0x000018a2:    2004        .       MOVS     r0,#4
        0x000018a4:    4304        .C      ORRS     r4,r4,r0
        0x000018a6:    7868        hx      LDRB     r0,[r5,#1]
        0x000018a8:    1c6d        m.      ADDS     r5,r5,#1
        0x000018aa:    282a        *(      CMP      r0,#0x2a
        0x000018ac:    d10a        ..      BNE      0x18c4 ; _printf_core + 168
        0x000018ae:    cf01        ..      LDM      r7!,{r0}
        0x000018b0:    1c6d        m.      ADDS     r5,r5,#1
        0x000018b2:    9002        ..      STR      r0,[sp,#8]
        0x000018b4:    e00b        ..      B        0x18ce ; _printf_core + 178
        0x000018b6:    9902        ..      LDR      r1,[sp,#8]
        0x000018b8:    220a        ."      MOVS     r2,#0xa
        0x000018ba:    4351        QC      MULS     r1,r2,r1
        0x000018bc:    3930        09      SUBS     r1,r1,#0x30
        0x000018be:    1840        @.      ADDS     r0,r0,r1
        0x000018c0:    1c6d        m.      ADDS     r5,r5,#1
        0x000018c2:    9002        ..      STR      r0,[sp,#8]
        0x000018c4:    7828        (x      LDRB     r0,[r5,#0]
        0x000018c6:    4601        .F      MOV      r1,r0
        0x000018c8:    3930        09      SUBS     r1,r1,#0x30
        0x000018ca:    2909        .)      CMP      r1,#9
        0x000018cc:    d9f3        ..      BLS      0x18b6 ; _printf_core + 154
        0x000018ce:    7828        (x      LDRB     r0,[r5,#0]
        0x000018d0:    286c        l(      CMP      r0,#0x6c
        0x000018d2:    d010        ..      BEQ      0x18f6 ; _printf_core + 218
        0x000018d4:    dc06        ..      BGT      0x18e4 ; _printf_core + 200
        0x000018d6:    284c        L(      CMP      r0,#0x4c
        0x000018d8:    d01a        ..      BEQ      0x1910 ; _printf_core + 244
        0x000018da:    2868        h(      CMP      r0,#0x68
        0x000018dc:    d00e        ..      BEQ      0x18fc ; _printf_core + 224
        0x000018de:    286a        j(      CMP      r0,#0x6a
        0x000018e0:    d117        ..      BNE      0x1912 ; _printf_core + 246
        0x000018e2:    e004        ..      B        0x18ee ; _printf_core + 210
        0x000018e4:    2874        t(      CMP      r0,#0x74
        0x000018e6:    d013        ..      BEQ      0x1910 ; _printf_core + 244
        0x000018e8:    287a        z(      CMP      r0,#0x7a
        0x000018ea:    d112        ..      BNE      0x1912 ; _printf_core + 246
        0x000018ec:    e010        ..      B        0x1910 ; _printf_core + 244
        0x000018ee:    2001        .       MOVS     r0,#1
        0x000018f0:    0540        @.      LSLS     r0,r0,#21
        0x000018f2:    4304        .C      ORRS     r4,r4,r0
        0x000018f4:    e00c        ..      B        0x1910 ; _printf_core + 244
        0x000018f6:    2101        .!      MOVS     r1,#1
        0x000018f8:    0509        ..      LSLS     r1,r1,#20
        0x000018fa:    e001        ..      B        0x1900 ; _printf_core + 228
        0x000018fc:    2103        .!      MOVS     r1,#3
        0x000018fe:    0509        ..      LSLS     r1,r1,#20
        0x00001900:    430c        .C      ORRS     r4,r4,r1
        0x00001902:    7869        ix      LDRB     r1,[r5,#1]
        0x00001904:    4281        .B      CMP      r1,r0
        0x00001906:    d103        ..      BNE      0x1910 ; _printf_core + 244
        0x00001908:    2001        .       MOVS     r0,#1
        0x0000190a:    0500        ..      LSLS     r0,r0,#20
        0x0000190c:    1824        $.      ADDS     r4,r4,r0
        0x0000190e:    1c6d        m.      ADDS     r5,r5,#1
        0x00001910:    1c6d        m.      ADDS     r5,r5,#1
        0x00001912:    7828        (x      LDRB     r0,[r5,#0]
        0x00001914:    9003        ..      STR      r0,[sp,#0xc]
        0x00001916:    286e        n(      CMP      r0,#0x6e
        0x00001918:    d01e        ..      BEQ      0x1958 ; _printf_core + 316
        0x0000191a:    dc0c        ..      BGT      0x1936 ; _printf_core + 282
        0x0000191c:    2863        c(      CMP      r0,#0x63
        0x0000191e:    d031        1.      BEQ      0x1984 ; _printf_core + 360
        0x00001920:    dc04        ..      BGT      0x192c ; _printf_core + 272
        0x00001922:    2800        .(      CMP      r0,#0
        0x00001924:    d08a        ..      BEQ      0x183c ; _printf_core + 32
        0x00001926:    2858        X(      CMP      r0,#0x58
        0x00001928:    d111        ..      BNE      0x194e ; _printf_core + 306
        0x0000192a:    e0b2        ..      B        0x1a92 ; _printf_core + 630
        0x0000192c:    2864        d(      CMP      r0,#0x64
        0x0000192e:    d07b        {.      BEQ      0x1a28 ; _printf_core + 524
        0x00001930:    2869        i(      CMP      r0,#0x69
        0x00001932:    d10c        ..      BNE      0x194e ; _printf_core + 306
        0x00001934:    e078        x.      B        0x1a28 ; _printf_core + 524
        0x00001936:    2873        s(      CMP      r0,#0x73
        0x00001938:    d02d        -.      BEQ      0x1996 ; _printf_core + 378
        0x0000193a:    dc04        ..      BGT      0x1946 ; _printf_core + 298
        0x0000193c:    286f        o(      CMP      r0,#0x6f
        0x0000193e:    d070        p.      BEQ      0x1a22 ; _printf_core + 518
        0x00001940:    2870        p(      CMP      r0,#0x70
        0x00001942:    d104        ..      BNE      0x194e ; _printf_core + 306
        0x00001944:    e0a7        ..      B        0x1a96 ; _printf_core + 634
        0x00001946:    2875        u(      CMP      r0,#0x75
        0x00001948:    d06c        l.      BEQ      0x1a24 ; _printf_core + 520
        0x0000194a:    2878        x(      CMP      r0,#0x78
        0x0000194c:    d06b        k.      BEQ      0x1a26 ; _printf_core + 522
        0x0000194e:    9a14        ..      LDR      r2,[sp,#0x50]
        0x00001950:    9913        ..      LDR      r1,[sp,#0x4c]
        0x00001952:    4790        .G      BLX      r2
        0x00001954:    1c76        v.      ADDS     r6,r6,#1
        0x00001956:    e062        b.      B        0x1a1e ; _printf_core + 514
        0x00001958:    0260        `.      LSLS     r0,r4,#9
        0x0000195a:    0f40        @.      LSRS     r0,r0,#29
        0x0000195c:    2802        .(      CMP      r0,#2
        0x0000195e:    d007        ..      BEQ      0x1970 ; _printf_core + 340
        0x00001960:    2803        .(      CMP      r0,#3
        0x00001962:    d00a        ..      BEQ      0x197a ; _printf_core + 350
        0x00001964:    2804        .(      CMP      r0,#4
        0x00001966:    6838        8h      LDR      r0,[r7,#0]
        0x00001968:    d00a        ..      BEQ      0x1980 ; _printf_core + 356
        0x0000196a:    6006        .`      STR      r6,[r0,#0]
        0x0000196c:    1d3f        ?.      ADDS     r7,r7,#4
        0x0000196e:    e056        V.      B        0x1a1e ; _printf_core + 514
        0x00001970:    6838        8h      LDR      r0,[r7,#0]
        0x00001972:    17f1        ..      ASRS     r1,r6,#31
        0x00001974:    6006        .`      STR      r6,[r0,#0]
        0x00001976:    6041        A`      STR      r1,[r0,#4]
        0x00001978:    e7f8        ..      B        0x196c ; _printf_core + 336
        0x0000197a:    6838        8h      LDR      r0,[r7,#0]
        0x0000197c:    8006        ..      STRH     r6,[r0,#0]
        0x0000197e:    e7f5        ..      B        0x196c ; _printf_core + 336
        0x00001980:    7006        .p      STRB     r6,[r0,#0]
        0x00001982:    e7f3        ..      B        0x196c ; _printf_core + 336
        0x00001984:    7838        8x      LDRB     r0,[r7,#0]
        0x00001986:    4669        iF      MOV      r1,sp
        0x00001988:    7408        .t      STRB     r0,[r1,#0x10]
        0x0000198a:    2000        .       MOVS     r0,#0
        0x0000198c:    7448        Ht      STRB     r0,[r1,#0x11]
        0x0000198e:    a804        ..      ADD      r0,sp,#0x10
        0x00001990:    9003        ..      STR      r0,[sp,#0xc]
        0x00001992:    2001        .       MOVS     r0,#1
        0x00001994:    e003        ..      B        0x199e ; _printf_core + 386
        0x00001996:    6838        8h      LDR      r0,[r7,#0]
        0x00001998:    9003        ..      STR      r0,[sp,#0xc]
        0x0000199a:    2000        .       MOVS     r0,#0
        0x0000199c:    43c0        .C      MVNS     r0,r0
        0x0000199e:    1d3f        ?.      ADDS     r7,r7,#4
        0x000019a0:    0761        a.      LSLS     r1,r4,#29
        0x000019a2:    d50f        ..      BPL      0x19c4 ; _printf_core + 424
        0x000019a4:    2100        .!      MOVS     r1,#0
        0x000019a6:    e001        ..      B        0x19ac ; _printf_core + 400
        0x000019a8:    9901        ..      LDR      r1,[sp,#4]
        0x000019aa:    1c49        I.      ADDS     r1,r1,#1
        0x000019ac:    9a02        ..      LDR      r2,[sp,#8]
        0x000019ae:    9101        ..      STR      r1,[sp,#4]
        0x000019b0:    4291        .B      CMP      r1,r2
        0x000019b2:    da13        ..      BGE      0x19dc ; _printf_core + 448
        0x000019b4:    4281        .B      CMP      r1,r0
        0x000019b6:    dbf7        ..      BLT      0x19a8 ; _printf_core + 396
        0x000019b8:    9a01        ..      LDR      r2,[sp,#4]
        0x000019ba:    9903        ..      LDR      r1,[sp,#0xc]
        0x000019bc:    5c89        .\      LDRB     r1,[r1,r2]
        0x000019be:    2900        .)      CMP      r1,#0
        0x000019c0:    d1f2        ..      BNE      0x19a8 ; _printf_core + 396
        0x000019c2:    e00b        ..      B        0x19dc ; _printf_core + 448
        0x000019c4:    2100        .!      MOVS     r1,#0
        0x000019c6:    e001        ..      B        0x19cc ; _printf_core + 432
        0x000019c8:    9901        ..      LDR      r1,[sp,#4]
        0x000019ca:    1c49        I.      ADDS     r1,r1,#1
        0x000019cc:    9101        ..      STR      r1,[sp,#4]
        0x000019ce:    4281        .B      CMP      r1,r0
        0x000019d0:    dbfa        ..      BLT      0x19c8 ; _printf_core + 428
        0x000019d2:    9a01        ..      LDR      r2,[sp,#4]
        0x000019d4:    9903        ..      LDR      r1,[sp,#0xc]
        0x000019d6:    5c89        .\      LDRB     r1,[r1,r2]
        0x000019d8:    2900        .)      CMP      r1,#0
        0x000019da:    d1f5        ..      BNE      0x19c8 ; _printf_core + 428
        0x000019dc:    9901        ..      LDR      r1,[sp,#4]
        0x000019de:    9800        ..      LDR      r0,[sp,#0]
        0x000019e0:    9a13        ..      LDR      r2,[sp,#0x4c]
        0x000019e2:    1a40        @.      SUBS     r0,r0,r1
        0x000019e4:    9000        ..      STR      r0,[sp,#0]
        0x000019e6:    4621        !F      MOV      r1,r4
        0x000019e8:    9b14        ..      LDR      r3,[sp,#0x50]
        0x000019ea:    f000f93b    ..;.    BL       _printf_pre_padding ; 0x1c64
        0x000019ee:    9901        ..      LDR      r1,[sp,#4]
        0x000019f0:    1980        ..      ADDS     r0,r0,r6
        0x000019f2:    1846        F.      ADDS     r6,r0,r1
        0x000019f4:    e007        ..      B        0x1a06 ; _printf_core + 490
        0x000019f6:    9803        ..      LDR      r0,[sp,#0xc]
        0x000019f8:    9903        ..      LDR      r1,[sp,#0xc]
        0x000019fa:    7800        .x      LDRB     r0,[r0,#0]
        0x000019fc:    1c49        I.      ADDS     r1,r1,#1
        0x000019fe:    9103        ..      STR      r1,[sp,#0xc]
        0x00001a00:    9a14        ..      LDR      r2,[sp,#0x50]
        0x00001a02:    9913        ..      LDR      r1,[sp,#0x4c]
        0x00001a04:    4790        .G      BLX      r2
        0x00001a06:    9801        ..      LDR      r0,[sp,#4]
        0x00001a08:    1e40        @.      SUBS     r0,r0,#1
        0x00001a0a:    9001        ..      STR      r0,[sp,#4]
        0x00001a0c:    1c40        @.      ADDS     r0,r0,#1
        0x00001a0e:    d1f2        ..      BNE      0x19f6 ; _printf_core + 474
        0x00001a10:    4621        !F      MOV      r1,r4
        0x00001a12:    9b14        ..      LDR      r3,[sp,#0x50]
        0x00001a14:    9a13        ..      LDR      r2,[sp,#0x4c]
        0x00001a16:    9800        ..      LDR      r0,[sp,#0]
        0x00001a18:    f000f914    ....    BL       _printf_post_padding ; 0x1c44
        0x00001a1c:    1986        ..      ADDS     r6,r0,r6
        0x00001a1e:    1c6d        m.      ADDS     r5,r5,#1
        0x00001a20:    e709        ..      B        0x1836 ; _printf_core + 26
        0x00001a22:    e041        A.      B        0x1aa8 ; _printf_core + 652
        0x00001a24:    e033        3.      B        0x1a8e ; _printf_core + 626
        0x00001a26:    e034        4.      B        0x1a92 ; _printf_core + 630
        0x00001a28:    200a        .       MOVS     r0,#0xa
        0x00001a2a:    2100        .!      MOVS     r1,#0
        0x00001a2c:    9004        ..      STR      r0,[sp,#0x10]
        0x00001a2e:    9105        ..      STR      r1,[sp,#0x14]
        0x00001a30:    0260        `.      LSLS     r0,r4,#9
        0x00001a32:    0f41        A.      LSRS     r1,r0,#29
        0x00001a34:    2902        .)      CMP      r1,#2
        0x00001a36:    d005        ..      BEQ      0x1a44 ; _printf_core + 552
        0x00001a38:    cf01        ..      LDM      r7!,{r0}
        0x00001a3a:    17c2        ..      ASRS     r2,r0,#31
        0x00001a3c:    4694        .F      MOV      r12,r2
        0x00001a3e:    2903        .)      CMP      r1,#3
        0x00001a40:    d005        ..      BEQ      0x1a4e ; _printf_core + 562
        0x00001a42:    e007        ..      B        0x1a54 ; _printf_core + 568
        0x00001a44:    1dff        ..      ADDS     r7,r7,#7
        0x00001a46:    08ff        ..      LSRS     r7,r7,#3
        0x00001a48:    00ff        ..      LSLS     r7,r7,#3
        0x00001a4a:    cf03        ..      LDM      r7!,{r0,r1}
        0x00001a4c:    e006        ..      B        0x1a5c ; _printf_core + 576
        0x00001a4e:    b200        ..      SXTH     r0,r0
        0x00001a50:    17c2        ..      ASRS     r2,r0,#31
        0x00001a52:    4694        .F      MOV      r12,r2
        0x00001a54:    2904        .)      CMP      r1,#4
        0x00001a56:    d102        ..      BNE      0x1a5e ; _printf_core + 578
        0x00001a58:    b240        @.      SXTB     r0,r0
        0x00001a5a:    17c1        ..      ASRS     r1,r0,#31
        0x00001a5c:    468c        .F      MOV      r12,r1
        0x00001a5e:    2200        ."      MOVS     r2,#0
        0x00001a60:    4661        aF      MOV      r1,r12
        0x00001a62:    4594        .E      CMP      r12,r2
        0x00001a64:    da06        ..      BGE      0x1a74 ; _printf_core + 600
        0x00001a66:    460a        .F      MOV      r2,r1
        0x00001a68:    2100        .!      MOVS     r1,#0
        0x00001a6a:    4240        @B      RSBS     r0,r0,#0
        0x00001a6c:    4191        .A      SBCS     r1,r1,r2
        0x00001a6e:    468c        .F      MOV      r12,r1
        0x00001a70:    212d        -!      MOVS     r1,#0x2d
        0x00001a72:    e002        ..      B        0x1a7a ; _printf_core + 606
        0x00001a74:    0521        !.      LSLS     r1,r4,#20
        0x00001a76:    d504        ..      BPL      0x1a82 ; _printf_core + 614
        0x00001a78:    212b        +!      MOVS     r1,#0x2b
        0x00001a7a:    466a        jF      MOV      r2,sp
        0x00001a7c:    7611        .v      STRB     r1,[r2,#0x18]
        0x00001a7e:    2101        .!      MOVS     r1,#1
        0x00001a80:    e003        ..      B        0x1a8a ; _printf_core + 622
        0x00001a82:    07e1        ..      LSLS     r1,r4,#31
        0x00001a84:    d001        ..      BEQ      0x1a8a ; _printf_core + 622
        0x00001a86:    2120         !      MOVS     r1,#0x20
        0x00001a88:    e7f7        ..      B        0x1a7a ; _printf_core + 606
        0x00001a8a:    9101        ..      STR      r1,[sp,#4]
        0x00001a8c:    e054        T.      B        0x1b38 ; _printf_core + 796
        0x00001a8e:    200a        .       MOVS     r0,#0xa
        0x00001a90:    e00b        ..      B        0x1aaa ; _printf_core + 654
        0x00001a92:    2010        .       MOVS     r0,#0x10
        0x00001a94:    e009        ..      B        0x1aaa ; _printf_core + 654
        0x00001a96:    2010        .       MOVS     r0,#0x10
        0x00001a98:    9004        ..      STR      r0,[sp,#0x10]
        0x00001a9a:    2100        .!      MOVS     r1,#0
        0x00001a9c:    2004        .       MOVS     r0,#4
        0x00001a9e:    4304        .C      ORRS     r4,r4,r0
        0x00001aa0:    2008        .       MOVS     r0,#8
        0x00001aa2:    9105        ..      STR      r1,[sp,#0x14]
        0x00001aa4:    9002        ..      STR      r0,[sp,#8]
        0x00001aa6:    e003        ..      B        0x1ab0 ; _printf_core + 660
        0x00001aa8:    2008        .       MOVS     r0,#8
        0x00001aaa:    2100        .!      MOVS     r1,#0
        0x00001aac:    9105        ..      STR      r1,[sp,#0x14]
        0x00001aae:    9004        ..      STR      r0,[sp,#0x10]
        0x00001ab0:    0260        `.      LSLS     r0,r4,#9
        0x00001ab2:    0f41        A.      LSRS     r1,r0,#29
        0x00001ab4:    2902        .)      CMP      r1,#2
        0x00001ab6:    d005        ..      BEQ      0x1ac4 ; _printf_core + 680
        0x00001ab8:    cf01        ..      LDM      r7!,{r0}
        0x00001aba:    2200        ."      MOVS     r2,#0
        0x00001abc:    4694        .F      MOV      r12,r2
        0x00001abe:    2903        .)      CMP      r1,#3
        0x00001ac0:    d006        ..      BEQ      0x1ad0 ; _printf_core + 692
        0x00001ac2:    e006        ..      B        0x1ad2 ; _printf_core + 694
        0x00001ac4:    1dff        ..      ADDS     r7,r7,#7
        0x00001ac6:    08ff        ..      LSRS     r7,r7,#3
        0x00001ac8:    00ff        ..      LSLS     r7,r7,#3
        0x00001aca:    cf03        ..      LDM      r7!,{r0,r1}
        0x00001acc:    468c        .F      MOV      r12,r1
        0x00001ace:    e003        ..      B        0x1ad8 ; _printf_core + 700
        0x00001ad0:    b280        ..      UXTH     r0,r0
        0x00001ad2:    2904        .)      CMP      r1,#4
        0x00001ad4:    d100        ..      BNE      0x1ad8 ; _printf_core + 700
        0x00001ad6:    b2c0        ..      UXTB     r0,r0
        0x00001ad8:    2100        .!      MOVS     r1,#0
        0x00001ada:    9101        ..      STR      r1,[sp,#4]
        0x00001adc:    0721        !.      LSLS     r1,r4,#28
        0x00001ade:    d52b        +.      BPL      0x1b38 ; _printf_core + 796
        0x00001ae0:    9903        ..      LDR      r1,[sp,#0xc]
        0x00001ae2:    2970        p)      CMP      r1,#0x70
        0x00001ae4:    d006        ..      BEQ      0x1af4 ; _printf_core + 728
        0x00001ae6:    9a04        ..      LDR      r2,[sp,#0x10]
        0x00001ae8:    2110        .!      MOVS     r1,#0x10
        0x00001aea:    9b05        ..      LDR      r3,[sp,#0x14]
        0x00001aec:    404a        J@      EORS     r2,r2,r1
        0x00001aee:    431a        .C      ORRS     r2,r2,r3
        0x00001af0:    d005        ..      BEQ      0x1afe ; _printf_core + 738
        0x00001af2:    e00e        ..      B        0x1b12 ; _printf_core + 758
        0x00001af4:    2140        @!      MOVS     r1,#0x40
        0x00001af6:    466a        jF      MOV      r2,sp
        0x00001af8:    7611        .v      STRB     r1,[r2,#0x18]
        0x00001afa:    2101        .!      MOVS     r1,#1
        0x00001afc:    e008        ..      B        0x1b10 ; _printf_core + 756
        0x00001afe:    4661        aF      MOV      r1,r12
        0x00001b00:    4301        .C      ORRS     r1,r1,r0
        0x00001b02:    d006        ..      BEQ      0x1b12 ; _printf_core + 758
        0x00001b04:    2130        0!      MOVS     r1,#0x30
        0x00001b06:    466a        jF      MOV      r2,sp
        0x00001b08:    7611        .v      STRB     r1,[r2,#0x18]
        0x00001b0a:    9903        ..      LDR      r1,[sp,#0xc]
        0x00001b0c:    7651        Qv      STRB     r1,[r2,#0x19]
        0x00001b0e:    2102        .!      MOVS     r1,#2
        0x00001b10:    9101        ..      STR      r1,[sp,#4]
        0x00001b12:    9a04        ..      LDR      r2,[sp,#0x10]
        0x00001b14:    2108        .!      MOVS     r1,#8
        0x00001b16:    9b05        ..      LDR      r3,[sp,#0x14]
        0x00001b18:    404a        J@      EORS     r2,r2,r1
        0x00001b1a:    431a        .C      ORRS     r2,r2,r3
        0x00001b1c:    d10c        ..      BNE      0x1b38 ; _printf_core + 796
        0x00001b1e:    4661        aF      MOV      r1,r12
        0x00001b20:    4301        .C      ORRS     r1,r1,r0
        0x00001b22:    d101        ..      BNE      0x1b28 ; _printf_core + 780
        0x00001b24:    0761        a.      LSLS     r1,r4,#29
        0x00001b26:    d507        ..      BPL      0x1b38 ; _printf_core + 796
        0x00001b28:    2130        0!      MOVS     r1,#0x30
        0x00001b2a:    466a        jF      MOV      r2,sp
        0x00001b2c:    7611        .v      STRB     r1,[r2,#0x18]
        0x00001b2e:    2101        .!      MOVS     r1,#1
        0x00001b30:    9101        ..      STR      r1,[sp,#4]
        0x00001b32:    9902        ..      LDR      r1,[sp,#8]
        0x00001b34:    1e49        I.      SUBS     r1,r1,#1
        0x00001b36:    9102        ..      STR      r1,[sp,#8]
        0x00001b38:    9903        ..      LDR      r1,[sp,#0xc]
        0x00001b3a:    2958        X)      CMP      r1,#0x58
        0x00001b3c:    d004        ..      BEQ      0x1b48 ; _printf_core + 812
        0x00001b3e:    a137        7.      ADR      r1,{pc}+0xde ; 0x1c1c
        0x00001b40:    9103        ..      STR      r1,[sp,#0xc]
        0x00001b42:    a90f        ..      ADD      r1,sp,#0x3c
        0x00001b44:    910f        ..      STR      r1,[sp,#0x3c]
        0x00001b46:    e00d        ..      B        0x1b64 ; _printf_core + 840
        0x00001b48:    a139        9.      ADR      r1,{pc}+0xe8 ; 0x1c30
        0x00001b4a:    e7f9        ..      B        0x1b40 ; _printf_core + 804
        0x00001b4c:    4661        aF      MOV      r1,r12
        0x00001b4e:    9b05        ..      LDR      r3,[sp,#0x14]
        0x00001b50:    9a04        ..      LDR      r2,[sp,#0x10]
        0x00001b52:    f7fefaf1    ....    BL       __aeabi_uldivmod ; 0x138
        0x00001b56:    9b03        ..      LDR      r3,[sp,#0xc]
        0x00001b58:    468c        .F      MOV      r12,r1
        0x00001b5a:    5c9b        .\      LDRB     r3,[r3,r2]
        0x00001b5c:    9a0f        ..      LDR      r2,[sp,#0x3c]
        0x00001b5e:    1e52        R.      SUBS     r2,r2,#1
        0x00001b60:    920f        ..      STR      r2,[sp,#0x3c]
        0x00001b62:    7013        .p      STRB     r3,[r2,#0]
        0x00001b64:    4661        aF      MOV      r1,r12
        0x00001b66:    4301        .C      ORRS     r1,r1,r0
        0x00001b68:    d1f0        ..      BNE      0x1b4c ; _printf_core + 816
        0x00001b6a:    980f        ..      LDR      r0,[sp,#0x3c]
        0x00001b6c:    a907        ..      ADD      r1,sp,#0x1c
        0x00001b6e:    1a08        ..      SUBS     r0,r1,r0
        0x00001b70:    3020         0      ADDS     r0,r0,#0x20
        0x00001b72:    9003        ..      STR      r0,[sp,#0xc]
        0x00001b74:    0760        `.      LSLS     r0,r4,#29
        0x00001b76:    d504        ..      BPL      0x1b82 ; _printf_core + 870
        0x00001b78:    2001        .       MOVS     r0,#1
        0x00001b7a:    0400        ..      LSLS     r0,r0,#16
        0x00001b7c:    4384        .C      BICS     r4,r4,r0
        0x00001b7e:    9802        ..      LDR      r0,[sp,#8]
        0x00001b80:    e001        ..      B        0x1b86 ; _printf_core + 874
        0x00001b82:    2001        .       MOVS     r0,#1
        0x00001b84:    9002        ..      STR      r0,[sp,#8]
        0x00001b86:    9903        ..      LDR      r1,[sp,#0xc]
        0x00001b88:    4288        .B      CMP      r0,r1
        0x00001b8a:    dd01        ..      BLE      0x1b90 ; _printf_core + 884
        0x00001b8c:    1a40        @.      SUBS     r0,r0,r1
        0x00001b8e:    e000        ..      B        0x1b92 ; _printf_core + 886
        0x00001b90:    2000        .       MOVS     r0,#0
        0x00001b92:    1841        A.      ADDS     r1,r0,r1
        0x00001b94:    9002        ..      STR      r0,[sp,#8]
        0x00001b96:    9801        ..      LDR      r0,[sp,#4]
        0x00001b98:    1809        ..      ADDS     r1,r1,r0
        0x00001b9a:    9800        ..      LDR      r0,[sp,#0]
        0x00001b9c:    1a40        @.      SUBS     r0,r0,r1
        0x00001b9e:    9000        ..      STR      r0,[sp,#0]
        0x00001ba0:    03e0        ..      LSLS     r0,r4,#15
        0x00001ba2:    d406        ..      BMI      0x1bb2 ; _printf_core + 918
        0x00001ba4:    4621        !F      MOV      r1,r4
        0x00001ba6:    9b14        ..      LDR      r3,[sp,#0x50]
        0x00001ba8:    9a13        ..      LDR      r2,[sp,#0x4c]
        0x00001baa:    9800        ..      LDR      r0,[sp,#0]
        0x00001bac:    f000f85a    ..Z.    BL       _printf_pre_padding ; 0x1c64
        0x00001bb0:    1986        ..      ADDS     r6,r0,r6
        0x00001bb2:    2000        .       MOVS     r0,#0
        0x00001bb4:    9004        ..      STR      r0,[sp,#0x10]
        0x00001bb6:    e008        ..      B        0x1bca ; _printf_core + 942
        0x00001bb8:    a906        ..      ADD      r1,sp,#0x18
        0x00001bba:    5c08        .\      LDRB     r0,[r1,r0]
        0x00001bbc:    9a14        ..      LDR      r2,[sp,#0x50]
        0x00001bbe:    9913        ..      LDR      r1,[sp,#0x4c]
        0x00001bc0:    4790        .G      BLX      r2
        0x00001bc2:    9804        ..      LDR      r0,[sp,#0x10]
        0x00001bc4:    1c40        @.      ADDS     r0,r0,#1
        0x00001bc6:    1c76        v.      ADDS     r6,r6,#1
        0x00001bc8:    9004        ..      STR      r0,[sp,#0x10]
        0x00001bca:    9901        ..      LDR      r1,[sp,#4]
        0x00001bcc:    4288        .B      CMP      r0,r1
        0x00001bce:    dbf3        ..      BLT      0x1bb8 ; _printf_core + 924
        0x00001bd0:    03e0        ..      LSLS     r0,r4,#15
        0x00001bd2:    d50c        ..      BPL      0x1bee ; _printf_core + 978
        0x00001bd4:    4621        !F      MOV      r1,r4
        0x00001bd6:    9b14        ..      LDR      r3,[sp,#0x50]
        0x00001bd8:    9a13        ..      LDR      r2,[sp,#0x4c]
        0x00001bda:    9800        ..      LDR      r0,[sp,#0]
        0x00001bdc:    f000f842    ..B.    BL       _printf_pre_padding ; 0x1c64
        0x00001be0:    1986        ..      ADDS     r6,r0,r6
        0x00001be2:    e004        ..      B        0x1bee ; _printf_core + 978
        0x00001be4:    9a14        ..      LDR      r2,[sp,#0x50]
        0x00001be6:    2030        0       MOVS     r0,#0x30
        0x00001be8:    9913        ..      LDR      r1,[sp,#0x4c]
        0x00001bea:    4790        .G      BLX      r2
        0x00001bec:    1c76        v.      ADDS     r6,r6,#1
        0x00001bee:    9902        ..      LDR      r1,[sp,#8]
        0x00001bf0:    1e48        H.      SUBS     r0,r1,#1
        0x00001bf2:    9002        ..      STR      r0,[sp,#8]
        0x00001bf4:    2900        .)      CMP      r1,#0
        0x00001bf6:    dcf5        ..      BGT      0x1be4 ; _printf_core + 968
        0x00001bf8:    e008        ..      B        0x1c0c ; _printf_core + 1008
        0x00001bfa:    980f        ..      LDR      r0,[sp,#0x3c]
        0x00001bfc:    990f        ..      LDR      r1,[sp,#0x3c]
        0x00001bfe:    7800        .x      LDRB     r0,[r0,#0]
        0x00001c00:    1c49        I.      ADDS     r1,r1,#1
        0x00001c02:    910f        ..      STR      r1,[sp,#0x3c]
        0x00001c04:    9a14        ..      LDR      r2,[sp,#0x50]
        0x00001c06:    9913        ..      LDR      r1,[sp,#0x4c]
        0x00001c08:    4790        .G      BLX      r2
        0x00001c0a:    1c76        v.      ADDS     r6,r6,#1
        0x00001c0c:    9903        ..      LDR      r1,[sp,#0xc]
        0x00001c0e:    1e48        H.      SUBS     r0,r1,#1
        0x00001c10:    9003        ..      STR      r0,[sp,#0xc]
        0x00001c12:    2900        .)      CMP      r1,#0
        0x00001c14:    dcf1        ..      BGT      0x1bfa ; _printf_core + 990
        0x00001c16:    e6fb        ..      B        0x1a10 ; _printf_core + 500
    $d
        0x00001c18:    00012809    .(..    DCD    75785
        0x00001c1c:    33323130    0123    DCD    858927408
        0x00001c20:    37363534    4567    DCD    926299444
        0x00001c24:    62613938    89ab    DCD    1650538808
        0x00001c28:    66656463    cdef    DCD    1717920867
        0x00001c2c:    00000000    ....    DCD    0
        0x00001c30:    33323130    0123    DCD    858927408
        0x00001c34:    37363534    4567    DCD    926299444
        0x00001c38:    42413938    89AB    DCD    1111570744
        0x00001c3c:    46454443    CDEF    DCD    1178944579
        0x00001c40:    00000000    ....    DCD    0
    $t
    i._printf_post_padding
    _printf_post_padding
        0x00001c44:    b5f8        ..      PUSH     {r3-r7,lr}
        0x00001c46:    4604        .F      MOV      r4,r0
        0x00001c48:    2500        .%      MOVS     r5,#0
        0x00001c4a:    461e        .F      MOV      r6,r3
        0x00001c4c:    4617        .F      MOV      r7,r2
        0x00001c4e:    0488        ..      LSLS     r0,r1,#18
        0x00001c50:    d404        ..      BMI      0x1c5c ; _printf_post_padding + 24
        0x00001c52:    e005        ..      B        0x1c60 ; _printf_post_padding + 28
        0x00001c54:    4639        9F      MOV      r1,r7
        0x00001c56:    2020                MOVS     r0,#0x20
        0x00001c58:    47b0        .G      BLX      r6
        0x00001c5a:    1c6d        m.      ADDS     r5,r5,#1
        0x00001c5c:    1e64        d.      SUBS     r4,r4,#1
        0x00001c5e:    d5f9        ..      BPL      0x1c54 ; _printf_post_padding + 16
        0x00001c60:    4628        (F      MOV      r0,r5
        0x00001c62:    bdf8        ..      POP      {r3-r7,pc}
    i._printf_pre_padding
    _printf_pre_padding
        0x00001c64:    b5ff        ..      PUSH     {r0-r7,lr}
        0x00001c66:    4604        .F      MOV      r4,r0
        0x00001c68:    2500        .%      MOVS     r5,#0
        0x00001c6a:    b081        ..      SUB      sp,sp,#4
        0x00001c6c:    461e        .F      MOV      r6,r3
        0x00001c6e:    03c8        ..      LSLS     r0,r1,#15
        0x00001c70:    d501        ..      BPL      0x1c76 ; _printf_pre_padding + 18
        0x00001c72:    2730        0'      MOVS     r7,#0x30
        0x00001c74:    e000        ..      B        0x1c78 ; _printf_pre_padding + 20
        0x00001c76:    2720         '      MOVS     r7,#0x20
        0x00001c78:    0488        ..      LSLS     r0,r1,#18
        0x00001c7a:    d504        ..      BPL      0x1c86 ; _printf_pre_padding + 34
        0x00001c7c:    e005        ..      B        0x1c8a ; _printf_pre_padding + 38
        0x00001c7e:    4638        8F      MOV      r0,r7
        0x00001c80:    9903        ..      LDR      r1,[sp,#0xc]
        0x00001c82:    47b0        .G      BLX      r6
        0x00001c84:    1c6d        m.      ADDS     r5,r5,#1
        0x00001c86:    1e64        d.      SUBS     r4,r4,#1
        0x00001c88:    d5f9        ..      BPL      0x1c7e ; _printf_pre_padding + 26
        0x00001c8a:    4628        (F      MOV      r0,r5
        0x00001c8c:    b005        ..      ADD      sp,sp,#0x14
        0x00001c8e:    bdf0        ..      POP      {r4-r7,pc}
    i.fputc
    fputc
;;; .\..\..\..\..\pan108\device\Source\pan_retarget.c
;;;139    {
        0x00001c90:    b510        ..      PUSH     {r4,lr}
        0x00001c92:    4604        .F      MOV      r4,r0
;;;140        SendChar(ch);
        0x00001c94:    f7fffc6c    ..l.    BL       SendChar ; 0x1570
;;;141        return ch;
        0x00001c98:    4620         F      MOV      r0,r4
;;;142    }
        0x00001c9a:    bd10        ..      POP      {r4,pc}
    i.main
    main
;;; .\..\src\main.c
;;;50         BSP_ClockInit();
        0x00001c9c:    f7fefb34    ..4.    BL       BSP_ClockInit ; 0x308
;;;51         BSP_UartInit();
        0x00001ca0:    f7fefb96    ....    BL       BSP_UartInit ; 0x3d0
;;;52         BSP_GpioInit();
        0x00001ca4:    f7fefb7c    ..|.    BL       BSP_GpioInit ; 0x3a0
;;;53         SYS_TEST("CPU @ %dHz\n", SystemCoreClock);
        0x00001ca8:    4828        (H      LDR      r0,[pc,#160] ; [0x1d4c] = 0x20000000
        0x00001caa:    6801        .h      LDR      r1,[r0,#0]
        0x00001cac:    a028        (.      ADR      r0,{pc}+0xa4 ; 0x1d50
        0x00001cae:    f7fffd7b    ..{.    BL       __0printf$8 ; 0x17a8
;;;54     
;;;55     #if (INTERFACE_MODE == USE_SPI_3LINE)
;;;56         SYS_TEST("SPI-3LINE\n");
;;;57     #elif (INTERFACE_MODE == USE_I2C)
;;;58         SYS_TEST("IIC\n");
;;;59     #endif
;;;60     #if INTERFACE_MODE == USE_SPI_4LINE
;;;61         SYS_TEST("SPI-4LINE\n");
        0x00001cb2:    a02a        *.      ADR      r0,{pc}+0xaa ; 0x1d5c
        0x00001cb4:    f7fffd78    ..x.    BL       __0printf$8 ; 0x17a8
;;;62     #endif
;;;63     
;;;64         RF_BusInit();
        0x00001cb8:    f7fffc44    ..D.    BL       RF_BusInit ; 0x1544
;;;65         PAN216_Err_t ret = PAN216_Init();
        0x00001cbc:    f7feffe0    ....    BL       PAN216_Init ; 0xc80
;;;66         if (ret != PAN216_OK)
        0x00001cc0:    2800        .(      CMP      r0,#0
        0x00001cc2:    d003        ..      BEQ      0x1ccc ; main + 48
        0x00001cc4:    a028        (.      ADR      r0,{pc}+0xa4 ; 0x1d68
        0x00001cc6:    f7fffd6f    ..o.    BL       __0printf$8 ; 0x17a8
        0x00001cca:    e7fe        ..      B        0x1cca ; main + 46
;;;67             goto err_init;
;;;68     #if (!EASY_RF)
;;;69         ret = PAN216_SetUpConfig(&gRfConfig);
        0x00001ccc:    482c        ,H      LDR      r0,[pc,#176] ; [0x1d80] = 0x20000040
        0x00001cce:    f7fffa8f    ....    BL       PAN216_SetUpConfig ; 0x11f0
;;;70         if (ret != PAN216_OK)
        0x00001cd2:    2800        .(      CMP      r0,#0
        0x00001cd4:    d003        ..      BEQ      0x1cde ; main + 66
        0x00001cd6:    a02b        +.      ADR      r0,{pc}+0xae ; 0x1d84
        0x00001cd8:    f7fffd66    ..f.    BL       __0printf$8 ; 0x17a8
        0x00001cdc:    e7fe        ..      B        0x1cdc ; main + 64
;;;71             goto err_setup;
;;;72     #endif
;;;73     
;;;74         PAN216_EnableInterfaceMuxIRQ(true);
        0x00001cde:    2001        .       MOVS     r0,#1
        0x00001ce0:    f7feff01    ....    BL       PAN216_EnableInterfaceMuxIRQ ; 0xae6
;;;75         PAN216_ConfigIT(RF_IT_RX_IRQ | RF_IT_CRC_ERR_IRQ);
        0x00001ce4:    2011        .       MOVS     r0,#0x11
        0x00001ce6:    f7fefe51    ..Q.    BL       PAN216_ConfigIT ; 0x98c
;;;76         PAN216_ClearIRQFlags(0xFF);
        0x00001cea:    20ff        .       MOVS     r0,#0xff
        0x00001cec:    f7fefe48    ..H.    BL       PAN216_ClearIRQFlags ; 0x980
;;;77         PAN216_PrepareTRxWithAck(PAN216_RX, false);
        0x00001cf0:    2100        .!      MOVS     r1,#0
        0x00001cf2:    2001        .       MOVS     r0,#1
        0x00001cf4:    f7fff83a    ..:.    BL       PAN216_PrepareTRxWithAck ; 0xd6c
;;;78         PAN216_RxStart();
        0x00001cf8:    f7fff8b0    ....    BL       PAN216_RxStart ; 0xe5c
        0x00001cfc:    4d20         M      LDR      r5,[pc,#128] ; [0x1d80] = 0x20000040
;;;79     
;;;80         while (1)
;;;81         {
;;;82             while (!IRQ_DETECTED)
        0x00001cfe:    4e29        )N      LDR      r6,[pc,#164] ; [0x1da4] = 0x40020280
        0x00001d00:    1f2d        -.      SUBS     r5,r5,#4
        0x00001d02:    6970        pi      LDR      r0,[r6,#0x14]
        0x00001d04:    2800        .(      CMP      r0,#0
        0x00001d06:    d1fc        ..      BNE      0x1d02 ; main + 102
;;;83                 ;
;;;84             u8 flag = PAN216_GetIRQFlags();
        0x00001d08:    f7feffb5    ....    BL       PAN216_GetIRQFlags ; 0xc76
        0x00001d0c:    4604        .F      MOV      r4,r0
;;;85     
;;;86             if (flag & RF_IT_RX_IRQ)
        0x00001d0e:    07c0        ..      LSLS     r0,r0,#31
        0x00001d10:    d012        ..      BEQ      0x1d38 ; main + 156
;;;87             {
;;;88                 PAN216_ReadFifo(TRX_FIFO, RxBuf, 46);
        0x00001d12:    222e        ."      MOVS     r2,#0x2e
        0x00001d14:    4924        $I      LDR      r1,[pc,#144] ; [0x1da8] = 0x20000088
        0x00001d16:    2001        .       MOVS     r0,#1
        0x00001d18:    f7fff85c    ..\.    BL       PAN216_ReadFifo ; 0xdd4
;;;89                 PAN216_ClearIRQFlags(RF_IT_RX_IRQ);
        0x00001d1c:    2001        .       MOVS     r0,#1
        0x00001d1e:    f7fefe2f    ../.    BL       PAN216_ClearIRQFlags ; 0x980
;;;90                 printf("Rx[%d]:\r\n", ++count);
        0x00001d22:    6829        )h      LDR      r1,[r5,#0]
        0x00001d24:    a021        !.      ADR      r0,{pc}+0x88 ; 0x1dac
        0x00001d26:    1c49        I.      ADDS     r1,r1,#1
        0x00001d28:    6029        )`      STR      r1,[r5,#0]
        0x00001d2a:    f7fffd3d    ..=.    BL       __0printf$8 ; 0x17a8
;;;91                 printHex(RxBuf, 46);
        0x00001d2e:    212e        .!      MOVS     r1,#0x2e
        0x00001d30:    481d        .H      LDR      r0,[pc,#116] ; [0x1da8] = 0x20000088
        0x00001d32:    f000f84f    ..O.    BL       printHex ; 0x1dd4
        0x00001d36:    e7e4        ..      B        0x1d02 ; main + 102
;;;92             }
;;;93             else if (flag == RF_IT_CRC_ERR_IRQ)
        0x00001d38:    2c10        .,      CMP      r4,#0x10
        0x00001d3a:    d1e2        ..      BNE      0x1d02 ; main + 102
;;;94             {
;;;95                 PAN216_ClearIRQFlags(flag);
        0x00001d3c:    4620         F      MOV      r0,r4
        0x00001d3e:    f7fefe1f    ....    BL       PAN216_ClearIRQFlags ; 0x980
;;;96                 printf(">> RF_IT_CRC_ERR_IRQ%d\r\n", flag);
        0x00001d42:    4621        !F      MOV      r1,r4
        0x00001d44:    a01c        ..      ADR      r0,{pc}+0x74 ; 0x1db8
        0x00001d46:    f7fffd2f    ../.    BL       __0printf$8 ; 0x17a8
        0x00001d4a:    e7da        ..      B        0x1d02 ; main + 102
    $d
        0x00001d4c:    20000000    ...     DCD    536870912
        0x00001d50:    20555043    CPU     DCD    542462019
        0x00001d54:    64252040    @ %d    DCD    1680154688
        0x00001d58:    000a7a48    Hz..    DCD    686664
        0x00001d5c:    2d495053    SPI-    DCD    759779411
        0x00001d60:    4e494c34    4LIN    DCD    1313426484
        0x00001d64:    00000a45    E...    DCD    2629
        0x00001d68:    324e4150    PAN2    DCD    843989328
        0x00001d6c:    495f3631    16_I    DCD    1230976561
        0x00001d70:    2074696e    nit     DCD    544500078
        0x00001d74:    6c696166    fail    DCD    1818845542
        0x00001d78:    0d2e6465    ed..    DCD    221144165
        0x00001d7c:    0000000a    ....    DCD    10
        0x00001d80:    20000040    @..     DCD    536870976
        0x00001d84:    324e4150    PAN2    DCD    843989328
        0x00001d88:    535f3631    16_S    DCD    1398748721
        0x00001d8c:    70557465    etUp    DCD    1884648549
        0x00001d90:    666e6f43    Conf    DCD    1718513475
        0x00001d94:    66206769    ig f    DCD    1713399657
        0x00001d98:    656c6961    aile    DCD    1701603681
        0x00001d9c:    0a0d2e64    d...    DCD    168636004
        0x00001da0:    00000000    ....    DCD    0
        0x00001da4:    40020280    ...@    DCD    1073873536
        0x00001da8:    20000088    ...     DCD    536871048
        0x00001dac:    255b7852    Rx[%    DCD    626751570
        0x00001db0:    0d3a5d64    d]:.    DCD    221928804
        0x00001db4:    0000000a    ....    DCD    10
        0x00001db8:    52203e3e    >> R    DCD    1377844798
        0x00001dbc:    54495f46    F_IT    DCD    1414094662
        0x00001dc0:    4352435f    _CRC    DCD    1129464671
        0x00001dc4:    5252455f    _ERR    DCD    1381123423
        0x00001dc8:    5152495f    _IRQ    DCD    1364347231
        0x00001dcc:    0a0d6425    %d..    DCD    168649765
        0x00001dd0:    00000000    ....    DCD    0
    $t
    i.printHex
    printHex
;;; ..\..\..\..\middleware\log.c
;;;15     {
        0x00001dd4:    b570        p.      PUSH     {r4-r6,lr}
        0x00001dd6:    460d        .F      MOV      r5,r1
        0x00001dd8:    4606        .F      MOV      r6,r0
        0x00001dda:    2400        .$      MOVS     r4,#0
;;; ..\..\..\..\middleware\log.c (15)
        0x00001ddc:    e004        ..      B        0x1de8 ; printHex + 20
        0x00001dde:    5d31        1]      LDRB     r1,[r6,r4]
        0x00001de0:    a004        ..      ADR      r0,{pc}+0x14 ; 0x1df4
        0x00001de2:    f7fffce1    ....    BL       __0printf$8 ; 0x17a8
        0x00001de6:    1c64        d.      ADDS     r4,r4,#1
;;;16         for (int i = 0; i < len; i++)
        0x00001de8:    42ac        .B      CMP      r4,r5
        0x00001dea:    dbf8        ..      BLT      0x1dde ; printHex + 10
;;;17         {
;;;18             printf("%02X ", buf[i]);
;;;19         }
;;;20         printf("\r\n");
        0x00001dec:    a003        ..      ADR      r0,{pc}+0x10 ; 0x1dfc
        0x00001dee:    f7fffcdb    ....    BL       __0printf$8 ; 0x17a8
;;;21     }
        0x00001df2:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x00001df4:    58323025    %02X    DCD    1479684133
        0x00001df8:    00000020     ...    DCD    32
        0x00001dfc:    00000a0d    ....    DCD    2573
    $t
    i.spi_4line_readbyte
    spi_4line_readbyte
;;; ..\..\..\..\radio\pan216_port.c
;;;166        u8 value = 0;
        0x00001e00:    2000        .       MOVS     r0,#0
;;;167    
;;;168        for (i = 0; i < 8; i++)
        0x00001e02:    2100        .!      MOVS     r1,#0
        0x00001e04:    e011        ..      B        0x1e2a ; spi_4line_readbyte + 42
;;;169        {
;;;170            SPI_SCK_LOW;
        0x00001e06:    2200        ."      MOVS     r2,#0
        0x00001e08:    4b0b        .K      LDR      r3,[pc,#44] ; [0x1e38] = 0x40020280
        0x00001e0a:    601a        .`      STR      r2,[r3,#0]
;;;171            value <<= 1;
        0x00001e0c:    0642        B.      LSLS     r2,r0,#25
        0x00001e0e:    0e10        ..      LSRS     r0,r2,#24
;;;172            DELAY();
        0x00001e10:    bf00        ..      NOP      
;;;173            SPI_SCK_HIGH;
        0x00001e12:    2201        ."      MOVS     r2,#1
        0x00001e14:    4b08        .K      LDR      r3,[pc,#32] ; [0x1e38] = 0x40020280
        0x00001e16:    601a        .`      STR      r2,[r3,#0]
;;;174            DELAY();
        0x00001e18:    bf00        ..      NOP      
;;;175            if (SPI_DATA_STATUS)
        0x00001e1a:    4a07        .J      LDR      r2,[pc,#28] ; [0x1e38] = 0x40020280
        0x00001e1c:    6892        .h      LDR      r2,[r2,#8]
        0x00001e1e:    2a00        .*      CMP      r2,#0
        0x00001e20:    d001        ..      BEQ      0x1e26 ; spi_4line_readbyte + 38
;;;176            {
;;;177                value |= 0x01;
        0x00001e22:    2201        ."      MOVS     r2,#1
        0x00001e24:    4310        .C      ORRS     r0,r0,r2
        0x00001e26:    1c4a        J.      ADDS     r2,r1,#1
        0x00001e28:    b2d1        ..      UXTB     r1,r2
        0x00001e2a:    2908        .)      CMP      r1,#8
        0x00001e2c:    dbeb        ..      BLT      0x1e06 ; spi_4line_readbyte + 6
;;;178            }
;;;179        }
;;;180        SPI_SCK_LOW;
        0x00001e2e:    2200        ."      MOVS     r2,#0
        0x00001e30:    4b01        .K      LDR      r3,[pc,#4] ; [0x1e38] = 0x40020280
        0x00001e32:    601a        .`      STR      r2,[r3,#0]
;;;181    
;;;182        return value;
;;;183    }
        0x00001e34:    4770        pG      BX       lr
    $d
        0x00001e36:    0000        ..      DCW    0
        0x00001e38:    40020280    ...@    DCD    1073873536
    $t
    i.spi_4line_writebyte
    spi_4line_writebyte
;;; ..\..\..\..\radio\pan216_port.c (141)
        0x00001e3c:    2100        .!      MOVS     r1,#0
;;; ..\..\..\..\radio\pan216_port.c (141)
        0x00001e3e:    e017        ..      B        0x1e70 ; spi_4line_writebyte + 52
;;;142        {
;;;143            SPI_SCK_LOW;
        0x00001e40:    2200        ."      MOVS     r2,#0
        0x00001e42:    4b0e        .K      LDR      r3,[pc,#56] ; [0x1e7c] = 0x40020280
        0x00001e44:    601a        .`      STR      r2,[r3,#0]
;;;144            DELAY();
        0x00001e46:    bf00        ..      NOP      
;;;145            if (value & 0x80)
        0x00001e48:    2280        ."      MOVS     r2,#0x80
        0x00001e4a:    4002        .@      ANDS     r2,r2,r0
        0x00001e4c:    2a00        .*      CMP      r2,#0
        0x00001e4e:    d003        ..      BEQ      0x1e58 ; spi_4line_writebyte + 28
;;;146            {
;;;147                SPI_DATA_HIGH;
        0x00001e50:    2201        ."      MOVS     r2,#1
        0x00001e52:    4b0a        .K      LDR      r3,[pc,#40] ; [0x1e7c] = 0x40020280
        0x00001e54:    60da        .`      STR      r2,[r3,#0xc]
        0x00001e56:    e002        ..      B        0x1e5e ; spi_4line_writebyte + 34
;;;148            }
;;;149            else
;;;150            {
;;;151                SPI_DATA_LOW;
        0x00001e58:    2200        ."      MOVS     r2,#0
        0x00001e5a:    4b08        .K      LDR      r3,[pc,#32] ; [0x1e7c] = 0x40020280
        0x00001e5c:    60da        .`      STR      r2,[r3,#0xc]
;;;152            }
;;;153    
;;;154            value <<= 1;
        0x00001e5e:    0642        B.      LSLS     r2,r0,#25
        0x00001e60:    0e10        ..      LSRS     r0,r2,#24
;;;155            DELAY();
        0x00001e62:    bf00        ..      NOP      
;;;156            SPI_SCK_HIGH;
        0x00001e64:    2201        ."      MOVS     r2,#1
        0x00001e66:    4b05        .K      LDR      r3,[pc,#20] ; [0x1e7c] = 0x40020280
        0x00001e68:    601a        .`      STR      r2,[r3,#0]
;;;157            DELAY();
        0x00001e6a:    bf00        ..      NOP      
        0x00001e6c:    1c4a        J.      ADDS     r2,r1,#1
        0x00001e6e:    b2d1        ..      UXTB     r1,r2
        0x00001e70:    2908        .)      CMP      r1,#8
        0x00001e72:    dbe5        ..      BLT      0x1e40 ; spi_4line_writebyte + 4
;;;158        }
;;;159    
;;;160        SPI_SCK_LOW;
        0x00001e74:    2200        ."      MOVS     r2,#0
        0x00001e76:    4b01        .K      LDR      r3,[pc,#4] ; [0x1e7c] = 0x40020280
        0x00001e78:    601a        .`      STR      r2,[r3,#0]
;;;161    }
        0x00001e7a:    4770        pG      BX       lr
    $d
        0x00001e7c:    40020280    ...@    DCD    1073873536
    $t
    i.spi_cs_set_high
    spi_cs_set_high
;;; ..\..\..\..\radio\pan216_port.c (69)
        0x00001e80:    2001        .       MOVS     r0,#1
        0x00001e82:    4901        .I      LDR      r1,[pc,#4] ; [0x1e88] = 0x40020280
        0x00001e84:    6048        H`      STR      r0,[r1,#4]
;;;70     }
        0x00001e86:    4770        pG      BX       lr
    $d
        0x00001e88:    40020280    ...@    DCD    1073873536
    $t
    i.spi_cs_set_low
    spi_cs_set_low
;;;71     
;;;72     /**
;;;73      * @brief Set SPI CS low, use STM32 GPIOA4 as SPI CS pin
;;;74      * @param[in] none
;;;75      * @return none
;;;76      */
;;;77     void spi_cs_set_low(void)
;;;78     {
;;;79         SPI_CS_LOW;
        0x00001e8c:    2000        .       MOVS     r0,#0
        0x00001e8e:    4901        .I      LDR      r1,[pc,#4] ; [0x1e94] = 0x40020280
        0x00001e90:    6048        H`      STR      r0,[r1,#4]
;;;80     }
        0x00001e92:    4770        pG      BX       lr
    $d
        0x00001e94:    40020280    ...@    DCD    1073873536
    $t
    i.stackDump
    stackDump
;;; .\..\..\..\..\pan108\device\Source\pan_retarget.c
;;;33     {
        0x00001e98:    b510        ..      PUSH     {r4,lr}
        0x00001e9a:    4604        .F      MOV      r4,r0
;;;34         printf("r0  = 0x%x\r\n", stack[r0]);
        0x00001e9c:    6801        .h      LDR      r1,[r0,#0]
        0x00001e9e:    a010        ..      ADR      r0,{pc}+0x42 ; 0x1ee0
        0x00001ea0:    f7fffc82    ....    BL       __0printf$8 ; 0x17a8
;;;35         printf("r1  = 0x%x\r\n", stack[r1]);
        0x00001ea4:    a012        ..      ADR      r0,{pc}+0x4c ; 0x1ef0
        0x00001ea6:    6861        ah      LDR      r1,[r4,#4]
        0x00001ea8:    f7fffc7e    ..~.    BL       __0printf$8 ; 0x17a8
;;;36         printf("r2  = 0x%x\r\n", stack[r2]);
        0x00001eac:    a014        ..      ADR      r0,{pc}+0x54 ; 0x1f00
        0x00001eae:    68a1        .h      LDR      r1,[r4,#8]
        0x00001eb0:    f7fffc7a    ..z.    BL       __0printf$8 ; 0x17a8
;;;37         printf("r3  = 0x%x\r\n", stack[r3]);
        0x00001eb4:    a016        ..      ADR      r0,{pc}+0x5c ; 0x1f10
        0x00001eb6:    68e1        .h      LDR      r1,[r4,#0xc]
        0x00001eb8:    f7fffc76    ..v.    BL       __0printf$8 ; 0x17a8
;;;38         printf("r12 = 0x%x\r\n", stack[r12]);
        0x00001ebc:    a018        ..      ADR      r0,{pc}+0x64 ; 0x1f20
        0x00001ebe:    6921        !i      LDR      r1,[r4,#0x10]
        0x00001ec0:    f7fffc72    ..r.    BL       __0printf$8 ; 0x17a8
;;;39         printf("lr  = 0x%x\r\n", stack[lr]);
        0x00001ec4:    a01a        ..      ADR      r0,{pc}+0x6c ; 0x1f30
        0x00001ec6:    6961        ai      LDR      r1,[r4,#0x14]
        0x00001ec8:    f7fffc6e    ..n.    BL       __0printf$8 ; 0x17a8
;;;40         printf("pc  = 0x%x\r\n", stack[pc]);
        0x00001ecc:    a01c        ..      ADR      r0,{pc}+0x74 ; 0x1f40
        0x00001ece:    69a1        .i      LDR      r1,[r4,#0x18]
        0x00001ed0:    f7fffc6a    ..j.    BL       __0printf$8 ; 0x17a8
;;;41         printf("psr = 0x%x\r\n", stack[psr]);
        0x00001ed4:    a01e        ..      ADR      r0,{pc}+0x7c ; 0x1f50
        0x00001ed6:    69e1        .i      LDR      r1,[r4,#0x1c]
        0x00001ed8:    f7fffc66    ..f.    BL       __0printf$8 ; 0x17a8
;;;42     }
        0x00001edc:    bd10        ..      POP      {r4,pc}
    $d
        0x00001ede:    0000        ..      DCW    0
        0x00001ee0:    20203072    r0      DCD    538980466
        0x00001ee4:    7830203d    = 0x    DCD    2016419901
        0x00001ee8:    0a0d7825    %x..    DCD    168654885
        0x00001eec:    00000000    ....    DCD    0
        0x00001ef0:    20203172    r1      DCD    538980722
        0x00001ef4:    7830203d    = 0x    DCD    2016419901
        0x00001ef8:    0a0d7825    %x..    DCD    168654885
        0x00001efc:    00000000    ....    DCD    0
        0x00001f00:    20203272    r2      DCD    538980978
        0x00001f04:    7830203d    = 0x    DCD    2016419901
        0x00001f08:    0a0d7825    %x..    DCD    168654885
        0x00001f0c:    00000000    ....    DCD    0
        0x00001f10:    20203372    r3      DCD    538981234
        0x00001f14:    7830203d    = 0x    DCD    2016419901
        0x00001f18:    0a0d7825    %x..    DCD    168654885
        0x00001f1c:    00000000    ....    DCD    0
        0x00001f20:    20323172    r12     DCD    540160370
        0x00001f24:    7830203d    = 0x    DCD    2016419901
        0x00001f28:    0a0d7825    %x..    DCD    168654885
        0x00001f2c:    00000000    ....    DCD    0
        0x00001f30:    2020726c    lr      DCD    538997356
        0x00001f34:    7830203d    = 0x    DCD    2016419901
        0x00001f38:    0a0d7825    %x..    DCD    168654885
        0x00001f3c:    00000000    ....    DCD    0
        0x00001f40:    20206370    pc      DCD    538993520
        0x00001f44:    7830203d    = 0x    DCD    2016419901
        0x00001f48:    0a0d7825    %x..    DCD    168654885
        0x00001f4c:    00000000    ....    DCD    0
        0x00001f50:    20727370    psr     DCD    544371568
        0x00001f54:    7830203d    = 0x    DCD    2016419901
        0x00001f58:    0a0d7825    %x..    DCD    168654885
        0x00001f5c:    00000000    ....    DCD    0
    $d.realdata
    .constdata
        0x00001f60:    1537ca27    '.7.    DCD    355977767
        0x00001f64:    0000143a    :...    DCD    5178
        0x00001f68:    0309c805    ....    DCD    50972677
        0x00001f6c:    3a43030a    ..C:    DCD    977470218
        0x00001f70:    c956dd55    U.V.    DCD    3377913173
        0x00001f74:    0f5ab757    W.Z.    DCD    257603415
        0x00001f78:    e85cfc5b    [.\.    DCD    3898408027
        0x00001f7c:    025ed35d    ].^.    DCD    39768925
        0x00001f80:    0e60065f    _.`.    DCD    241174111
        0x00001f84:    34663e61    a>f4    DCD    879115873
        0x00001f88:    206e0d68    h.n     DCD    544083304
    .constdata
    TxDemodTable
        0x00001f8c:    1e1f3201    .2..    DCD    505360897
        0x00001f90:    1f18101f    ....    DCD    521670687
        0x00001f94:    101f1010    ....    DCD    270471184
        0x00001f98:    18101f10    ....    DCD    403709712
        0x00001f9c:    3301101f    ...3    DCD    855707679
        0x00001fa0:    1c3f193f    ?.?.    DCD    473897279
        0x00001fa4:    191c321b    .2..    DCD    421278235
        0x00001fa8:    1c1c191a    ....    DCD    471603482
        0x00001fac:    1c321b1c    ..2.    DCD    473045788
    TxDemodIndex
        0x00001fb0:    00030000    ....    DCD    196608
        0x00001fb4:    02000401    ....    DCD    33555457
        0x00001fb8:    06000105    ....    DCD    100663557
        0x00001fbc:    01070101    ....    DCD    17236225
        0x00001fc0:    00020802    ....    DCD    133122
        0x00001fc4:    0a010209    ....    DCD    167838217
        0x00001fc8:    030b0202    ....    DCD    51053058
        0x00001fcc:    01030c00    ....    DCD    16976896
        0x00001fd0:    0e02030d    ....    DCD    235012877
    RxDemodTable
        0x00001fd4:    10103800    .8..    DCD    269498368
        0x00001fd8:    130b0b10    ....    DCD    319490832
        0x00001fdc:    0038001f    ..8.    DCD    3670047
        0x00001fe0:    02000200    ....    DCD    33554944
        0x00001fe4:    37006000    .`.7    DCD    922771456
        0x00001fe8:    6b606060    ```k    DCD    1801478240
        0x00001fec:    007f5a6b    kZ..    DCD    8346219
        0x00001ff0:    01000036    6...    DCD    16777270
        0x00001ff4:    80000100    ....    DCD    2147483904
        0x00001ff8:    01013600    .6..    DCD    16856576
        0x00001ffc:    01000100    ....    DCD    16777472
        0x00002000:    05360040    @.6.    DCD    87425088
        0x00002004:    00040005    ....    DCD    262149
        0x00002008:    07010f06    ....    DCD    117509894
        0x0000200c:    05070707    ....    DCD    84346631
        0x00002010:    01f00807    ....    DCD    32507911
        0x00002014:    05050507    ....    DCD    84215047
        0x00002018:    0f060504    ....    DCD    252052740
        0x0000201c:    09090d01    ....    DCD    151588097
        0x00002020:    0b090609    ....    DCD    185140745
        0x00002024:    0f0f013f    ?...    DCD    252641599
        0x00002028:    0f0a0f0f    ....    DCD    252317455
        0x0000202c:    0e011f12    ....    DCD    234954514
        0x00002030:    00010100    ....    DCD    65792
        0x00002034:    01800000    ....    DCD    25165824
        0x00002038:    0000010e    ....    DCD    270
        0x0000203c:    40010101    ...@    DCD    1073807617
        0x00002040:    00011501    ....    DCD    70913
        0x00002044:    01010100    ....    DCD    16843008
        0x00002048:    015c0140    @.\.    DCD    22806848
        0x0000204c:    01010000    ....    DCD    16842752
        0x00002050:    5d018001    ...]    DCD    1560379393
        0x00002054:    00010100    ....    DCD    65792
        0x00002058:    01400000    ..@.    DCD    20971520
        0x0000205c:    0000010a    ....    DCD    266
        0x00002060:    80010001    ....    DCD    2147549185
    RxDemodIndex
        0x00002064:    00000000    ....    DCD    0
        0x00002068:    00000100    ....    DCD    256
        0x0000206c:    04000200    ....    DCD    67109376
        0x00002070:    03000001    ....    DCD    50331649
        0x00002074:    03000101    ....    DCD    50331905
        0x00002078:    04000201    ....    DCD    67109377
        0x0000207c:    03000002    ....    DCD    50331650
        0x00002080:    03000102    ....    DCD    50331906
        0x00002084:    04000202    ....    DCD    67109378
        0x00002088:    00000003    ....    DCD    3
        0x0000208c:    01010003    ....    DCD    16842755
        0x00002090:    01020003    ....    DCD    16908291
        0x00002094:    00000103    ....    DCD    259
        0x00002098:    04000203    ....    DCD    67109379
        0x0000209c:    02010203    ....    DCD    33620483
        0x000020a0:    02020203    ....    DCD    33686019
    sop8_power_table
        0x000020a4:    0000000a    ....    DCD    10
        0x000020a8:    00000007    ....    DCD    7
        0x000020ac:    00000003    ....    DCD    3
        0x000020b0:    00000008    ....    DCD    8
        0x000020b4:    0000000c    ....    DCD    12
        0x000020b8:    00000000    ....    DCD    0
        0x000020bc:    00000000    ....    DCD    0
        0x000020c0:    00000009    ....    DCD    9
        0x000020c4:    00000007    ....    DCD    7
        0x000020c8:    00000003    ....    DCD    3
        0x000020cc:    00000008    ....    DCD    8
        0x000020d0:    00000008    ....    DCD    8
        0x000020d4:    00000000    ....    DCD    0
        0x000020d8:    00000000    ....    DCD    0
        0x000020dc:    00000008    ....    DCD    8
        0x000020e0:    00000007    ....    DCD    7
        0x000020e4:    00000003    ....    DCD    3
        0x000020e8:    00000008    ....    DCD    8
        0x000020ec:    00000006    ....    DCD    6
        0x000020f0:    00000000    ....    DCD    0
        0x000020f4:    00000000    ....    DCD    0
        0x000020f8:    00000007    ....    DCD    7
        0x000020fc:    00000007    ....    DCD    7
        0x00002100:    00000003    ....    DCD    3
        0x00002104:    00000008    ....    DCD    8
        0x00002108:    00000003    ....    DCD    3
        0x0000210c:    00000000    ....    DCD    0
        0x00002110:    00000000    ....    DCD    0
        0x00002114:    00000006    ....    DCD    6
        0x00002118:    00000007    ....    DCD    7
        0x0000211c:    00000003    ....    DCD    3
        0x00002120:    00000008    ....    DCD    8
        0x00002124:    00000004    ....    DCD    4
        0x00002128:    00000000    ....    DCD    0
        0x0000212c:    00000001    ....    DCD    1
        0x00002130:    00000005    ....    DCD    5
        0x00002134:    00000007    ....    DCD    7
        0x00002138:    00000003    ....    DCD    3
        0x0000213c:    00000008    ....    DCD    8
        0x00002140:    00000002    ....    DCD    2
        0x00002144:    00000000    ....    DCD    0
        0x00002148:    00000001    ....    DCD    1
        0x0000214c:    00000004    ....    DCD    4
        0x00002150:    00000007    ....    DCD    7
        0x00002154:    00000003    ....    DCD    3
        0x00002158:    00000008    ....    DCD    8
        0x0000215c:    00000000    ....    DCD    0
        0x00002160:    00000000    ....    DCD    0
        0x00002164:    00000001    ....    DCD    1
        0x00002168:    00000003    ....    DCD    3
        0x0000216c:    00000007    ....    DCD    7
        0x00002170:    00000003    ....    DCD    3
        0x00002174:    00000008    ....    DCD    8
        0x00002178:    00000000    ....    DCD    0
        0x0000217c:    00000000    ....    DCD    0
        0x00002180:    00000002    ....    DCD    2
        0x00002184:    00000002    ....    DCD    2
        0x00002188:    00000003    ....    DCD    3
        0x0000218c:    00000003    ....    DCD    3
        0x00002190:    00000008    ....    DCD    8
        0x00002194:    00000002    ....    DCD    2
        0x00002198:    00000000    ....    DCD    0
        0x0000219c:    00000003    ....    DCD    3
        0x000021a0:    00000001    ....    DCD    1
        0x000021a4:    00000003    ....    DCD    3
        0x000021a8:    00000003    ....    DCD    3
        0x000021ac:    00000008    ....    DCD    8
        0x000021b0:    00000000    ....    DCD    0
        0x000021b4:    00000000    ....    DCD    0
        0x000021b8:    00000003    ....    DCD    3
        0x000021bc:    00000000    ....    DCD    0
        0x000021c0:    00000003    ....    DCD    3
        0x000021c4:    00000003    ....    DCD    3
        0x000021c8:    00000008    ....    DCD    8
        0x000021cc:    00000004    ....    DCD    4
        0x000021d0:    00000001    ....    DCD    1
        0x000021d4:    00000003    ....    DCD    3
        0x000021d8:    00000063    c...    DCD    99
        0x000021dc:    00000007    ....    DCD    7
        0x000021e0:    00000001    ....    DCD    1
        0x000021e4:    00000008    ....    DCD    8
        0x000021e8:    0000000f    ....    DCD    15
        0x000021ec:    00000000    ....    DCD    0
        0x000021f0:    00000000    ....    DCD    0
        0x000021f4:    000000ff    ....    DCD    255
        0x000021f8:    00000004    ....    DCD    4
        0x000021fc:    00000003    ....    DCD    3
        0x00002200:    00000008    ....    DCD    8
        0x00002204:    00000000    ....    DCD    0
        0x00002208:    00000001    ....    DCD    1
        0x0000220c:    00000003    ....    DCD    3
        0x00002210:    000000fe    ....    DCD    254
        0x00002214:    00000007    ....    DCD    7
        0x00002218:    00000001    ....    DCD    1
        0x0000221c:    0000000f    ....    DCD    15
        0x00002220:    0000000f    ....    DCD    15
        0x00002224:    00000000    ....    DCD    0
        0x00002228:    00000001    ....    DCD    1
        0x0000222c:    000000fc    ....    DCD    252
        0x00002230:    00000007    ....    DCD    7
        0x00002234:    00000001    ....    DCD    1
        0x00002238:    0000000f    ....    DCD    15
        0x0000223c:    0000000f    ....    DCD    15
        0x00002240:    00000001    ....    DCD    1
        0x00002244:    00000003    ....    DCD    3
        0x00002248:    000000fb    ....    DCD    251
        0x0000224c:    00000007    ....    DCD    7
        0x00002250:    00000001    ....    DCD    1
        0x00002254:    0000000f    ....    DCD    15
        0x00002258:    0000000f    ....    DCD    15
        0x0000225c:    00000001    ....    DCD    1
        0x00002260:    00000003    ....    DCD    3
        0x00002264:    000000f9    ....    DCD    249
        0x00002268:    00000003    ....    DCD    3
        0x0000226c:    00000001    ....    DCD    1
        0x00002270:    00000008    ....    DCD    8
        0x00002274:    00000008    ....    DCD    8
        0x00002278:    00000001    ....    DCD    1
        0x0000227c:    00000003    ....    DCD    3
        0x00002280:    000000f8    ....    DCD    248
        0x00002284:    00000003    ....    DCD    3
        0x00002288:    00000001    ....    DCD    1
        0x0000228c:    00000008    ....    DCD    8
        0x00002290:    00000004    ....    DCD    4
        0x00002294:    00000001    ....    DCD    1
        0x00002298:    00000001    ....    DCD    1
        0x0000229c:    000000f6    ....    DCD    246
        0x000022a0:    00000003    ....    DCD    3
        0x000022a4:    00000001    ....    DCD    1
        0x000022a8:    00000008    ....    DCD    8
        0x000022ac:    00000000    ....    DCD    0
        0x000022b0:    00000001    ....    DCD    1
        0x000022b4:    00000000    ....    DCD    0
        0x000022b8:    000000f5    ....    DCD    245
        0x000022bc:    00000003    ....    DCD    3
        0x000022c0:    00000001    ....    DCD    1
        0x000022c4:    00000006    ....    DCD    6
        0x000022c8:    00000000    ....    DCD    0
        0x000022cc:    00000001    ....    DCD    1
        0x000022d0:    00000000    ....    DCD    0
        0x000022d4:    000000f4    ....    DCD    244
        0x000022d8:    00000003    ....    DCD    3
        0x000022dc:    00000001    ....    DCD    1
        0x000022e0:    00000005    ....    DCD    5
        0x000022e4:    00000000    ....    DCD    0
        0x000022e8:    00000001    ....    DCD    1
        0x000022ec:    00000000    ....    DCD    0
        0x000022f0:    000000f2    ....    DCD    242
        0x000022f4:    00000003    ....    DCD    3
        0x000022f8:    00000001    ....    DCD    1
        0x000022fc:    00000004    ....    DCD    4
        0x00002300:    00000000    ....    DCD    0
        0x00002304:    00000001    ....    DCD    1
        0x00002308:    00000000    ....    DCD    0
        0x0000230c:    000000f0    ....    DCD    240
        0x00002310:    00000003    ....    DCD    3
        0x00002314:    00000001    ....    DCD    1
        0x00002318:    00000003    ....    DCD    3
        0x0000231c:    00000000    ....    DCD    0
        0x00002320:    00000001    ....    DCD    1
        0x00002324:    00000000    ....    DCD    0
        0x00002328:    000000ed    ....    DCD    237
        0x0000232c:    00000003    ....    DCD    3
        0x00002330:    00000001    ....    DCD    1
        0x00002334:    00000002    ....    DCD    2
        0x00002338:    00000000    ....    DCD    0
        0x0000233c:    00000001    ....    DCD    1
        0x00002340:    00000000    ....    DCD    0
        0x00002344:    000000e9    ....    DCD    233
        0x00002348:    00000003    ....    DCD    3
        0x0000234c:    00000001    ....    DCD    1
        0x00002350:    00000001    ....    DCD    1
        0x00002354:    00000000    ....    DCD    0
        0x00002358:    00000001    ....    DCD    1
        0x0000235c:    00000000    ....    DCD    0
        0x00002360:    000000e7    ....    DCD    231
        0x00002364:    00000002    ....    DCD    2
        0x00002368:    00000001    ....    DCD    1
        0x0000236c:    00000001    ....    DCD    1
        0x00002370:    00000000    ....    DCD    0
        0x00002374:    00000001    ....    DCD    1
        0x00002378:    00000000    ....    DCD    0
        0x0000237c:    000000e4    ....    DCD    228
        0x00002380:    00000001    ....    DCD    1
        0x00002384:    00000001    ....    DCD    1
        0x00002388:    00000001    ....    DCD    1
        0x0000238c:    00000008    ....    DCD    8
        0x00002390:    00000001    ....    DCD    1
        0x00002394:    00000000    ....    DCD    0
        0x00002398:    000000df    ....    DCD    223
        0x0000239c:    00000003    ....    DCD    3
        0x000023a0:    00000001    ....    DCD    1
        0x000023a4:    00000000    ....    DCD    0
        0x000023a8:    00000000    ....    DCD    0
        0x000023ac:    00000001    ....    DCD    1
        0x000023b0:    00000000    ....    DCD    0
        0x000023b4:    000000db    ....    DCD    219
        0x000023b8:    00000000    ....    DCD    0
        0x000023bc:    00000001    ....    DCD    1
        0x000023c0:    00000000    ....    DCD    0
        0x000023c4:    00000000    ....    DCD    0
        0x000023c8:    00000000    ....    DCD    0
        0x000023cc:    00000000    ....    DCD    0
        0x000023d0:    000000d8    ....    DCD    216
        0x000023d4:    00000000    ....    DCD    0
        0x000023d8:    00000001    ....    DCD    1
        0x000023dc:    00000000    ....    DCD    0
        0x000023e0:    00000000    ....    DCD    0
        0x000023e4:    00000001    ....    DCD    1
        0x000023e8:    00000000    ....    DCD    0
    Region$$Table$$Base
        0x000023ec:    0000240c    .$..    DCD    9228
        0x000023f0:    20000000    ...     DCD    536870912
        0x000023f4:    00000088    ....    DCD    136
        0x000023f8:    000017fc    ....    DCD    6140
        0x000023fc:    00002494    .$..    DCD    9364
        0x00002400:    20000088    ...     DCD    536871048
        0x00002404:    00000830    0...    DCD    2096
        0x00002408:    0000180c    ....    DCD    6156
    Region$$Table$$Limit

** Section #2 'RW_IRAM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 136 bytes (alignment 4)
    Address: 0x20000000

    0x20000000:   00 00 00 00 00 00 00 00 00 00 00 00 3d 1e 00 00    ............=...
    0x20000010:   01 1e 00 00 81 1e 00 00 8d 1e 00 00 89 03 00 00    ................
    0x20000020:   6d 03 00 00 00 00 00 01 3c 07 00 43 30 00 44 f0    m.......<..C0.D.
    0x20000030:   00 44 0f 01 46 01 01 46 0c 00 00 00 00 00 00 00    .D..F..F........
    0x20000040:   4e 00 00 00 01 00 04 cc cc cc cc cc 04 01 cc cc    N...............
    0x20000050:   cc cc cc 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x20000060:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x20000070:   00 2a 2a 00 00 01 00 01 00 00 30 75 00 00 00 00    .**.......0u....
    0x20000080:   00 00 02 00 00 00 00 00                            ........


** Section #3 'RW_IRAM1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 2096 bytes (alignment 8)
    Address: 0x20000088


** Section #4 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #5 '.debug_frame' (SHT_PROGBITS)
    Size   : 3416 bytes


** Section #6 '.debug_info' (SHT_PROGBITS)
    Size   : 83944 bytes


** Section #7 '.debug_line' (SHT_PROGBITS)
    Size   : 18412 bytes


** Section #8 '.debug_loc' (SHT_PROGBITS)
    Size   : 7484 bytes


** Section #9 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 234324 bytes


** Section #10 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 4442 bytes


** Section #11 '.symtab' (SHT_SYMTAB)
    Size   : 9104 bytes (alignment 4)
    String table #12 '.strtab'
    Last local symbol no. 341


** Section #12 '.strtab' (SHT_STRTAB)
    Size   : 8292 bytes


** Section #13 '.note' (SHT_NOTE)
    Size   : 28 bytes (alignment 4)


** Section #14 '.comment' (SHT_PROGBITS)
    Size   : 21508 bytes


** Section #15 '.shstrtab' (SHT_STRTAB)
    Size   : 156 bytes


address     size       variable name                            type
0x20000088  0x2e       RxBuf                                    array[46] of u8

address     size       variable name                            type
0x2000003c  0x4        count                                    int

address     size       variable name                            type
0x20000040  0x44       gRfConfig                                RFConfig_t
0x20000040  0x1        gRfConfig.Channel                        uint8_t
0x20000041  0x1        gRfConfig.TxPower                        PAN216_TxPower_t
0x20000042  0x1        gRfConfig.DataRate                       PAN216_DataRate_t
0x20000043  0x1        gRfConfig.Crc                            PAN216_Crc_t
0x20000044  0x1        gRfConfig.ChipMode                       PAN216_ChipMode_t
0x20000045  0x1        gRfConfig.WorkMode                       PAN216_WorkMode_t
0x20000046  0x1        gRfConfig.TxAddrWidth                    PAN216_AddrWidth_t
0x20000047  0x5        gRfConfig.TxAddr                         array[5] of uint8_t
0x2000004c  0x1        gRfConfig.RxAddrWidth                    PAN216_AddrWidth_t
0x2000004d  0x24       gRfConfig.RxAddr                         array[6] of RxPipeAddr_t
0x20000071  0x1        gRfConfig.TxLen                          u8
0x20000072  0x1        gRfConfig.RxLen                          u8
0x20000073  0x1        gRfConfig.EnWhite                        _Bool
0x20000074  0x1        gRfConfig.EnDPL                          _Bool
0x20000075  0x1        gRfConfig.EnTxNoAck                      _Bool
0x20000076  0x1        gRfConfig.crcSkipAddr                    _Bool
0x20000077  0x1        gRfConfig.Endian                         PAN216_Endian_t
0x20000078  0x2        gRfConfig.TRxDelayTimeUs                 u16
0x2000007a  0x2        gRfConfig.RxTimeoutUs                    u16
0x2000007c  0x2        gRfConfig.AutoDelayUs                    u16
0x2000007e  0x1        gRfConfig.AutoMaxCnt                     u8
0x2000007f  0x1        gRfConfig.EnManuPid                      u8
0x20000080  0x1        gRfConfig.EnRxPlLenLimit                 _Bool
0x20000081  0x1        gRfConfig.TxMode                         PAN216_TxMode_t
0x20000082  0x1        gRfConfig.RxMode                         PAN216_RxMode_t

address     size       variable name                            type
0x00002064  0x40       RxDemodIndex                             array[16] of const anonymous

address     size       variable name                            type
0x00001fd4  0x90       RxDemodTable                             array[16] of const anonymous

address     size       variable name                            type
0x00001fb0  0x24       TxDemodIndex                             array[12] of const anonymous

address     size       variable name                            type
0x00001f8c  0x24       TxDemodTable                             array[2] of const anonymous

address     size       variable name                            type
0x20000024  0x1        _gChipMode                               uint8_t

address     size       variable name                            type
0x20000025  0x1        _gDataRate                               uint8_t

address     size       variable name                            type
0x20000026  0x1        _gS2S8Mode                               uint8_t

address     size       variable name                            type
0x000020a4  0x348      sop8_power_table                         array[30] of const anonymous

address     size       variable name                            type
0x20000027  0x12       sop8_power_table_reg                     array[6] of array[3] of uint8_t

address     size       variable name                            type
0x2000000c  0x18       Pan216_Funs                              PAN216_Fun_t
0x2000000c  0x4        Pan216_Funs.spi_writebyte                pointer to function 
0x20000010  0x4        Pan216_Funs.spi_readbyte                 pointer to function 
0x20000014  0x4        Pan216_Funs.spi_cs_high                  pointer to function 
0x20000018  0x4        Pan216_Funs.spi_cs_low                   pointer to function 
0x2000001c  0x4        Pan216_Funs.delayus                      pointer to function 
0x20000020  0x4        Pan216_Funs.delayms                      pointer to function 

address     size       variable name                            type
0x20000008  0x4        g_SystemTick                             volatile uint32_t

address     size       variable name                            type
0x00000000  0x1        PanFlashEnhanceEnable                    const _Bool

address     size       variable name                            type
0x00000000  0x4        PanFlashLineMode                         const uint32_t

address     size       variable name                            type
0x00000000  0x4        SocTemperature                           float

address     size       variable name                            type
0x20000000  0x4        SystemCoreClock                          uint32_t

address     size       variable name                            type
0x00000000  0x100      otp                                      OTP_STRUCT_T
0x00000000  0x100      otp.d8                                   array[256] of uint8_t
0x00000000  0x100      otp.m                                    anonymous
0x00000000  0x1        otp.m.rsvd0                              uint8_t
0x00000001  0x1        otp.m.mp_ver                             uint8_t
0x00000002  0x1        otp.m.chip_ver                           uint8_t
0x00000003  0x1        otp.m.cp_version                         uint8_t
0x00000004  0x8        otp.m.uid                                array[8] of uint8_t
0x0000000c  0x1        otp.m.wafer_number                       uint8_t
0x0000000d  0x1(4:4)   otp.m.ana_ldo                            uint8_t
0x0000000d  0x1(0:4)   otp.m.rffe_ldo                           uint8_t
0x0000000e  0x1(4:4)   otp.m.fsync_ldo                          uint8_t
0x0000000e  0x1(0:4)   otp.m.rxadc_ldo                          uint8_t
0x0000000f  0x1(4:4)   otp.m.vco_ldo                            uint8_t
0x0000000f  0x1(0:4)   otp.m.temp_low                           uint8_t
0x00000010  0x1        otp.m.temp_high                          uint8_t
0x00000011  0x1        otp.m.c_rch                              uint8_t
0x00000012  0x4        otp.m.f_rch                              uint32_t
0x00000016  0x1(2:6)   otp.m.rcl_coarse                         uint8_t
0x00000016  0x1(0:2)   otp.m.rsvd1                              uint8_t
0x00000017  0x1(2:6)   otp.m.rcl_fine                           uint8_t
0x00000017  0x1(0:2)   otp.m.rsvd2                              uint8_t
0x00000018  0x1(4:4)   otp.m.rsvd3                              uint8_t
0x00000018  0x1(1:3)   otp.m.rcl_rsvd_1                         uint8_t
0x00000018  0x1(0:1)   otp.m.rsvd3_1                            uint8_t
0x00000019  0x2        otp.m.f_rcl                              uint16_t
0x0000001b  0x6        otp.m.mac_addr                           array[6] of uint8_t
0x00000021  0x1(5:3)   otp.m.c_lldo                             uint8_t
0x00000021  0x1(4:1)   otp.m.rsvd4                              uint8_t
0x00000021  0x1(0:4)   otp.m.v_lldo_low                         uint8_t
0x00000022  0x1        otp.m.v_lldo_high                        uint8_t
0x00000023  0x1(4:4)   otp.m.c_hldo                             uint8_t
0x00000023  0x1(0:4)   otp.m.v_hldo_low                         uint8_t
0x00000024  0x1        otp.m.v_hldo_high                        uint8_t
0x00000025  0x1(5:3)   otp.m.c_vbg                              uint8_t
0x00000025  0x1(4:1)   otp.m.rsvd5                              uint8_t
0x00000025  0x1(0:4)   otp.m.v_vbg_low                          uint8_t
0x00000026  0x1        otp.m.v_vbg_high                         uint8_t
0x00000027  0x1(2:6)   otp.m.c_adcvbg                           uint8_t
0x00000027  0x1(0:2)   otp.m.rsvd6                              uint8_t
0x00000028  0x2        otp.m.v_adcvbg                           uint16_t
0x0000002a  0x1(4:4)   otp.m.rsvd7                              uint8_t
0x0000002a  0x1(0:4)   otp.m.c_temp_low                         uint8_t
0x0000002b  0x1        otp.m.c_temp_high                        uint8_t
0x0000002c  0x1        otp.m.lldo_p56_4b                        uint8_t
0x0000002d  0x1        otp.m.lldo_kscan_4b                      uint8_t
0x0000002e  0x2        otp.m.rsvd8                              array[2] of uint8_t
0x00000030  0x3        otp.m.adc_data_vbgcode_00                array[3] of uint8_t
0x00000033  0x3        otp.m.adc_data_vbgcode_3f                array[3] of uint8_t
0x00000036  0x1        otp.m.c_vdd_4_high                       uint8_t
0x00000037  0x1(4:4)   otp.m.v_bat_low                          uint8_t
0x00000037  0x1(0:4)   otp.m.c_vdd_4_low                        uint8_t
0x00000038  0x1        otp.m.v_bat_high                         uint8_t
0x00000039  0x2        otp.m.adc_vdd_k                          uint16_t
0x0000003b  0x2        otp.m.adc_vdd_b                          uint16_t
0x0000003d  0x1(5:3)   otp.m.c_bodref                           uint8_t
0x0000003d  0x1(4:1)   otp.m.rsvd9                              uint8_t
0x0000003d  0x1(0:4)   otp.m.v_bodref_low                       uint8_t
0x0000003e  0x1        otp.m.v_bodref_high                      uint8_t
0x0000003f  0x2        otp.m.adc_vbg_k                          uint16_t
0x00000041  0x2        otp.m.adc_vbg_b                          uint16_t
0x00000043  0x1        otp.m.lldo_p56                           uint8_t
0x00000044  0x1        otp.m.lldo_kscan                         uint8_t
0x00000045  0x1        otp.m.lldo_timer                         uint8_t
0x00000046  0x1        otp.m.lldo_m0                            uint8_t
0x00000047  0x1(5:3)   otp.m.id_buck_vc                         uint8_t
0x00000047  0x1(0:5)   otp.m.rsvd10                             uint8_t
0x00000048  0x1(3:5)   otp.m.id_buck_i                          uint8_t
0x00000048  0x1(0:3)   otp.m.rsvd11                             uint8_t
0x00000049  0x1        otp.m.id_buck_freq                       uint8_t
0x0000004a  0x1(3:5)   otp.m.id_buck_refcal                     uint8_t
0x0000004a  0x1(0:3)   otp.m.rsvd12                             uint8_t
0x0000004b  0x1(2:6)   otp.m.c_adcvbg1                          uint8_t
0x0000004b  0x1(0:2)   otp.m.rsvd13                             uint8_t
0x0000004c  0x2        otp.m.v_adcvbg1                          uint16_t
0x0000004e  0x1        otp.m.sram_test_flag                     uint8_t
0x0000004f  0x1(4:4)   otp.m.rsvd14                             uint8_t
0x0000004f  0x1(0:4)   otp.m.c_temp_low_1                       uint8_t
0x00000050  0x1        otp.m.c_temp_high_1                      uint8_t
0x00000051  0x1        otp.m.rf1                                uint8_t
0x00000052  0x1        otp.m.ft_version                         uint8_t
0x00000053  0x1        otp.m.cp_checksum                        uint8_t
0x00000054  0x1        otp.m.ft_checksum                        uint8_t
0x00000055  0xb        otp.m.rsvd15                             array[11] of uint8_t
0x00000060  0x21       otp.m.adc_data_refvbg                    array[33] of uint8_t
0x00000081  0x3e       otp.m.rsvd16                             array[62] of uint8_t
0x000000bf  0x1        otp.m.feature_ctrl                       uint8_t
0x000000c0  0x10       otp.m.aes_key                            array[16] of uint8_t
0x000000d0  0x1(7:1)   otp.m.secure_enabled                     uint8_t
0x000000d0  0x1(6:1)   otp.m.anti_inject_en                     uint8_t
0x000000d0  0x1(0:6)   otp.m.rsvd17                             uint8_t
0x000000d1  0x3        otp.m.flash_enc_ofst                     array[3] of uint8_t
0x000000d4  0x14       otp.m.user_ro_data                       array[20] of uint8_t
0x000000e8  0x1        otp.m.misoperate_flag                    uint8_t
0x000000e9  0x17       otp.m.user_rw_data                       array[23] of uint8_t

